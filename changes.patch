diff --git a/B-1B-set.xml b/B-1B-set.xml
index cd464b0..dd64a04 100644
--- a/B-1B-set.xml
+++ b/B-1B-set.xml
@@ -345,11 +345,12 @@ B-1B set file.
                             <script>weapons.repair_damage()</script>
                         </binding>
                     </item>
-                    <item n="4">
+                    <item>
                         <label>Targeting Computer</label>
+                        <name>targeting_comp</name>
                         <binding>
-                            <command>nasal</command>
-                            <script>weapons.targeting_comp.open()</script>
+                            <command>dialog-show</command>
+                            <dialog-name>targeting_comp</dialog-name>
                         </binding>
                     </item>
                     <item n="10">
@@ -772,6 +773,15 @@ B-1B set file.
             <lightning type="bool" archive="y">true</lightning>
             <display-mode archive="y">arc</display-mode>
         </wxradar>
+        <datalink>
+            <data type="int">0</data>
+            <power type="bool">false</power>
+            <channel type="int">42</channel>
+            <power_prop type="string">/instrumentation/datalink/power</power_prop>
+            <channel_prop type="string">instrumentation/datalink/channel</channel_prop>
+            <receive_period type="double">1</receive_period>
+            <!--identifier_prop type="string">instrumentation/datalink/ident</identifier_prop-->
+        </datalink>
     </instrumentation>
 
     <input>
@@ -949,8 +959,21 @@ B-1B set file.
         <view>
           <file>Aircraft/B-1B/Nasal/MissileView.nas</file>
         </view>
+        <tgp>
+          <file>Aircraft/B-1B/Nasal/tgp.nas</file>
+        </tgp>
+        <tacview>
+            <file>Aircraft/B-1B/Nasal/tacview.nas</file>
+        </tacview>
+        <datalink>
+            <file>Aircraft/B-1B/Nasal/datalink.nas</file>
+        </datalink>
+        <steerpoints>
+            <file>Aircraft/B-1B/Nasal/steerpoints.nas</file>
+        </steerpoints>
         <radar_system>
             <file>Aircraft/B-1B/Nasal/radar/radar-system.nas</file>
+            <file>Aircraft/B-1B/Nasal/radar/apg-68.nas</file>
             <file>Aircraft/B-1B/Nasal/radar/rwr_new.nas</file>
         </radar_system>
         <armament>
diff --git a/Dialogs/targeting_comp.xml b/Dialogs/targeting_comp.xml
deleted file mode 100644
index c6da14e..0000000
--- a/Dialogs/targeting_comp.xml
+++ /dev/null
@@ -1,614 +0,0 @@
-<PropertyList>
-
-    <name>targeting_comp</name>
-    <modal>false</modal>
-    <layout>vbox</layout>
-    <width>850</width>
-    <!--    <height>450</height>-->
-    <nasal>
-        <open><![CDATA[
-        setprop("b1/preplanning-status", "");
-        var load_stpts = func(path) {
-            data.loadSTPTs(path.getValue());
-        }
-        var save_stpts = func(path) {
-            data.saveSTPTs(path.getValue());
-        }
-
-        var defaultDirInFileSelector = getprop("/sim/fg-home") ~ "/Export";
-
-        var file_selector_dtc = gui.FileSelector.new(
-            callback: load_stpts, title: "Load data", button: "Load",
-            dir: defaultDirInFileSelector, dotfiles: 1, pattern: ["*.b1dtc"]);
-        var save_selector_dtc = gui.FileSelector.new(
-            callback: save_stpts, title: "Save data", button: "Save",
-            dir: defaultDirInFileSelector, dotfiles: 1, file: "b1-dtc-data.b1dtc", pattern: ["*.b1dtc"]);
-
-    ]]></open>
-
-        <close><![CDATA[
-        file_selector_dtc.del();
-        save_selector_dtc.del();
-    ]]></close>
-    </nasal>
-    <group>
-        <layout>hbox</layout>
-        <text>
-            <halign>center</halign>
-            <label>Targeting Computer</label>
-        </text>
-    </group>
-    <hrule/>
-    <group>
-        <layout>hbox</layout>
-        <group>
-            <!-- ********************************* FWD BAY ************************************ -->
-            <layout>vbox</layout>
-
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <halign>center</halign>
-                    <label>FWD Bay</label>
-                </text>
-            </group>
-
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>1 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[0]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[0]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>2 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[1]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[1]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>3 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[2]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[2]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>4 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[3]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[3]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>5 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[4]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[4]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>6 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[5]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[5]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>7 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[6]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[6]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>8 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay0/bomb[7]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay0/bomb[7]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-        </group>
-        <vrule/>
-        <group>
-            <layout>vbox</layout>
-            <!-- ********************************* IMD BAY ************************************ -->
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>IMD Bay</label>
-                    <halign>center</halign>
-                </text>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>1 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[0]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[0]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>2 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[1]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[1]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>3 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[2]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[2]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>4 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[3]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[3]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>5 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[4]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[4]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>6 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[5]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[5]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>7 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[6]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[6]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>8 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay1/bomb[7]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay1/bomb[7]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-        </group>
-        <vrule/>
-        <group>
-            <layout>vbox</layout>
-            <!-- ********************************* AFT BAY ************************************ -->
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>AFT Bay</label>
-                    <halign>center</halign>
-                </text>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>1 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[0]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[0]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>2 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[1]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[1]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>3 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[2]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[2]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>4 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[3]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[3]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>5 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[4]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[4]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>6 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[5]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[5]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>7 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[6]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[6]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-            <group>
-                <layout>hbox</layout>
-                <text>
-                    <label>8 (Lat/Lon):</label>
-                </text>
-                <input>
-                    <property>/ai/guided/bay2/bomb[7]/target-latitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-                <input>
-                    <property>/ai/guided/bay2/bomb[7]/target-longitude-deg</property>
-                    <binding>
-                        <command>dialog-apply</command>
-                    </binding>
-                </input>
-            </group>
-        </group>
-    </group>
-    <hrule/>
-    <group>
-        <layout>hbox</layout>
-        <text>
-            <halign>left</halign>
-            <live>true</live>
-            <format>I/O Status: %s</format>
-            <property>b1/preplanning-status</property>
-        </text>
-        <button>
-            <legend>Load DTC</legend>
-            <equal>true</equal>
-            <binding>
-                <command>nasal</command>
-                <script>file_selector_dtc.open()</script>
-            </binding>
-            <binding>
-                <command>dialog-update</command>
-            </binding>
-        </button>
-        <button>
-            <legend>Save DTC</legend>
-            <equal>true</equal>
-            <enable>
-                <value>1</value>
-            </enable>
-            <binding>
-                <command>dialog-apply</command>
-            </binding>
-            <binding>
-                <command>nasal</command>
-                <script>save_selector_dtc.open();</script>
-            </binding>
-        </button>
-    </group>
-    <hrule/>
-    <!-- ********************************* CLOSE BUTTON ************************************* -->
-    <group>
-        <layout>hbox</layout>
-        <button>
-            <legend>Close</legend>
-            <halign>center</halign>
-            <binding>
-                <command>nasal</command>
-                <script>
-                    <![CDATA[
-		    data.syncData();
-	    ]]>
-                </script>
-            </binding>
-            <binding>
-                <command>dialog-close</command>
-            </binding>
-        </button>
-    </group>
-
-
-    <!--<text>
-      <label>Weapon Management</label>
-    </text>
-
-        var tlat = getprop("ai/guided/bay"~ b ~"/bomb["~ n ~"]/target-latitude-deg");
-  var tlong = getprop("ai/guided/bay"~ b ~"/bomb["~ n ~"]/target-longitude-deg");
-
-   <hrule/>
-
-    <nasal>
-      <open>
-      #nasal
-      </open>
-    </nasal>
-
-
-      <text>
-      <label>Load Weapons</label>
-     </text>
-      <text>
-      <label></label>
-     </text>
-    <group>
-     <layout>vbox</layout>
-
-      <text>
-      <label>Load bays with 8 guidable GBU-31 2000lb bombs</label>
-      <halign>left</halign>
-     </text>
-
-    <button>
-      <legend>Load Guided Ordonance - FWD</legend>
-      <default>true</default>
-      <pref-width>230</pref-width>
-        <binding>
-          <command>nasal</command>
-          <script>weapons.wpn_load(0)</script>
-        </binding>
-            <binding>
-              <command>dialog-apply</command>
-            </binding>
-    </button>-->
-
-</PropertyList>
\ No newline at end of file
diff --git a/Nasal/Radar/apg-68.nas b/Nasal/Radar/apg-68.nas
new file mode 100644
index 0000000..3b2f73f
--- /dev/null
+++ b/Nasal/Radar/apg-68.nas
@@ -0,0 +1,3515 @@
+
+
+
+
+
+############# BEGIN SOMEWHAT GENERIC CLASSES ###########################################
+
+
+
+# Field of regard requests
+var FOR_ROUND  = 0;# TODO: be able to ask noseradar for round field of regard.
+var FOR_SQUARE = 1;
+#Pulses
+var DOPPLER = 1;
+var MONO = 0;
+
+var overlapHorizontal = 1.5;
+
+
+#   █████  ██ ██████  ██████   ██████  ██████  ███    ██ ███████     ██████   █████  ██████   █████  ██████
+#  ██   ██ ██ ██   ██ ██   ██ ██    ██ ██   ██ ████   ██ ██          ██   ██ ██   ██ ██   ██ ██   ██ ██   ██
+#  ███████ ██ ██████  ██████  ██    ██ ██████  ██ ██  ██ █████       ██████  ███████ ██   ██ ███████ ██████
+#  ██   ██ ██ ██   ██ ██   ██ ██    ██ ██   ██ ██  ██ ██ ██          ██   ██ ██   ██ ██   ██ ██   ██ ██   ██
+#  ██   ██ ██ ██   ██ ██████   ██████  ██   ██ ██   ████ ███████     ██   ██ ██   ██ ██████  ██   ██ ██   ██
+#
+#
+var AirborneRadar = {
+	#
+	# This is an base class for an airborne forward looking radar
+	# The class RadarMode uses this. Subclass as needed.
+	#
+	# TODO: Cleaner calls to optional ground mapper
+	#
+	fieldOfRegardType: FOR_SQUARE,
+	fieldOfRegardMaxAz: 60,
+	fieldOfRegardMaxElev: 60,
+	fieldOfRegardMinElev: -60,
+	currentMode: nil, # vector of cascading modes ending with current submode
+	currentModeIndex: nil,
+	rootMode: 0,
+	mainModes: nil,
+	instantFoVradius: 2.0,#average of horiz/vert radius
+	instantVertFoVradius: 2.5,# real vert radius (could be used by ground mapper)
+	instantHoriFoVradius: 1.5,# real hori radius (not used)
+	rcsRefDistance: 70,
+	rcsRefValue: 3.2,
+	#closureReject: -1, # The minimum kt closure speed it will pick up, else rejected.
+	#positionEuler: [0,0,0,0],# euler direction
+	positionDirection: [1,0,0],# vector direction
+	positionCart: [0,0,0,0],
+	eulerX: 0,
+	eulerY: 0,
+	horizonStabilized: 1, # When true antennae ignore roll (and pitch until its high)
+	vector_aicontacts_for: [],# vector of contacts found in field of regard
+	vector_aicontacts_bleps: [],# vector of not timed out bleps
+	chaffList: [],
+	chaffSeenList: [],
+	chaffFilter: 0.60,# 1=filters all chaff, 0=sees all chaff all the time
+	timer: nil,
+	timerMedium: nil,
+	timerSlow: nil,
+	timeToKeepBleps: 13,
+	elapsed: elapsedProp.getValue(),
+	lastElapsed: elapsedProp.getValue(),
+	debug: 0,
+	newAirborne: func (mainModes, child) {
+		var rdr = {parents: [child, AirborneRadar, Radar]};
+
+		rdr.mainModes = mainModes;
+
+		foreach (modes ; mainModes) {
+			foreach (mode ; modes) {
+				# this needs to be set on submodes also...hmmm
+				mode.radar = rdr;
+			}
+		}
+
+		rdr.currentModeIndex = setsize([], size(mainModes));
+		forindex (var i; rdr.currentModeIndex) {
+			rdr.currentModeIndex[i] = 0;
+		}
+
+		rdr.setCurrentMode(rdr.mainModes[0][0], nil);
+
+		rdr.SliceNotification = SliceNotification.new();
+		rdr.ContactNotification = VectorNotification.new("ContactNotification");
+		rdr.ActiveDiscRadarRecipient = emesary.Recipient.new("ActiveDiscRadarRecipient");
+		rdr.ActiveDiscRadarRecipient.radar = rdr;
+		rdr.ActiveDiscRadarRecipient.Receive = func(notification) {
+	        if (notification.NotificationType == "FORNotification") {
+	        	#printf("DiscRadar recv: %s", notification.NotificationType);
+	            #if (rdr.enabled == 1) { no, lets keep this part running, so we have fresh data when its re-enabled
+	    		    rdr.vector_aicontacts_for = notification.vector;
+	    		    rdr.purgeBleps();
+	    		    #print("size(rdr.vector_aicontacts_for)=",size(rdr.vector_aicontacts_for));
+	    	    #}
+	            return emesary.Transmitter.ReceiptStatus_OK;
+	        }
+	        if (notification.NotificationType == "ChaffReleaseNotification") {
+	    		rdr.chaffList ~= notification.vector;
+	            return emesary.Transmitter.ReceiptStatus_OK;
+	        }
+	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+	    };
+		emesary.GlobalTransmitter.Register(rdr.ActiveDiscRadarRecipient);
+		rdr.timer = maketimer(scanInterval, rdr, func rdr.loop());
+		rdr.timerSlow = maketimer(0.75, rdr, func rdr.loopSlow());
+		rdr.timerMedium = maketimer(0.25, rdr, func rdr.loopMedium());
+		rdr.timerMedium.start();
+		rdr.timerSlow.start();
+		rdr.timer.start();
+    	return rdr;
+	},
+	getTiltKnob: func {
+		me.theKnob = antennae_knob_prop.getValue();
+		if (math.abs(me.theKnob) < 0.01) {
+			antennae_knob_prop.setValue(0);
+			me.theKnob = 0;
+		}
+		return me.theKnob*60;
+	},
+	increaseRange: func {
+		if (me["gmapper"] != nil) me.gmapper.clear();
+		me.currentMode.increaseRange();
+	},
+	decreaseRange: func {
+		if (me["gmapper"] != nil) me.gmapper.clear();
+		me.currentMode.decreaseRange();
+	},
+	designate: func (designate_contact) {
+		me.currentMode.designate(designate_contact);
+	},
+	designateRandom: func {
+		# Use this method mostly for testing
+		if (size(me.vector_aicontacts_bleps) > 0) {
+			me.designate(me.vector_aicontacts_bleps[size(me.vector_aicontacts_bleps)-1]);
+		}
+	},
+	undesignate: func {
+		me.currentMode.undesignate();
+	},
+	getPriorityTarget: func {
+		if (!me.enabled) return nil;
+		return me.currentMode.getPriority();
+	},
+	cycleDesignate: func {
+		me.currentMode.cycleDesignate();
+	},
+	cycleMode: func {
+		me.currentModeIndex[me.rootMode] += 1;
+		if (me.currentModeIndex[me.rootMode] >= size(me.mainModes[me.rootMode])) {
+			me.currentModeIndex[me.rootMode] = 0;
+		}
+		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+		me.newMode.setRange(me.currentMode.getRange());
+		me.oldMode = me.currentMode;
+		me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+	},
+	cycleRootMode: func {
+		me.rootMode += 1;
+		if (me.rootMode >= size(me.mainModes)) {
+			me.rootMode = 0;
+		}
+
+		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+		#me.newMode.setRange(me.currentMode.getRange());
+		me.oldMode = me.currentMode;
+		me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+	},
+	cycleAZ: func {
+		if (me["gmapper"] != nil) me.gmapper.clear();
+		me.clearShowScan();
+		me.currentMode.cycleAZ();
+	},
+	cycleBars: func {
+		me.currentMode.cycleBars();
+		me.clearShowScan();
+	},
+	getDeviation: func {
+		return me.currentMode.getDeviation();
+	},
+	setCursorDeviation: func (cursor_az) {
+		return me.currentMode.setCursorDeviation(cursor_az);
+	},
+	getCursorDeviation: func {
+		return me.currentMode.getCursorDeviation();
+	},
+	setCursorDistance: func (nm) {
+		# Return if the cursor should be distance zeroed.
+		return me.currentMode.setCursorDistance(nm);;
+	},
+	getCursorAltitudeLimits: func {
+		if (!me.enabled) return nil;
+		return me.currentMode.getCursorAltitudeLimits();
+	},
+	getBars: func {
+		return me.currentMode.getBars();
+	},
+	getAzimuthRadius: func {
+		return me.currentMode.getAz();
+	},
+	getMode: func {
+		return me.currentMode.shortName;
+	},
+	setCurrentMode: func (new_mode, priority = nil) {
+		me.olderMode = me.currentMode;
+		me.currentMode = new_mode;
+		new_mode.radar = me;
+		#new_mode.setCursorDeviation(me.currentMode.getCursorDeviation()); # no need since submodes don't overwrite this
+		new_mode.designatePriority(priority);
+		if (me.olderMode != nil) me.olderMode.leaveMode();
+		new_mode.enterMode();
+		settimer(func me.clearShowScan(), 0.5);
+	},
+	setRootMode: func (mode_number, priority = nil) {
+		me.rootMode = mode_number;
+		if (me.rootMode >= size(me.mainModes)) {
+			me.rootMode = 0;
+		}
+
+		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+		#me.newMode.setRange(me.currentMode.getRange());
+		me.oldMode = me.currentMode;
+		me.setCurrentMode(me.newMode, priority);
+	},
+	getRange: func {
+		return me.currentMode.getRange();
+	},
+	getCaretPosition: func {
+		if (me["eulerX"] == nil or me["eulerY"] == nil) {
+			return [0,0];
+		} elsif (me.horizonStabilized) {
+			return [me.eulerX/me.fieldOfRegardMaxAz,me.eulerY/me.fieldOfRegardMaxElev];
+		} else {
+			return [me.eulerX/me.fieldOfRegardMaxAz,me.eulerY/me.fieldOfRegardMaxElev];
+		}
+	},
+	setAntennae: func (local_dir) {
+		# remember to set horizonStabilized when calling this.
+
+		# convert from coordinates to polar
+		me.eulerDir = vector.Math.cartesianToEuler(local_dir);
+
+		# Make sure if pitch is 90 or -90 that heading gets set to something sensible
+		me.eulerX = me.eulerDir[0]==nil?0:geo.normdeg180(me.eulerDir[0]);
+		me.eulerY = me.eulerDir[1];
+
+		# Make array: [heading_degs, pitch_degs, heading_norm, pitch_norm], for convinience, not used atm.
+		#me.positionEuler = [me.eulerX,me.eulerDir[1],me.eulerX/me.fieldOfRegardMaxAz,me.eulerDir[1]/me.fieldOfRegardMaxElev];
+
+		# Make the antennae direction-vector be length 1.0
+		me.positionDirection = vector.Math.normalize(local_dir);
+
+		# Decompose the antennae direction-vector into seperate angles for Azimuth and Elevation
+		me.posAZDeg = -90+R2D*math.acos(vector.Math.normalize(vector.Math.projVectorOnPlane([0,0,1],me.positionDirection))[1]);
+		me.posElDeg = R2D*math.asin(vector.Math.normalize(vector.Math.projVectorOnPlane([0,1,0],me.positionDirection))[2]);
+
+		# Make an array that holds: [azimuth_norm, elevation_norm, azimuth_deg, elevation_deg]
+		me.positionCart = [me.posAZDeg/me.fieldOfRegardMaxAz, me.posElDeg/me.fieldOfRegardMaxElev,me.posAZDeg,me.posElDeg];
+
+		# Note: that all these numbers can be either relative to aircraft or relative to scenery.
+		# Its the modes responsibility to call this method with antennae local_dir that is either relative to
+		# aircraft, or to landscape so that they match how scanFOV compares the antennae direction to target positions.
+		#
+		# Make sure that scanFOV() knows what coord system you are operating in. By setting me.horizonStabilized.
+	},
+	installMapper: func (gmapper) {
+		me.gmapper = gmapper;
+	},
+	isEnabled: func {
+		return 1;
+	},
+	loop: func {
+		me.enabled = me.isEnabled();
+		setprop("instrumentation/radar/radar-standby", !me.enabled);
+		# calc dt here, so we don't get a massive dt when going from disabled to enabled:
+		me.elapsed = elapsedProp.getValue();
+		me.dt = me.elapsed - me.lastElapsed;
+		me.lastElapsed = me.elapsed;
+		if (me.enabled) {
+			if (me.currentMode.painter and me.currentMode.detectAIR) {
+				# We need faster updates to not lose track of oblique flying locks close by when in STT.
+				me.ContactNotification.vector = [me.getPriorityTarget()];
+				emesary.GlobalTransmitter.NotifyAll(me.ContactNotification);
+			}
+
+			while (me.dt > 0.001) {
+				# mode tells us how to move disc and to scan
+				me.dt = me.currentMode.step(me.dt);# mode already knows where in pattern we are and AZ and bars.
+
+				# we then step to the new position, and scan for each step
+				me.scanFOV();
+				me.showScan();
+			}
+
+		} elsif (size(me.vector_aicontacts_bleps)) {
+			# So that when radar is restarted there is not old bleps.
+			me.purgeAllBleps();
+		}
+	},
+	loopMedium: func {
+		#
+		# It send out what target we are Single-target-track locked onto if any so the target get RWR warning.
+		# It also sends out on datalink what we are STT/SAM/TWS locked onto.
+		# In addition it notifies the weapons what we have targeted.
+		# Plus it sets the MP property for radar standby so others can see us on RWR.
+		if (me.enabled) {
+			me.focus = me.getPriorityTarget();
+			if (me.focus != nil and me.focus.callsign != "") {
+				if (me.currentMode.painter) sttSend.setValue(left(md5(me.focus.callsign), 4));
+				else sttSend.setValue("");
+				if (steerpoints.sending == nil) {
+			        datalink.send_data({"contacts":[{"callsign":me.focus.callsign,"iff":0}]});
+			    }
+			} else {
+				sttSend.setValue("");
+				if (steerpoints.sending == nil) {
+		            datalink.clear_data();
+		        }
+			}
+			armament.contact = me.focus;
+			stbySend.setIntValue(0);
+		} else {
+			armament.contact = nil;
+			sttSend.setValue("");
+			stbySend.setIntValue(1);
+			if (steerpoints.sending == nil) {
+	            datalink.clear_data();
+	        }
+		}
+
+		me.debug = getprop("debug-radar/debug-main");
+	},
+	loopSlow: func {
+		#
+		# Here we ask the NoseRadar for a slice of the sky once in a while.
+		#
+		if (me.enabled and !(me.currentMode.painter and me.currentMode.detectAIR)) {
+			emesary.GlobalTransmitter.NotifyAll(me.SliceNotification.slice(self.getPitch(), self.getHeading(), math.max(-me.fieldOfRegardMinElev, me.fieldOfRegardMaxElev)*1.414, me.fieldOfRegardMaxAz*1.414, me.getRange()*NM2M, !me.currentMode.detectAIR, !me.currentMode.detectSURFACE, !me.currentMode.detectMARINE));
+		}
+	},
+	scanFOV: func {
+		#
+		# Here we test for IFF and test the radar beam against targets to see if the radar picks them up.
+		#
+		# Note that this can happen in aircraft coords (ACM modes) or in landscape coords (the other modes).
+		me.doIFF = getprop("instrumentation/radar/iff");
+    	setprop("instrumentation/radar/iff",0);
+    	if (me.doIFF) iff.last_interogate = systime();
+    	if (me["gmapper"] != nil) me.gmapper.scanGM(me.eulerX, me.eulerY, me.instantVertFoVradius, me.instantFoVradius,
+    		 me.currentMode.bars == 1 or (me.currentMode.bars == 4 and me.currentMode["nextPatternNode"] == 0) or (me.currentMode.bars == 3 and me.currentMode["nextPatternNode"] == 7) or (me.currentMode.bars == 2 and me.currentMode["nextPatternNode"] == 1),
+    		 me.currentMode.bars == 1 or (me.currentMode.bars == 4 and me.currentMode["nextPatternNode"] == 2) or (me.currentMode.bars == 3 and me.currentMode["nextPatternNode"] == 3) or (me.currentMode.bars == 2 and me.currentMode["nextPatternNode"] == 3));# The last two parameter is hack
+
+    	# test for passive ECM (chaff)
+		#
+		me.closestChaff = 1000000;# meters
+		if (size(me.chaffList)) {
+			if (me.horizonStabilized) {
+				me.globalAntennaeDir = vector.Math.yawVector(-self.getHeading(), me.positionDirection);
+			} else {
+				me.globalAntennaeDir = vector.Math.rollPitchYawVector(self.getRoll(), self.getPitch(), -self.getHeading(), me.positionDirection);
+			}
+
+			foreach (me.chaff ; me.chaffList) {
+				if (rand() < me.chaffFilter or me.chaff.meters < 10000+10000*rand()) continue;# some chaff are filtered out.
+				me.globalToTarget = vector.Math.pitchYawVector(me.chaff.pitch, -me.chaff.bearing, [1,0,0]);
+
+				# Degrees from center of radar beam to center of chaff cloud
+				me.beamDeviation = vector.Math.angleBetweenVectors(me.globalAntennaeDir, me.globalToTarget);
+
+				if (me.beamDeviation < me.instantFoVradius) {
+					if (me.chaff.meters < me.closestChaff) {
+						me.closestChaff = me.chaff.meters;
+					}
+					me.registerChaff(me.chaff);# for displays
+					#print("REGISTER CHAFF");
+				}# elsif(me.debug > -1) {
+					# This is too detailed for most debugging, remove later
+				#	setprop("debug-radar/main-beam-deviation-chaff", me.beamDeviation);
+				#}
+			}
+		}
+
+    	me.testedPrio = 0;
+		foreach(contact ; me.vector_aicontacts_for) {
+			if (me.doIFF == 1) {
+	            me.iffr = iff.interrogate(contact.prop);
+	            if (me.iffr) {
+	                contact.iff = me.elapsed;
+	            } else {
+	                contact.iff = -me.elapsed;
+	            }
+	        }
+			if (me.elapsed - contact.getLastBlepTime() < me.currentMode.minimumTimePerReturn) {
+				if(me.debug > 1 and me.currentMode.painter and contact == me.getPriorityTarget()) {
+					me.testedPrio = 1;
+				}
+				continue;# To prevent double detecting in overlapping beams
+			}
+
+			me.dev = contact.getDeviationStored();
+
+			if (me.horizonStabilized) {
+				# ignore roll and pitch
+
+				# Vector that points to target in radar coordinates as if aircraft it was not rolled or pitched.
+				me.globalToTarget = vector.Math.eulerToCartesian3X(-me.dev.bearing,me.dev.elevationGlobal,0);
+
+				# Vector that points to target in radar coordinates as if aircraft it was not yawed, rolled or pitched.
+				me.localToTarget = vector.Math.yawVector(self.getHeading(), me.globalToTarget);
+			} else {
+				# Vector that points to target in local radar coordinates.
+				me.localToTarget = vector.Math.eulerToCartesian3X(-me.dev.azimuthLocal,me.dev.elevationLocal,0);
+			}
+
+			# Degrees from center of radar beam to target, note that positionDirection must match the coord system defined by horizonStabilized.
+			me.beamDeviation = vector.Math.angleBetweenVectors(me.positionDirection, me.localToTarget);
+
+			if(me.debug > 1 and me.currentMode.painter and contact == me.getPriorityTarget()) {
+				# This is too detailed for most debugging, remove later
+				setprop("debug-radar/main-beam-deviation", me.beamDeviation);
+				me.testedPrio = 1;
+			}
+			if (me.beamDeviation < me.instantFoVradius and (me.dev.rangeDirect_m < me.closestChaff or rand() < me.chaffFilter) ) {#  and (me.closureReject == -1 or me.dev.closureSpeed > me.closureReject)
+				# TODO: Refine the chaff conditional (ALOT)
+				me.registerBlep(contact, me.dev, me.currentMode.painter, me.currentMode.pulse);
+				#print("REGISTER BLEP");
+
+				# Return here, so that each instant FoV max gets 1 target:
+				# TODO: refine by testing angle between contacts seen in this FoV
+				break;
+			}
+		}
+
+		if(me.debug > 1 and me.currentMode.painter and !me.testedPrio) {
+			setprop("debug-radar/main-beam-deviation", "--unseen-lock--");
+		}
+	},
+	registerBlep: func (contact, dev, stt, doppler = 1) {
+		if (!contact.isVisible()) return 0;
+		if (doppler) {
+			if (contact.isHiddenFromDoppler()) {
+				return 0;
+			}
+			if (math.abs(dev.closureSpeed) < me.currentMode.minClosure) {
+				return 0;
+			}
+		}
+
+		me.maxDistVisible = me.currentMode.rcsFactor * me.targetRCSSignal(self.getCoord(), dev.coord, contact.model, dev.heading, dev.pitch, dev.roll,me.rcsRefDistance*NM2M,me.rcsRefValue);
+
+		if (me.maxDistVisible > dev.rangeDirect_m) {
+			me.extInfo = me.currentMode.getSearchInfo(contact);# if the scan gives heading info etc..
+
+			if (me.extInfo == nil) {
+				return 0;
+			}
+			contact.blep(me.elapsed, me.extInfo, me.maxDistVisible, stt);
+			if (!me.containsVectorContact(me.vector_aicontacts_bleps, contact)) {
+				append(me.vector_aicontacts_bleps, contact);
+			}
+			return 1;
+		}
+		return 0;
+	},
+	registerChaff: func (chaff) {
+		chaff.seenTime = me.elapsed;
+		if (!me.containsVector(me.chaffSeenList, chaff)) {
+			append(me.chaffSeenList, chaff);
+		}
+	},
+	purgeBleps: func {
+		#ok, lets clean up old bleps:
+		me.vector_aicontacts_bleps_tmp = [];
+		me.elapsed = elapsedProp.getValue();
+		foreach(contact ; me.vector_aicontacts_bleps) {
+			me.bleps_cleaned = [];
+			foreach (me.blep;contact.getBleps()) {
+				if (me.elapsed - me.blep.getBlepTime() < me.currentMode.timeToFadeBleps) {
+					append(me.bleps_cleaned, me.blep);
+				}
+			}
+			contact.setBleps(me.bleps_cleaned);
+			if (size(me.bleps_cleaned)) {
+				append(me.vector_aicontacts_bleps_tmp, contact);
+				me.currentMode.testContact(contact);# TODO: do this smarter
+			} else {
+				me.currentMode.prunedContact(contact);
+			}
+		}
+		#print("Purged ", size(me.vector_aicontacts_bleps) - size(me.vector_aicontacts_bleps_tmp), " bleps   remains:",size(me.vector_aicontacts_bleps_tmp), " orig ",size(me.vector_aicontacts_bleps));
+		me.vector_aicontacts_bleps = me.vector_aicontacts_bleps_tmp;
+
+		#lets purge the old chaff also, both seen and unseen
+		me.wnd = wndprop.getValue();
+		me.chaffLifetime = math.max(0, me.wnd==0?25:25*(1-me.wnd/50));
+		me.chaffList_tmp = [];
+		foreach(me.evilchaff ; me.chaffList) {
+			if (me.elapsed - me.evilchaff.releaseTime < me.chaffLifetime) {
+				append(me.chaffList_tmp, me.evilchaff);
+			}
+		}
+		me.chaffList = me.chaffList_tmp;
+
+		me.chaffSeenList_tmp = [];
+		foreach(me.evilchaff ; me.chaffSeenList) {
+			if (me.elapsed - me.evilchaff.releaseTime < me.chaffLifetime or me.elapsed - me.evilchaff.seenTime < me.timeToKeepBleps) {
+				append(me.chaffSeenList_tmp, me.evilchaff);
+			}
+		}
+		me.chaffSeenList = me.chaffSeenList_tmp;
+	},
+	purgeAllBleps: func {
+		#ok, lets delete all bleps:
+		foreach(contact ; me.vector_aicontacts_bleps) {
+			contact.setBleps([]);
+			me.currentMode.prunedContact(contact);
+		}
+		me.vector_aicontacts_bleps = [];
+		me.chaffSeenList = [];
+	},
+	targetRCSSignal: func(aircraftCoord, targetCoord, targetModel, targetHeading, targetPitch, targetRoll, myRadarDistance_m = 74000, myRadarStrength_rcs = 3.2) {
+		#
+		# test method. Belongs in rcs.nas.
+		#
+	    me.target_front_rcs = nil;
+	    if ( contains(rcs.rcs_oprf_database,targetModel) ) {
+	        me.target_front_rcs = rcs.rcs_oprf_database[targetModel];
+	    } elsif ( contains(rcs.rcs_database,targetModel) ) {
+	        me.target_front_rcs = rcs.rcs_database[targetModel];
+	    } else {
+	        # GA/Commercial return most likely
+	        me.target_front_rcs = rcs.rcs_oprf_database["default"];
+	    }
+	    me.target_rcs = rcs.getRCS(targetCoord, targetHeading, targetPitch, targetRoll, aircraftCoord, me.target_front_rcs);
+
+	    # standard formula
+	    return myRadarDistance_m/math.pow(myRadarStrength_rcs/me.target_rcs, 1/4);
+	},
+	getActiveBleps: func {
+		return me.vector_aicontacts_bleps;
+	},
+	getActiveChaff: func {
+		return me.chaffSeenList;
+	},
+	showScan: func {
+		if (me.debug > 0) {
+			if (me["canvas2"] == nil) {
+	            me.canvas2 = canvas.Window.new([512,512],"dialog").set('title',"Scan").getCanvas(1);
+				me.canvas_root2 = me.canvas2.createGroup().setTranslation(256,256);
+				me.canvas2.setColorBackground(0.25,0.25,1);
+			}
+
+			if (me.elapsed - me.currentMode.lastFrameStart < 0.1) {
+				me.clearShowScan();
+			}
+			me.canvas_root2.createChild("path")
+				.setTranslation(256*me.eulerX/60, -256*me.eulerY/60)
+				.moveTo(0, 256*me.instantFoVradius/60)
+				.lineTo(0, -256*me.instantFoVradius/60)
+				.setColor(1,1,1);
+		}
+	},
+	clearShowScan: func {
+		if (me["canvas2"] == nil or me.debug < 1) return;
+		me.canvas_root2.removeAllChildren();
+		if (me.horizonStabilized) {
+			me.canvas_root2.createChild("path")
+				.moveTo(-250, 0)
+				.lineTo(250, 0)
+				.setColor(1,1,0)
+				.setStrokeLineWidth(4);
+		} else {
+			me.canvas_root2.createChild("path")
+				.moveTo(256*-5/60, 256*-1.5/60)
+				.lineTo(256*5/60, 256*-1.5/60)
+				.lineTo(256*5/60,  256*15/60)
+				.lineTo(256*-5/60,  256*15/60)
+				.lineTo(256*-5/60, 256*-1.5/60)
+				.setColor(1,1,0)
+				.setStrokeLineWidth(4);
+		}
+	},
+	containsVector: func (vec, item) {
+		foreach(test; vec) {
+			if (test == item) {
+				return 1;
+			}
+		}
+		return 0;
+	},
+
+	containsVectorContact: func (vec, item) {
+		foreach(test; vec) {
+			if (test.equals(item)) {
+				return 1;
+			}
+		}
+		return 0;
+	},
+
+	vectorIndex: func (vec, item) {
+		me.i = 0;
+		foreach(test; vec) {
+			if (test == item) {
+				return me.i;
+			}
+			me.i += 1;
+		}
+		return -1;
+	},
+	del: func {
+        emesary.GlobalTransmitter.DeRegister(me.ActiveDiscRadarRecipient);
+    },
+};
+
+
+
+
+
+
+
+
+
+
+var SPOT_SCAN = -1; # must be -1
+
+
+
+
+
+#  ██████   █████  ██████   █████  ██████      ███    ███  ██████  ██████  ███████
+#  ██   ██ ██   ██ ██   ██ ██   ██ ██   ██     ████  ████ ██    ██ ██   ██ ██
+#  ██████  ███████ ██   ██ ███████ ██████      ██ ████ ██ ██    ██ ██   ██ █████
+#  ██   ██ ██   ██ ██   ██ ██   ██ ██   ██     ██  ██  ██ ██    ██ ██   ██ ██
+#  ██   ██ ██   ██ ██████  ██   ██ ██   ██     ██      ██  ██████  ██████  ███████
+#
+#
+var RadarMode = {
+	#
+	# Subclass and modify as needed.
+	#
+	radar: nil,
+	range: 40,
+	minRange: 5,
+	maxRange: 160,
+	az: 60,
+	bars: 1,
+	azimuthTilt: 0,# modes set these depending on where they want the pattern to be centered.
+	elevationTilt: 0,
+	barHeight: 0.80,# multiple of instantFoVradius
+	barPattern:  [ [[-1,0],[1,0]] ],     # The second is multitude of instantFoVradius, the first is multitudes of me.az
+	barPatternMin: [0],
+	barPatternMax: [0],
+	nextPatternNode: 0,
+	scanPriorityEveryFrame: 0,# Related to SPOT_SCAN.
+	timeToFadeBleps: 13,
+	rootName: "Base",
+	shortName: "",
+	longName: "",
+	superMode: nil,
+	minimumTimePerReturn: 0.5,
+	rcsFactor: 0.9,
+	lastFrameStart: -1,
+	lastFrameDuration: 5,
+	detectAIR: 1,
+	detectSURFACE: 0,
+	detectMARINE: 0,
+	pulse: DOPPLER, # MONO or DOPPLER
+	minClosure: 0, # kt
+	cursorAz: 0,
+	cursorNm: 20,
+	upperAngle: 10,
+	lowerAngle: 10,
+	painter: 0, # if the mode when having a priority target will produce a hard lock on target.
+	mapper: 0,
+	discSpeed_dps: 1,# current disc speed. Must never be zero.
+	setRange: func (range) {
+		me.testMulti = me.maxRange/range;
+		if (int(me.testMulti) != me.testMulti) {
+			# max range is not dividable by range, so we don't change range
+			return 0;
+		}
+		me.range = math.min(me.maxRange, range);
+		me.range = math.max(me.minRange, me.range);
+		return range == me.range;
+	},
+	getRange: func {
+		return me.range;
+	},
+	_increaseRange: func {
+		me.range*=2;
+		if (me.range>me.maxRange) {
+			me.range*=0.5;
+			return 0;
+		}
+		return 1;
+	},
+	_decreaseRange: func {
+		me.range *= 0.5;
+		if (me.range < me.minRange) {
+			me.range *= 2;
+			return 0;
+		}
+		return 1;
+	},
+	getDeviation: func {
+		# how much the pattern is deviated from straight ahead in azimuth
+		return me.azimuthTilt;
+	},
+	getBars: func {
+		return me.bars;
+	},
+	getAz: func {
+		return me.az;
+	},
+	constrainAz: func () {
+		# Convinience method that the modes can use.
+		if (me.az == me.radar.fieldOfRegardMaxAz) {
+			me.azimuthTilt = 0;
+		} elsif (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+		}
+	},
+	getPriority: func {
+		return me["priorityTarget"];
+	},
+	computePattern: func {
+		# Translate the normalized pattern nodes into degrees. Since me.az or maybe me.bars have tendency to change rapidly
+		# We do this every step. Its fast anyway.
+		me.currentPattern = [];
+		foreach (me.eulerNorm ; me.barPattern[me.bars-1]) {
+			me.patternNode = [me.eulerNorm[0]*me.az, me.eulerNorm[1]*me.radar.instantFoVradius*me.barHeight];
+			append(me.currentPattern, me.patternNode);
+		}
+		return me.currentPattern;
+	},
+	step: func (dt) {
+		me.radar.horizonStabilized = 1;# Might be unset inside preStep()
+
+		# Individual modes override this method and get ready for the step.
+		# Inside this they typically set 'azimuthTilt' and 'elevationTilt' for moving the pattern around.
+		me.preStep();
+
+		# Lets figure out the desired antennae tilts
+	 	me.azimuthTiltIntern = me.azimuthTilt;
+	 	me.elevationTiltIntern = me.elevationTilt;
+		if (me.nextPatternNode == SPOT_SCAN and me.priorityTarget != nil) {
+			# We never do spot scans in ACM modes so no check for horizonStabilized here.
+			me.lastBlep = me.priorityTarget.getLastBlep();
+			if (me.lastBlep != nil) {
+				me.azimuthTiltIntern = me.lastBlep.getAZDeviation();
+				me.elevationTiltIntern = me.lastBlep.getElev();
+			} else {
+				me.priorityTarget = nil;
+				me.undesignate();
+				me.nextPatternNode == 0;
+			}
+		} elsif (me.nextPatternNode == SPOT_SCAN) {
+			# We cannot do spot scan on stuff we cannot see, reverting back to pattern
+			me.nextPatternNode = 0;
+		}
+
+		# now lets check where we want to move the disc to
+		me.currentPattern      = me.computePattern();
+		me.targetAzimuthTilt   = me.azimuthTiltIntern+(me.nextPatternNode!=SPOT_SCAN?me.currentPattern[me.nextPatternNode][0]:0);
+		me.targetElevationTilt = me.elevationTiltIntern+(me.nextPatternNode!=SPOT_SCAN?me.currentPattern[me.nextPatternNode][1]:0);
+
+		# The pattern min/max pitch when not tilted.
+		me.min = me.barPatternMin[me.bars-1]*me.barHeight*me.radar.instantFoVradius;
+		me.max = me.barPatternMax[me.bars-1]*me.barHeight*me.radar.instantFoVradius;
+
+		# We check if radar gimbal mount can turn enough.
+		me.gimbalInBounds = 1;
+		if (me.radar.horizonStabilized) {
+			# figure out if we reach the gimbal limit
+	 		me.actualMin = self.getPitch()+me.radar.fieldOfRegardMinElev;
+	 		me.actualMax = self.getPitch()+me.radar.fieldOfRegardMaxElev;
+	 		if (me.targetElevationTilt < me.actualMin) {
+	 			me.gimbalInBounds = 0;
+	 		} elsif (me.targetElevationTilt > me.actualMax) {
+	 			me.gimbalInBounds = 0;
+	 		}
+ 		}
+ 		if (!me.gimbalInBounds) {
+ 			# Don't move the antennae if it cannot reach whats requested.
+ 			# This basically stop the radar from working while still not on standby
+ 			# until better attitude is reached.
+ 			#
+ 			# It used to attempt to scan in edge of FoR but thats not really helpful to a pilot.
+ 			# If need to scan while extreme attitudes then the are specific modes for that (in some aircraft).
+ 			me.radar.setAntennae(me.radar.positionDirection);
+ 			#print("db-Out of gimbal bounds");
+	 		return 0;
+	 	}
+
+	 	# For help with cursor limits we need to compute these
+		if (me.radar.horizonStabilized and me.gimbalInBounds) {
+			me.lowerAngle = me.min+me.elevationTiltIntern;
+			me.upperAngle = me.max+me.elevationTiltIntern;
+		} else {
+			me.lowerAngle = 0;
+			me.upperAngle = 0;
+		}
+
+	 	# Lets get a status for where we are in relation to where we are going
+		me.targetDir = vector.Math.pitchYawVector(me.targetElevationTilt, -me.targetAzimuthTilt, [1,0,0]);# A vector for where we want the disc to go
+		me.angleToNextNode = vector.Math.angleBetweenVectors(me.radar.positionDirection, me.targetDir);# Lets test how far from the target tilts we are.
+
+		# Move the disc
+		if (me.angleToNextNode < me.radar.instantFoVradius) {
+			# We have reached our target
+			me.radar.setAntennae(me.targetDir);
+			me.nextPatternNode += 1;
+			if (me.nextPatternNode >= size(me.currentPattern)) {
+				me.nextPatternNode = (me.scanPriorityEveryFrame and me.priorityTarget!=nil)?SPOT_SCAN:0;
+				me.frameCompleted();
+			}
+			#print("db-node:", me.nextPatternNode);
+			# Now the antennae has been moved and we return how much leftover dt there is to the main radar.
+			return dt-me.angleToNextNode/me.discSpeed_dps;# Since we move disc seperately in axes, this is not strictly correct, but close enough.
+		}
+
+		# Lets move each axis of the radar seperate, as most radars likely has 2 joints anyway.
+		me.maxMove = math.min(me.radar.instantFoVradius*overlapHorizontal, me.discSpeed_dps*dt);# 1.75 instead of 2 is because the FoV is round so we overlap em a bit
+
+		# Azimuth
+		me.distance_deg = me.targetAzimuthTilt - me.radar.eulerX;
+		if (me.distance_deg >= 0) {
+			me.moveX =  math.min(me.maxMove, me.distance_deg);
+		} else {
+			me.moveX = math.max(-me.maxMove, me.distance_deg);
+		}
+		me.newX = me.radar.eulerX + me.moveX;
+
+		# Elevation
+		me.distance_deg = me.targetElevationTilt - me.radar.eulerY;
+		if (me.distance_deg >= 0) {
+			me.moveY =  math.min(me.maxMove, me.distance_deg);
+		} else {
+			me.moveY =  math.max(-me.maxMove, me.distance_deg);
+		}
+		me.newY = me.radar.eulerY + me.moveY;
+
+		# Convert the angles to a vector and set the new antennae position
+		me.newPos = vector.Math.pitchYawVector(me.newY, -me.newX, [1,0,0]);
+		me.radar.setAntennae(me.newPos);
+
+		# As the two joins move at the same time, we find out which moved the most
+		me.movedMax = math.max(math.abs(me.moveX), math.abs(me.moveY));
+		if (me.movedMax == 0) {
+			# This should really not happen, we return 0 to make sure the while loop don't get infinite.
+			print("me.movedMax == 0");
+			return 0;
+		}
+		if (me.movedMax > me.discSpeed_dps) {
+			print("me.movedMax > me.discSpeed_dps");
+			return 0;
+		}
+		return dt-me.movedMax/me.discSpeed_dps;
+	},
+	frameCompleted: func {
+		if (me.lastFrameStart != -1) {
+			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+		}
+		me.lastFrameStart = me.radar.elapsed;
+	},
+	setCursorDeviation: func (cursor_az) {
+		me.cursorAz = cursor_az;
+	},
+	getCursorDeviation: func {
+		return me.cursorAz;
+	},
+	setCursorDistance: func (nm) {
+		# Return if the cursor should be distance zeroed.
+		return 0;
+	},
+	getCursorAltitudeLimits: func {
+		# Used in F-16 with two numbers next to cursor that indicates min/max for radar pattern in altitude above sealevel.
+		# It needs: me.lowerAngle, me.upperAngle and me.cursorNm
+		me.vectorToDist = [math.cos(me.upperAngle*D2R), 0, math.sin(me.upperAngle*D2R)];
+		me.selfC = self.getCoord();
+		me.geo = vector.Math.vectorToGeoVector(me.vectorToDist, me.selfC);
+		me.geo = vector.Math.product(me.cursorNm*NM2M, vector.Math.normalize(me.geo.vector));
+		me.up = geo.Coord.new();
+		me.up.set_xyz(me.selfC.x()+me.geo[0],me.selfC.y()+me.geo[1],me.selfC.z()+me.geo[2]);
+		me.vectorToDist = [math.cos(me.lowerAngle*D2R), 0, math.sin(me.lowerAngle*D2R)];
+		me.geo = vector.Math.vectorToGeoVector(me.vectorToDist, me.selfC);
+		me.geo = vector.Math.product(me.cursorNm*NM2M, vector.Math.normalize(me.geo.vector));
+		me.down = geo.Coord.new();
+		me.down.set_xyz(me.selfC.x()+me.geo[0],me.selfC.y()+me.geo[1],me.selfC.z()+me.geo[2]);
+		return [me.up.alt()*M2FT, me.down.alt()*M2FT];
+	},
+	leaveMode: func {
+		# Warning: In this method do not set anything on me.radar only on me.
+		me.lastFrameStart = -1;
+	},
+	enterMode: func {
+	},
+	designatePriority: func (contact) {},
+	cycleDesignate: func {},
+	testContact: func (contact) {},
+	prunedContact: func (c) {
+		if (c.equalsFast(me["priorityTarget"])) {
+			me.priorityTarget = nil;
+		}
+	},
+};#                                    END Radar Mode class
+
+
+
+
+
+
+#  ██████   █████  ████████  █████  ██      ██ ███    ██ ██   ██ 
+#  ██   ██ ██   ██    ██    ██   ██ ██      ██ ████   ██ ██  ██  
+#  ██   ██ ███████    ██    ███████ ██      ██ ██ ██  ██ █████  
+#  ██   ██ ██   ██    ██    ██   ██ ██      ██ ██  ██ ██ ██  ██ 
+#  ██████  ██   ██    ██    ██   ██ ███████ ██ ██   ████ ██   ██ 
+#                                                                
+#
+DatalinkRadar = {
+	# I check the sky 360 deg for anything on datalink
+	#
+	# I will set 'blue' and 'blueIndex' on contacts.
+	# blue==1: On our datalink
+	# blue==2: Targeted by someone on our datalink
+	#
+	# Direct line of sight required for ~1000MHz signal.
+	#
+	# This class is only semi generic!
+	new: func (rate, max_dist_fighter_nm, max_dist_station_nm) {
+		var dlnk = {parents: [DatalinkRadar, Radar]};
+
+		dlnk.max_dist_fighter_nm = max_dist_fighter_nm;
+		dlnk.max_dist_station_nm = max_dist_station_nm;
+
+		datalink.can_transmit = func(callsign, mp_prop, mp_index) {
+		    dlnk.contactSender = callsignToContact.get(callsign);
+		    if (dlnk.contactSender == nil) return 0;
+		    if (!dlnk.contactSender.isValid()) return 0;
+		    if (!dlnk.contactSender.isVisible()) return 0;
+
+		    dlnk.isContactStation = isKnownSurface(dlnk.contactSender.getModel()) or isKnownShip(dlnk.contactSender.getModel()) or isKnownAwacs(dlnk.contactSender.getModel());
+		    dlnk.max_dist_nm = dlnk.isContactStation?dlnk.max_dist_station_nm:dlnk.max_dist_fighter_nm;
+
+		    return dlnk.contactSender.get_range() < dlnk.max_dist_nm;
+		}
+
+
+		dlnk.index = 0;
+		dlnk.vector_aicontacts = [];
+		dlnk.vector_aicontacts_for = [];
+		dlnk.timer          = maketimer(rate, dlnk, func dlnk.scan());
+
+		dlnk.DatalinkRadarRecipient = emesary.Recipient.new("DatalinkRadarRecipient");
+		dlnk.DatalinkRadarRecipient.radar = dlnk;
+		dlnk.DatalinkRadarRecipient.Receive = func(notification) {
+	        if (notification.NotificationType == "AINotification") {
+	        	#printf("DLNKRadar recv: %s", notification.NotificationType);
+	        	#printf("DLNKRadar notified of %d contacts", size(notification.vector));
+    		    me.radar.vector_aicontacts = notification.vector;
+    		    me.radar.index = 0;
+	            return emesary.Transmitter.ReceiptStatus_OK;
+	        }
+	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+	    };
+		emesary.GlobalTransmitter.Register(dlnk.DatalinkRadarRecipient);
+		dlnk.DatalinkNotification = VectorNotification.new("DatalinkNotification");
+		dlnk.DatalinkNotification.updateV(dlnk.vector_aicontacts_for);
+		dlnk.timer.start();
+		return dlnk;
+	},
+
+	scan: func () {
+		if (!me.enabled) return;
+
+		#this loop is really fast. But we only check 1 contact per call
+		if (me.index >= size(me.vector_aicontacts)) {
+			# will happen if there is no contacts or if contact(s) went away
+			me.index = 0;
+			return;
+		}
+		me.contact = me.vector_aicontacts[me.index];
+		me.wasBlue = me.contact["blue"];
+		me.cs = me.contact.get_Callsign();
+		if (me.wasBlue == nil) me.wasBlue = 0;
+
+		if (!me.contact.isValid()) {
+			me.contact.blue = 0;
+			if (me.wasBlue > 0) {
+				#print(me.cs," is invalid and purged from Datalink");
+				me.new_vector_aicontacts_for = [];
+				foreach (me.c ; me.vector_aicontacts_for) {
+					if (!me.c.equals(me.contact) and !me.c.equalsFast(me.contact)) {
+						append(me.new_vector_aicontacts_for, me.c);
+					}
+				}
+				me.vector_aicontacts_for = me.new_vector_aicontacts_for;
+			}
+		} else {
+
+
+	        if (!me.contact.isValid()) {
+	        	me.lnk = nil;
+	        } else {
+	        	me.lnk = datalink.get_data(damage.processCallsign(me.cs));
+	        }
+
+	        if (me.lnk != nil and me.lnk.on_link() == 1) {
+	            me.blue = 1;
+	            me.blueIndex = me.lnk.index()+1;
+	        } elsif (me.cs == getprop("link16/wingman-4")) { # Hack that the F16 need. Just ignore it, as nil wont cause expection.
+	            me.blue = 1;
+	            me.blueIndex = 0;
+	        } else {
+	        	me.blue = 0;
+	            me.blueIndex = -1;
+	        }
+	        if (!me.blue and me.lnk != nil and me.lnk.tracked() == 1) {
+	        	me.dl_idx = me.lnk.tracked_by_index();
+	        	if (me.dl_idx != nil and me.dl_idx > -1) {
+		            me.blue = 2;
+		            me.blueIndex = me.dl_idx+1;
+			    }
+	        }
+
+	        me.contact.blue = me.blue;
+	        if (me.blue > 0) {
+	        	me.contact.blueIndex = me.blueIndex;
+				if (!AirborneRadar.containsVectorContact(me.vector_aicontacts_for, me.contact)) {
+					append(me.vector_aicontacts_for, me.contact);
+					emesary.GlobalTransmitter.NotifyAll(me.DatalinkNotification.updateV(me.vector_aicontacts_for));
+				}
+			} elsif (me.wasBlue > 0) {
+				me.new_vector_aicontacts_for = [];
+				foreach (me.c ; me.vector_aicontacts_for) {
+					if (!me.c.equals(me.contact) and !me.c.equalsFast(me.contact)) {
+						append(me.new_vector_aicontacts_for, me.c);
+					}
+				}
+				me.vector_aicontacts_for = me.new_vector_aicontacts_for;
+			}
+		}
+		me.index += 1;
+        if (me.index > size(me.vector_aicontacts)-1) {
+        	me.index = 0;
+
+        	# Lets not keep contacts no longer in our scene
+        	me.new_vector_aicontacts_for = [];
+			foreach (me.c ; me.vector_aicontacts_for) {
+				if (AirborneRadar.containsVectorContact(me.vector_aicontacts, me.c)) {
+					append(me.new_vector_aicontacts_for, me.c);
+				}
+			}
+			me.vector_aicontacts_for = me.new_vector_aicontacts_for;
+
+        	emesary.GlobalTransmitter.NotifyAll(me.DatalinkNotification.updateV(me.vector_aicontacts_for));
+        }
+	},
+	del: func {
+        emesary.GlobalTransmitter.DeRegister(me.DatalinkRadarRecipient);
+    },
+};
+
+
+
+
+
+
+
+
+
+
+########################### BEGIN NON-GENERIC CLASSES ##########################
+
+
+
+
+
+
+
+#   █████  ██████   ██████         ██████   █████ 
+#  ██   ██ ██   ██ ██             ██       ██   ██ 
+#  ███████ ██████  ██   ███ █████ ███████   █████  
+#  ██   ██ ██      ██    ██       ██    ██ ██   ██ 
+#  ██   ██ ██       ██████         ██████   █████  
+#                                                 
+#
+var APG68 = {
+	#
+	# Root modes is  0: CRM  1: ACM 2: SEA 3: GM 4: GMT
+	#
+	instantFoVradius: 3.90*0.5,#average of horiz/vert radius
+	instantVertFoVradius: 4.55*0.5,# real vert radius (used by ground mapper)
+	instantHoriFoVradius: 3.25*0.5,# real hori radius (not used)
+	rcsRefDistance: 70,
+	rcsRefValue: 3.2,
+	targetHistory: 3,# Not used in TWS
+	isEnabled: func {
+		return getprop("/f16/avionics/power-fcr-bit") == 2 and getprop("instrumentation/radar/radar-enable") and !getprop("/fdm/jsbsim/gear/unit[0]/WOW") and getprop("instrumentation/radar/serviceable");
+	},
+	setAGMode: func {
+		if (me.rootMode != 3) {
+			me.rootMode = 3;
+			me.oldMode = me.currentMode;
+
+			me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+			me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+		}
+	},
+	setAAMode: func {
+		if (me.rootMode != 0) {
+			me.rootMode = 0;
+			me.oldMode = me.currentMode;
+
+			me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+			me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+		}
+	},
+	showAZ: func {
+		me.currentMode.showAZ();
+	},
+	showAZinHSD: func {
+		me.currentMode.showAZinHSD();
+	},
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#  ███████        ██  ██████      ███    ███  █████  ██ ███    ██     ███    ███  ██████  ██████  ███████
+#  ██            ███ ██           ████  ████ ██   ██ ██ ████   ██     ████  ████ ██    ██ ██   ██ ██
+#  █████   █████  ██ ███████      ██ ████ ██ ███████ ██ ██ ██  ██     ██ ████ ██ ██    ██ ██   ██ █████
+#  ██             ██ ██    ██     ██  ██  ██ ██   ██ ██ ██  ██ ██     ██  ██  ██ ██    ██ ██   ██ ██
+#  ██             ██  ██████      ██      ██ ██   ██ ██ ██   ████     ██      ██  ██████  ██████  ███████
+#
+#
+var APG68Mode = {
+	minRange: 5, # MLU T1 .. should we make this 10 for block 10/30/YF? TODO
+	maxRange: 160,
+	bars: 4,
+	barPattern:  [ [[-1,0],[1,0]],                    # These are multitudes of [me.az, instantFoVradius]
+	               [[-1,-1],[1,-1],[1,1],[-1,1]],
+	               [[-1,0],[1,0],[1,2],[-1,2],[-1,0],[1,0],[1,-2],[-1,-2]],
+	               [[1,-3],[1,3],[-1,3],[-1,1],[1,1],[1,-1],[-1,-1],[-1,-3]] ],
+	barPatternMin: [0,-1, -2, -3],
+	barPatternMax: [0, 1,  2,  3],
+	rootName: "CRM",
+	shortName: "",
+	longName: "",
+	EXPsupport: 0,#if support zoom
+	EXPsearch: 1,# if zoom should include search targets
+	EXPfixedAim: 0,# If map underneath should move instead of cursor when slewing
+	showAZ: func {
+		return me.az != me.radar.fieldOfRegardMaxAz; # If this return false, then they are also not shown in PPI.
+	},
+	showAZinHSD: func {
+		return 1;
+	},
+	showBars: func {
+		return 1;
+	},
+	showRangeOptions: func {
+		return 1;
+	},
+	setCursorDistance: func (nm) {
+		# Return if the cursor should be distance zeroed.
+		me.cursorNm = nm;
+		if (nm < me.radar.getRange()*0.05) {
+			return me.decreaseRange();
+		} elsif (nm > me.radar.getRange()*0.95) {
+			return me.increaseRange();
+		}
+		return 0;
+	},
+	frameCompleted: func {
+		if (me.lastFrameStart != -1) {
+			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
+		}
+		me.lastFrameStart = me.radar.elapsed;
+	},
+};#                                    END APG-68 Mode base class
+
+
+
+
+
+
+
+
+#  ██████  ██     ██ ███████ 
+#  ██   ██ ██     ██ ██      
+#  ██████  ██  █  ██ ███████ 
+#  ██   ██ ██ ███ ██      ██ 
+#  ██   ██  ███ ███  ███████ 
+#                            
+#
+var F16RWSMode = {
+	radar: nil,
+	shortName: "RWS",
+	longName: "Range While Search",
+	superMode: nil,
+	subMode: nil,
+	maxRange: 160,
+	discSpeed_dps: 65,#authentic for RWS
+	rcsFactor: 0.9,
+	EXPsupport: 1,#if support zoom
+	EXPsearch: 1,# if zoom should include search targets
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16RWSMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		subMode.superMode = mode;
+		subMode.shortName = mode.shortName;
+		return mode;
+	},
+	cycleAZ: func {
+		if (me.az == 10) me.az = 30;
+		elsif (me.az == 30) me.az = 60;
+		elsif (me.az == 60) me.az = 10;
+	},
+	cycleBars: func {
+		me.bars += 1;
+		if (me.bars == 3) me.bars = 4;# 3 is only for TWS
+		elsif (me.bars == 5) me.bars = 1;
+		me.nextPatternNode = 0;
+	},
+	designate: func (designate_contact) {
+		if (designate_contact == nil) return;
+		me.radar.setCurrentMode(me.subMode, designate_contact);
+		me.subMode.radar = me.radar;# find some smarter way of setting it.
+	},
+	undesignate: func {},
+	designatePriority: func (contact) {
+		me.designate(contact);
+	},
+	preStep: func {
+		var dev_tilt_deg = me.cursorAz;
+		me.elevationTilt = me.radar.getTiltKnob();
+		if (me.az == 60) {
+			dev_tilt_deg = 0;
+		}
+		me.azimuthTilt = dev_tilt_deg;
+		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+		}
+	},
+	increaseRange: func {
+		me._increaseRange();
+	},
+	decreaseRange: func {
+		me._decreaseRange();
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		return [1,0,1,0,0,1];
+	},
+};
+
+
+#  ██      ██████  ███████ 
+#  ██      ██   ██ ██      
+#  ██      ██████  ███████ 
+#  ██      ██   ██      ██ 
+#  ███████ ██   ██ ███████ 
+#                          
+#
+var F16LRSMode = {
+	shortName: "LRS",
+	longName: "Long Range Search",
+	range: 160,
+	discSpeed_dps: 45,
+	rcsFactor: 1,
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16LRSMode, F16RWSMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		subMode.superMode = mode;
+		subMode.shortName = mode.shortName;
+		return mode;
+	},
+};
+
+
+#  ███████ ███████  █████ 
+#  ██      ██      ██   ██ 
+#  ███████ █████   ███████ 
+#       ██ ██      ██   ██ 
+#  ███████ ███████ ██   ██ 
+#                          
+#
+var F16SeaMode = {
+	rootName: "SEA",
+	shortName: "AUTO",
+	longName: "Sea Navigation Mode",
+	discSpeed_dps: 55,# was 55
+	maxRange: 80,
+	range: 20,
+	bars: 1,
+	rcsFactor: 1,
+	detectAIR: 0,
+	detectSURFACE: 0,
+	detectMARINE: 1,
+	pulse: MONO, # MONO or DOPPLER
+	#barPattern:  [ [[-1,-3],[1,-3]], # The SURFACE/SEA pattern is centered so pattern is almost entirely under horizon
+	#               [[-1,-5],[1,-5],[1,-3],[-1,-3]],
+	#               [[-1,-5],[1,-5],[1,-3],[-1,-3],[-1,-5],[1,-5],[1,-7],[-1,-7]],
+	#               [[1,-7],[1,-1],[-1,-1],[-1,-3],[1,-3],[1,-5],[-1,-5],[-1,-7]] ],
+	#barPatternMin: [-3, -5, -7, -7], # about down to -15 degs coverage from horizon with 4 bars
+	#barPatternMax: [-3, -3, -3, -1],
+	EXPsupport: 1,
+	EXPfixedAim: 1,
+	exp: 0,
+	expAz: 0,
+	expDistNm: 10,
+	autoCursor: 1,
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16SeaMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		subMode.superMode = mode;
+		subMode.shortName = mode.shortName;
+		subMode.rootName = mode.rootName;
+		return mode;
+	},
+	toggleAuto: func {
+		me.autoCursor = !me.autoCursor;
+		me.shortName = me.autoCursor?"AUTO":"MAN";
+	},
+	setCursorDistance: func (nm) {
+		# Return if the cursor should be distance zeroed.
+		me.cursorNm = nm;
+		if (me.autoCursor and nm < me.radar.getRange()*0.425) {
+			return me.decreaseRange();
+		} elsif (me.autoCursor and nm > me.radar.getRange()*0.95) {
+			return me.increaseRange();
+		}
+		return 0;
+	},
+	preStep: func {
+		var dev_tilt_deg = me.cursorAz;
+		if (me.az == 60) {
+			dev_tilt_deg = 0;
+		}
+		me.azimuthTilt = dev_tilt_deg;
+		me.elevationTilt = me.radar.getTiltKnob();
+		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+		}
+		if (me.radar.getTiltKnob() == 0 and steerpoints.getCurrentNumber() != 0) {
+			me.groundPitch = steerpoints.getCurrentGroundPitch();
+			if (me.groundPitch != nil and me.groundPitch > -55 and me.groundPitch < 55) {
+				me.elevationTilt = me.groundPitch;
+			}
+		}
+	},
+	cycleAZ: func {
+		if (me.az == 10) me.az = 30;
+		elsif (me.az == 30) me.az = 60;
+		elsif (me.az == 60) me.az = 10;
+	},
+	cycleBars: func {
+	},
+	showBars: func {
+		return 0;
+	},
+	getEXPsize: func {
+		# return nm of zoom width
+		if (me.getRange() == 10) {
+			return 3.5;
+		} elsif (me.getRange() == 20) {
+			return 7;
+		} elsif (me.getRange() == 40) {
+			return 14;
+		} elsif (me.getRange() == 80) {
+			return 21;
+		}
+	},
+	showAZ: func {
+		return 1;
+	},
+	increaseRange: func {
+		me._increaseRange();
+	},
+	decreaseRange: func {
+		me._decreaseRange();
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		return [1,0,1,0,0,1];
+	},
+	designate: func (designate_contact) {
+		if (designate_contact == nil) return;
+		me.radar.setCurrentMode(me.subMode, designate_contact);
+		me.subMode.radar = me.radar;# find some smarter way of setting it.
+	},
+	undesignate: func {},
+	designatePriority: func (contact) {
+	},
+	enterMode: func {
+		me.radar.purgeAllBleps();
+	},
+};
+
+
+#   ██████  ███    ███ 
+#  ██       ████  ████ 
+#  ██   ███ ██ ████ ██ 
+#  ██    ██ ██  ██  ██ 
+#   ██████  ██      ██ 
+#                      
+#
+var F16GMMode = {
+	rootName: "GM",
+	longName: "Ground Map",
+	discSpeed_dps: 55,
+	detectAIR: 0,
+	detectSURFACE: 1,
+	detectMARINE: 0,
+	mapper: 1,
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16GMMode, F16SeaMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		subMode.superMode = mode;
+		subMode.shortName = mode.shortName;
+		subMode.rootName = mode.rootName;
+		return mode;
+	},
+	frameCompleted: func {
+		#print("frame ",me.radar.elapsed-me.lastFrameStart);
+		if (me.lastFrameStart != -1) {
+			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
+		}
+		me.lastFrameStart = me.radar.elapsed;
+		if (me.radar["gmapper"] != nil) {
+			me.radar.gmapper.frameDone();
+		}
+	},
+	setExp: func (exp) {
+		me.exp = exp;
+		if (me.radar["gmapper"] != nil) me.radar.gmapper.expChanged(exp);
+	},
+	isEXP: func {
+		return me.exp;
+	},
+	setExpPosition: func (azimuth, distance_nm) {
+		me.expAz = azimuth;
+		me.expDistNm = distance_nm;
+	},
+	getEXPBoundary: func {
+		if (me.exp and 0) {
+			me.expWidthNm = me.getEXPsize();
+			me.expCart = [me.expDistNm*math.sin(me.expAz*D2R), me.expDistNm*math.cos(me.expAz*D2R)];
+			me.expCornerCartBegin = [me.expCart[0]-me.expWidthNm*0.5, me.expCart[1]-me.expWidthNm*0.5];
+			me.expCornerCartEnd   = [me.expCart[0]+me.expWidthNm*0.5, me.expCart[1]-me.expWidthNm*0.5];
+			me.expCornerDist1 = math.sqrt(me.expCornerCartBegin[0]*me.expCornerCartBegin[0]+me.expCornerCartBegin[1]*me.expCornerCartBegin[1]);
+			me.expCornerDist2 = math.sqrt(me.expCornerCartEnd[0]*me.expCornerCartEnd[0]+me.expCornerCartEnd[1]*me.expCornerCartEnd[1]);
+			me.azStart = math.asin(math.clamp(me.expCornerCartBegin[0]/me.expCornerDist1,0,1))*R2D;
+			me.azEnd = math.asin(math.clamp(me.expCornerCartEnd[0]/me.expCornerDist2,0,1))*R2D;
+			if (me.expCornerDist1 > me.expCornerDist2) {
+				me.expCornerCartBegin[1] += me.expWidthNm;
+				me.cornerRangeNm = math.sqrt(me.expCornerCartBegin[0]*me.expCornerCartBegin[0]+me.expCornerCartBegin[1]*me.expCornerCartBegin[1]);
+				me.expMinRange = me.expCornerCartEnd[1];
+			} else {
+				me.expCornerCartEnd[1] += me.expWidthNm;
+				me.cornerRangeNm = math.sqrt(me.expCornerCartEnd[0]*me.expCornerCartEnd[0]+me.expCornerCartEnd[1]*me.expCornerCartEnd[1]);
+				me.expMinRange = me.expCornerCartBegin[1];
+			}
+			# deg start/end and min and max range in nm:
+			return [me.azStart, me.azEnd, me.expMinRange, me.cornerRangeNm];
+		} else {
+			return nil;
+		}
+	},
+};
+
+
+#   ██████  ███    ███ ████████ 
+#  ██       ████  ████    ██    
+#  ██   ███ ██ ████ ██    ██ 
+#  ██    ██ ██  ██  ██    ██ 
+#   ██████  ██      ██    ██ 
+#                            
+#
+var F16GMTMode = {
+	rootName: "GMT",
+	longName: "Ground Moving Target",
+	discSpeed_dps: 55,
+	maxRange: 40,
+	bars: 4,
+	detectAIR: 0,
+	detectSURFACE: 1,
+	detectMARINE: 0,
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16GMTMode, F16SeaMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		subMode.superMode = mode;
+		subMode.shortName = mode.shortName;
+		subMode.rootName = mode.rootName;
+		return mode;
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		me.devGMT = contact.getDeviationStored();
+		if (me.devGMT.speed_kt < 10) return nil;# A gain knob decide this. (should it be radial speed instead?)
+		return [1,0,1,1,0,1];
+	},
+};
+
+
+#  ██    ██ ███████
+#  ██    ██ ██     
+#  ██    ██ ███████
+#   ██  ██       ██ 
+#    ████   ███████ 
+#                           
+#
+var F16VSMode = {
+	shortName: "VS",#todo: make vsr also for newer blocks
+	longName: "Velocity Search",
+	range: 160,
+	discSpeed_dps: 45,
+	discSpeed_alert_dps: 45,    # From manual
+	discSpeed_confirm_dps: 100, # From manual
+	maxScanIntervalForVelocity: 12,
+	rcsFactor: 1.15,
+	minClosure: 75, # kt
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16VSMode, F16LRSMode, F16RWSMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		subMode.superMode = mode;
+		subMode.shortName = mode.shortName;
+		return mode;
+	},
+	frameCompleted: func {
+		if (me.lastFrameStart != -1 and me.discSpeed_dps == me.discSpeed_alert_dps) {
+			# Its max around 11.5 secs for alert scan
+			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
+		}
+		me.lastFrameStart = me.radar.elapsed;
+		if (me.discSpeed_dps == me.discSpeed_alert_dps) {
+			me.discSpeed_dps = me.discSpeed_confirm_dps;
+		} elsif (me.discSpeed_dps == me.discSpeed_confirm_dps) {
+			me.discSpeed_dps = me.discSpeed_alert_dps;
+		}
+	},
+	designate: func (designate_contact) {
+		if (designate_contact == nil) return;
+		me.radar.setCurrentMode(me.subMode, designate_contact);
+		me.subMode.radar = me.radar;# find some smarter way of setting it.
+		me.radar.registerBlep(designate_contact, designate_contact.getDeviationStored(), 0);
+	},
+	designatePriority: func {
+		# NOP
+	},
+	undesignate: func {
+		# NOP
+	},
+	preStep: func {
+		me.elevationTilt = me.radar.getTiltKnob();
+		var dev_tilt_deg = me.cursorAz;
+		if (me.az == 60) {
+			dev_tilt_deg = 0;
+		}
+		me.azimuthTilt = dev_tilt_deg;
+		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+		}
+	},
+	increaseRange: func {
+		#me._increaseRange();
+	},
+	decreaseRange: func {
+		#me._decreaseRange();
+	},
+	showRangeOptions: func {
+		return 0;
+	},
+	setRange: func {# Range is always 160 in VS
+		return 0;
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		#print(me.currentTracked,"   ",(me.radar.elapsed - contact.blepTime));
+		if (((me.radar.elapsed - contact.getLastBlepTime()) < me.maxScanIntervalForVelocity) and contact.getLastClosureRate() > 0) {
+			#print("VELOCITY");
+			return [0,0,1,1,1,0];
+		}
+		#print("  EMPTY");
+		return [0,0,0,0,1,0];
+	},
+	getCursorAltitudeLimits: func {
+		return nil;
+	},
+};
+
+
+
+
+
+
+
+#  ████████ ██     ██ ███████ 
+#     ██    ██     ██ ██      
+#     ██    ██  █  ██ ███████ 
+#     ██    ██ ███ ██      ██ 
+#     ██     ███ ███  ███████ 
+#                             
+#
+var F16TWSMode = {
+	radar: nil,
+	shortName: "TWS",
+	longName: "Track While Scan",
+	superMode: nil,
+	subMode: nil,
+	maxRange: 80,
+	discSpeed_dps: 50, # source: https://www.youtube.com/watch?v=Aq5HXTGUHGI
+	rcsFactor: 0.9,
+	timeToBlinkTracks: 8,# GR1F-16CJ-34-1-1
+	maxScanIntervalForTrack: 6.5,# authentic for TWS
+	priorityTarget: nil,
+	currentTracked: [],
+	maxTracked: 10,
+	az: 25,# slow scan, so default is 25 to get those double taps in there.
+	bars: 3,# default is less due to need 2 scans of target to get groundtrack
+	EXPsupport: 1,#if support zoom
+	EXPsearch: 0,# if zoom should include search targets
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16TWSMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		subMode.superMode = mode;
+		subMode.shortName = mode.shortName;
+		return mode;
+	},
+	cycleAZ: func {
+		if (me.az == 10) {
+			me.az = 25;
+		} elsif (me.az == 25 and me.priorityTarget == nil) {
+			me.az = 60;
+		} elsif (me.az == 25) {
+			me.az = 10;
+		} elsif (me.az == 60) {
+			me.az = 10;
+		}
+	},
+	cycleBars: func {
+		me.bars += 1;
+		if (me.priorityTarget != nil and me.bars > 3) {
+			me.bars = 2;
+		}
+		if (me.bars == 5) me.bars = 2;# bars:1 not available in TWS
+		me.nextPatternNode = 0;
+	},
+	designate: func (designate_contact) {
+		if (designate_contact != nil) {
+			me.radar.setCurrentMode(me.subMode, designate_contact);
+			me.subMode.radar = me.radar;# find some smarter way of setting it.
+		} else {
+			me.priorityTarget = nil;
+		}
+	},
+	designatePriority: func (contact) {
+		me.priorityTarget = contact;
+		if (contact != nil) {
+			# With a target of interest (TOI), AZ is not allowed to be 60
+			# Source MLU Tape 1:
+			me.bars = math.min(3, me.bars);
+			me.az = math.min(25, me.az);
+		}
+	},
+	getPriority: func {
+		return me.priorityTarget;
+	},
+	undesignate: func {
+		me.priorityTarget = nil;
+	},
+	preStep: func {
+	 	me.azimuthTilt = me.cursorAz;
+	 	me.elevationTilt = me.radar.getTiltKnob();
+		if (me.priorityTarget != nil) {
+			if (!size(me.priorityTarget.getBleps()) or me.priorityTarget.getLastRangeDirect() == nil or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget) or me.radar.elapsed - me.priorityTarget.getLastBlepTime() > me.radar.timeToKeepBleps) {
+				me.priorityTarget = nil;
+				me.undesignate();
+				return;
+			}
+			me.prioRange_nm = me.priorityTarget.getLastRangeDirect()*M2NM;
+			me.lastBlep = me.priorityTarget.getLastBlep();
+			if (me.lastBlep != nil) {
+				me.centerTilt = me.lastBlep.getAZDeviation();
+				if (me.centerTilt > me.azimuthTilt+me.az) {
+					me.azimuthTilt = me.centerTilt-me.az;
+				} elsif (me.centerTilt < me.azimuthTilt-me.az) {
+					me.azimuthTilt = me.centerTilt+me.az;
+				}
+				me.elevationTilt = me.lastBlep.getElev();
+			} else {
+				me.priorityTarget = nil;
+				me.undesignate();
+				return;
+			}
+			if (me.prioRange_nm < 0.40 * me.getRange()) {
+				me._decreaseRange();
+			} elsif (me.prioRange_nm > 0.90 * me.getRange()) {
+				me._increaseRange();
+			} elsif (me.prioRange_nm < 3) {
+				# auto go to STT when target is very close
+				me.designate(me.priorityTarget);
+			}
+			# Source MLU Tape 1:
+			me.bars = math.min(3, me.bars);
+			me.az = math.min(25, me.az);
+		} else {
+			me.undesignate();
+		}
+		me.constrainAz();
+	},
+	frameCompleted: func {
+		if (me.lastFrameStart != -1) {
+			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+		}
+		me.lastFrameStart = me.radar.elapsed;
+	},
+	enterMode: func {
+		me.currentTracked = [];
+		foreach(c;me.radar.vector_aicontacts_bleps) {
+			c.ignoreTrackInfo();# Kind of a hack to make it give out false info. Bypasses hadTrackInfo() but not hasTrackInfo().
+		}
+	},
+	leaveMode: func {
+		me.priorityTarget = nil;
+		me.lastFrameStart = -1;
+	},
+	increaseRange: func {
+		if (me.priorityTarget != nil) return 0;
+		me._increaseRange();
+	},
+	decreaseRange: func {
+		if (me.priorityTarget != nil) return 0;
+		me._decreaseRange();
+	},
+	showRangeOptions: func {
+		if (me.priorityTarget != nil) return 0;
+		return 1;
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		#print(me.currentTracked,"   ",(me.radar.elapsed - contact.blepTime));
+		me.scanInterval = (me.radar.elapsed - contact.getLastBlepTime()) < me.maxScanIntervalForTrack;
+		me.isInCurrent = me.radar.containsVectorContact(me.currentTracked, contact);
+		if (size(me.currentTracked) < me.maxTracked and me.scanInterval) {
+			#print("  TWICE    ",me.radar.elapsed);
+			#print(me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, contact),"   ",me.radar.elapsed - contact.blepTime);
+			if (!me.isInCurrent) append(me.currentTracked, contact);
+			return [1,1,1,1,1,1];
+		} elsif (me.isInCurrent and me.scanInterval) {
+			return [1,1,1,1,1,1];
+		} elsif (me.isInCurrent) {
+			me.tmp = [];
+			foreach (me.cc ; me.currentTracked) {
+				if(!me.cc.equals(contact)) {
+					append(me.tmp, me.cc);
+				}
+			}
+			me.currentTracked = me.tmp;
+		}
+		#print("  ONCE    ",me.currentTracked);
+		return [1,0,1,0,0,1];
+	},
+	prunedContact: func (c) {
+		if (c.equals(me.priorityTarget)) {
+			me.priorityTarget = nil;# this might have fixed the nil exception
+		}
+		if (c.hadTrackInfo()) {
+			me.del = me.radar.containsVectorContact(me.currentTracked, c);
+			if (me.del) {
+				me.tmp = [];
+				foreach (me.cc ; me.currentTracked) {
+					if(!me.cc.equals(c)) {
+						append(me.tmp, me.cc);
+					}
+				}
+				me.currentTracked = me.tmp;
+			}
+		}
+	},
+	testContact: func (contact) {
+		#if (me.radar.elapsed - contact.getLastBlepTime() > me.maxScanIntervalForTrack and contact.azi == 1) {
+		#	contact.azi = 0;
+		#	me.currentTracked -= 1;
+		#}
+	},
+	cycleDesignate: func {
+		if (!size(me.radar.vector_aicontacts_bleps)) {
+			me.priorityTarget = nil;
+			return;
+		}
+		if (me.priorityTarget == nil) {
+			me.testIndex = -1;
+		} else {
+			me.testIndex = me.radar.vectorIndex(me.radar.vector_aicontacts_bleps, me.priorityTarget);
+		}
+		for(me.i = me.testIndex+1;me.i<size(me.radar.vector_aicontacts_bleps);me.i+=1) {
+			#if (me.radar.vector_aicontacts_bleps[me.i].hadTrackInfo()) {
+				me.priorityTarget = me.radar.vector_aicontacts_bleps[me.i];
+				return;
+			#}
+		}
+		for(me.i = 0;me.i<=me.testIndex;me.i+=1) {
+			#if (me.radar.vector_aicontacts_bleps[me.i].hadTrackInfo()) {
+				me.priorityTarget = me.radar.vector_aicontacts_bleps[me.i];
+				return;
+			#}
+		}
+	},
+};
+
+
+
+
+#  ██████  ██     ██ ███████       ███████  █████  ███    ███ 
+#  ██   ██ ██     ██ ██            ██      ██   ██ ████  ████ 
+#  ██████  ██  █  ██ ███████ █████ ███████ ███████ ██ ████ ██ 
+#  ██   ██ ██ ███ ██      ██            ██ ██   ██ ██  ██  ██ 
+#  ██   ██  ███ ███  ███████       ███████ ██   ██ ██      ██ 
+#                                                             
+#
+var F16RWSSAMMode = {
+	radar: nil,
+	shortName: "RWS",
+	longName: "Range While Search - Situational Awareness Mode",
+	superMode: nil,
+	discSpeed_dps: 65,
+	rcsFactor: 0.9,
+	maxRange: 160,
+	priorityTarget: nil,
+	bars: 2,
+	azMFD: 60,
+	new: func (subMode = nil, radar = nil) {
+		var mode = {parents: [F16RWSSAMMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		if (subMode != nil) {
+			subMode.superMode = mode;
+			subMode.radar = radar;
+			subMode.shortName = mode.shortName;
+		}
+		return mode;
+	},
+	calcSAMwidth: func {
+		if (me.prioRange_nm<30) return math.min(60,18 + 2.066667*me.prioRange_nm - 0.02222222*me.prioRange_nm*me.prioRange_nm);
+		else return 60;
+	},
+	preStep: func {
+		me.azimuthTilt = me.cursorAz;
+		me.elevationTilt = me.radar.getTiltKnob();
+		if (me.priorityTarget != nil) {
+			# azimuth width is autocalculated in F16 AUTO-SAM:
+			if (!size(me.priorityTarget.getBleps()) or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget)) {
+				me.priorityTarget = nil;
+				me.undesignate();
+				return;
+			}
+			me.prioRange_nm = me.priorityTarget.getRangeDirect()*M2NM;
+			me.az = math.min(me.calcSAMwidth(), me.azMFD);#GR1F-16CJ-34-1-1 page 1-125
+			me.lastBlep = me.priorityTarget.getLastBlep();
+			if (me.lastBlep != nil) {
+				if (math.abs(me.azimuthTilt - (me.lastBlep.getAZDeviation())) > me.az) {
+					me.scanPriorityEveryFrame = 1;
+				} else {
+					me.scanPriorityEveryFrame = 0; # due to the overlap not being perfect, scan the designation extra, just to be safe
+				}
+				me.elevationTilt = me.lastBlep.getElev();
+			} else {
+				me.priorityTarget = nil;
+				me.undesignate();
+				return;
+			}
+			if (me.prioRange_nm < 0.40 * me.getRange()) {
+				me._decreaseRange();
+			} elsif (me.prioRange_nm > 0.90 * me.getRange()) {
+				me._increaseRange();
+			} elsif (me.prioRange_nm < 3) {
+				# auto go to STT when target is very close
+				me.designate(me.priorityTarget);
+			}
+		} else {
+			me.scanPriorityEveryFrame = 0;
+			me.undesignate();
+		}
+		me.constrainAz();
+	},
+	undesignate: func {
+		me.priorityTarget = nil;
+		me.radar.setCurrentMode(me.superMode, nil);
+	},
+	designate: func (designate_contact) {
+		if (designate_contact == nil) return;
+		if (designate_contact.equals(me.priorityTarget)) {
+			me.radar.setCurrentMode(me.subMode, designate_contact);
+			me.subMode.radar = me.radar;# find some smarter way of setting it.
+		} else {
+			me.priorityTarget = designate_contact;
+		}
+	},
+	designatePriority: func (contact) {
+		me.priorityTarget = contact;
+	},
+	cycleBars: func {
+		me.bars += 1;
+		if (me.bars == 3) me.bars = 4;# 3 is only for TWS
+		elsif (me.bars == 5) me.bars = 1;
+		me.nextPatternNode = 0;
+	},
+	cycleAZ: func {
+		if (me.azMFD == 10) me.azMFD = 30;
+		elsif (me.azMFD == 30) me.azMFD = 60;
+		elsif (me.azMFD == 60) me.azMFD = 10;
+	},
+	getAz: func {
+		return me.azMFD;
+	},
+	increaseRange: func {# Range is auto-set in RWS-SAM
+		return 0;
+	},
+	decreaseRange: func {# Range is auto-set in RWS-SAM
+		return 0;
+	},
+	setRange: func {# Range is auto-set in RWS-SAM
+	},
+	leaveMode: func {
+		me.priorityTarget = nil;
+		me.lastFrameStart = -1;
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		if (me.priorityTarget != nil and contact.equals(me.priorityTarget)) {
+			return [1,1,1,1,1,1];
+		}
+		return [1,0,1,0,0,1];
+	},
+	showRangeOptions: func {
+		return 0;
+	},
+	showAZ: func {
+		return 1;
+	},
+};
+
+
+#  ██      ██████  ███████       ███████  █████  ███    ███ 
+#  ██      ██   ██ ██            ██      ██   ██ ████  ████ 
+#  ██      ██████  ███████ █████ ███████ ███████ ██ ████ ██ 
+#  ██      ██   ██      ██            ██ ██   ██ ██  ██  ██ 
+#  ███████ ██   ██ ███████       ███████ ██   ██ ██      ██ 
+#                                                           
+#
+var F16LRSSAMMode = {
+	shortName: "LRS",
+	longName: "Long Range Search - Situational Awareness Mode",
+	discSpeed_dps: 45,
+	rcsFactor: 1,
+	new: func (subMode = nil, radar = nil) {
+		var mode = {parents: [F16LRSSAMMode, F16RWSSAMMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		if (subMode != nil) {
+			subMode.superMode = mode;
+			subMode.radar = radar;
+			subMode.shortName = mode.shortName;
+		}
+		return mode;
+	},
+	showAZ: func {
+		return 1;
+	},
+	calcSAMwidth: func {
+		if (me.prioRange_nm<42) return math.min(60,18 + 1.4*me.prioRange_nm - 0.01*me.prioRange_nm*me.prioRange_nm);
+		else return 60;
+	},
+};
+
+
+
+#   █████   ██████ ███    ███ 
+#  ██   ██ ██      ████  ████ 
+#  ███████ ██      ██ ████ ██ 
+#  ██   ██ ██      ██  ██  ██ 
+#  ██   ██  ██████ ██      ██ 
+#                             
+#
+var F16ACMMode = {#TODO
+	radar: nil,
+	rootName: "ACM",
+	shortName: "STBY",
+	longName: "Air Combat Mode Standby",
+	superMode: nil,
+	subMode: nil,
+	range: 10,
+	maxRange: 10,
+	discSpeed_dps: 84.6,# have reliable source for this.
+	rcsFactor: 0.9,
+	timeToFadeBleps: 1,
+	bars: 1,
+	az: 1,
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16ACMMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		mode.subMode.superMode = mode;
+		mode.subMode.shortName = mode.shortName;
+		return mode;
+	},
+	showBars: func {
+		return 0;
+	},
+	showAZinHSD: func {
+		return 0;
+	},
+	cycleAZ: func {	},
+	cycleBars: func { },
+	designate: func (designate_contact) {
+	},
+	designatePriority: func (contact) {
+
+	},
+	getPriority: func {
+		return nil;
+	},
+	undesignate: func {
+	},
+	preStep: func {
+	},
+	increaseRange: func {
+		return 0;
+	},
+	decreaseRange: func {
+		return 0;
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		return nil;
+	},
+	testContact: func (contact) {
+	},
+	cycleDesignate: func {
+	},
+};
+
+var F16ACM20Mode = {
+	radar: nil,
+	rootName: "ACM",
+	shortName: "20",
+	longName: "Air Combat Mode 30x20",
+	superMode: nil,
+	subMode: nil,
+	range: 10,
+	minRange: 10,
+	maxRange: 10,
+	discSpeed_dps: 84.6,
+	rcsFactor: 0.9,
+	timeToFadeBleps: 1,# TODO
+	bars: 1,
+	barPattern: [ [[1,-7],[1,3],[-1,3],[-1,1],[1,1],[1,-1],[-1,-1],[-1,-3],[1,-3],[1,-5],[-1,-5],[-1,-7]] ],
+	az: 15,
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16ACM20Mode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		mode.subMode.superMode = mode;
+		mode.subMode.shortName = mode.shortName;
+		return mode;
+	},
+	showBars: func {
+		return 0;
+	},
+	showAZinHSD: func {
+		return 0;
+	},
+	cycleAZ: func {	},
+	cycleBars: func { },
+	designate: func (designate_contact) {
+		if (designate_contact == nil) {
+			acmLockSound.setBoolValue(0);
+			return;
+		}
+		acmLockSound.setBoolValue(1);
+		me.radar.setCurrentMode(me.subMode, designate_contact);
+		me.subMode.radar = me.radar;
+	},
+	designatePriority: func (contact) {
+	},
+	getPriority: func {
+		return nil;
+	},
+	undesignate: func {
+	},
+	preStep: func {
+		me.radar.horizonStabilized = 0;
+		me.elevationTilt = -3;
+	},
+	increaseRange: func {
+		return 0;
+	},
+	decreaseRange: func {
+		return 0;
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		me.designate(contact);
+		return [1,1,1,1,1,1];
+	},
+	testContact: func (contact) {
+	},
+	cycleDesignate: func {
+	},
+	getCursorAltitudeLimits: func {
+		return nil;
+	},
+};
+
+var F16ACM60Mode = {
+	radar: nil,
+	rootName: "ACM",
+	shortName: "60",
+	longName: "Air Combat Mode 10x60",
+	superMode: nil,
+	subMode: nil,
+	maxRange: 10,
+	discSpeed_dps: 84.6,
+	rcsFactor: 0.9,
+	bars: 1,
+	barHeight: 1.0/APG68.instantFoVradius,# multiple of instantFoV (in this case 1 deg)
+	az: 5,
+	barPattern:  [ [[-0.6,-5],[0.0,-5],[0.0, 51],[0.6,51],[0.6,-5],[0.0,-5],[0.0,51],[-0.6,51]], ],
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16ACM60Mode, F16ACM20Mode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		mode.subMode.superMode = mode;
+		mode.subMode.shortName = mode.shortName;
+		return mode;
+	},
+	preStep: func {
+		me.radar.horizonStabilized = 0;
+		me.elevationTilt = 0;
+	},
+};
+
+var F16ACMBoreMode = {
+	radar: nil,
+	rootName: "ACM",
+	shortName: "BORE",
+	longName: "Air Combat Mode Bore",
+	bars: 1,
+	barHeight: 1.0,# multiple of instantFoV (in this case 1 deg)
+	az: 0,
+	barPattern:  [ [[0.0,-1]], ],
+	new: func (subMode, radar = nil) {
+		var mode = {parents: [F16ACMBoreMode, F16ACM20Mode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		mode.subMode = subMode;
+		mode.subMode.superMode = mode;
+		mode.subMode.shortName = mode.shortName;
+		return mode;
+	},
+	preStep: func {
+		me.radar.horizonStabilized = 0;
+		me.elevationTilt = -me.radar.instantFoVradius;
+		me.azimuthTilt = 0;
+		if (getprop("payload/armament/hmd-active") == 1) {
+			me.azimuthTilt = math.clamp(getprop("payload/armament/hmd-horiz-deg"),-60,60);
+			me.elevationTilt = math.clamp(getprop("payload/armament/hmd-vert-deg"),-60,60);
+		}
+	},
+	step: func (dt) {
+		me.preStep();
+		me.localDirHMD = vector.Math.pitchYawVector(me.elevationTilt, -me.azimuthTilt, [1,0,0]);
+		me.angleToHMD = vector.Math.angleBetweenVectors(me.radar.positionDirection, me.localDirHMD);
+		me.maxMove = math.min(me.angleToHMD, me.discSpeed_dps*dt);
+		if (me.angleToHMD < 0.1) {
+			me.radar.setAntennae(me.localDirHMD);
+			me.lastFrameDuration = 0;
+			return 0;
+		}
+		# Great circle movement to reach the bore spot
+		me.newPos = vector.Math.rotateVectorTowardsVector(me.radar.positionDirection, me.localDirHMD, me.maxMove);
+		me.radar.setAntennae(me.newPos);
+		return dt-me.maxMove/me.discSpeed_dps;
+	},
+};
+
+
+
+
+#  ███████ ████████ ████████ 
+#  ██         ██       ██    
+#  ███████    ██       ██ 
+#       ██    ██       ██ 
+#  ███████    ██       ██ 
+#                         
+#
+var F16STTMode = {
+	radar: nil,
+	shortName: "STT",
+	longName: "Single Target Track",
+	superMode: nil,
+	discSpeed_dps: 80,
+	rcsFactor: 1,
+	maxRange: 160,
+	priorityTarget: nil,
+	az: APG68.instantFoVradius*0.8,
+	barHeight: 0.90,# multiple of instantFoVradius
+	bars: 2,
+	minimumTimePerReturn: 0.10,
+	timeToFadeBleps: 13, # Need to have time to move disc to the selection from wherever it was before entering STT. Plus already faded bleps from superMode will get pruned if this is to low.
+	debug: 1,
+	painter: 1,
+	debug: 0,
+	new: func (radar = nil) {
+		var mode = {parents: [F16STTMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		return mode;
+	},
+	showAZ: func {
+		return 0;
+	},
+	showAZinHSD: func {
+		return 0;
+	},
+	showBars: func {
+		return me.superMode.showBars();
+	},
+	showRangeOptions: func {
+		return 0;
+	},
+	getBars: func {
+		return me.superMode.getBars();
+	},
+	getAz: func {
+		# We return the parents mode AZ and bars in this class, so they are shown in radar display as B4 A4 etc etc.
+		return me.superMode.getAz();
+	},
+	preStep: func {
+		me.debug = getprop("debug-radar/debug-stt");
+		if (me.priorityTarget != nil and size(me.priorityTarget.getBleps())) {
+			me.lastBlep = me.priorityTarget.getLastBlep();
+			if (me.debug > 0) {
+				setprop("debug-radar/STT-bleps", size(me.priorityTarget.getBleps()));
+			}
+			if (me.lastBlep != nil) {
+				me.azimuthTilt = me.lastBlep.getAZDeviation();
+				me.elevationTilt = me.lastBlep.getElev(); # tilt here is in relation to horizon
+			} else {
+				me.priorityTarget = nil;
+				me.undesignate();
+				return;
+			}
+			if (!size(me.priorityTarget.getBleps()) or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget)) {
+				me.priorityTarget = nil;
+				me.undesignate();
+				return;
+			} elsif (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+				me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+			} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+				me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+			}
+			if (me.priorityTarget.getRangeDirect()*M2NM < 0.40 * me.getRange()) {
+				me._decreaseRange();
+			}
+			if (me.priorityTarget.getRangeDirect()*M2NM > 0.90 * me.getRange()) {
+				me._increaseRange();
+			}
+			if (me.debug > 0) {
+				setprop("debug-radar/STT-focused", me.priorityTarget.get_Callsign());
+			}
+		} else {
+			if (me.debug > 0) {
+				setprop("debug-radar/STT-focused", "--none--");
+			}
+			if (me.debug > 0) {
+				setprop("debug-radar/STT-bleps", -1);
+			}
+			me.priorityTarget = nil;
+			me.undesignate();
+		}
+	},
+	designatePriority: func (prio) {
+		me.priorityTarget = prio;
+	},
+	undesignate: func {
+		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
+		me.priorityTarget = nil;
+		#var log = caller(1); foreach (l;log) print(l);
+	},
+	designate: func {},
+	cycleBars: func {},
+	cycleAZ: func {},
+	increaseRange: func {# Range is auto-set in STT
+		return 0;
+	},
+	decreaseRange: func {# Range is auto-set in STT
+		return 0;
+	},
+	setRange: func {# Range is auto-set in STT
+	},
+	frameCompleted: func {
+		if (me.lastFrameStart != -1) {
+			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+			#me.timeToFadeBleps = math.max(2, me.radar.targetHistory*me.lastFrameDuration);
+		}
+		me.lastFrameStart = me.radar.elapsed;
+	},
+	leaveMode: func {
+		me.priorityTarget = nil;
+		me.lastFrameStart = -1;
+		me.timeToFadeBleps = 13;# Reset to 5, since getSearchInfo might have lowered it.
+	},
+	getSearchInfo: func (contact) {
+		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+		if (me.priorityTarget != nil and contact.equals(me.priorityTarget)) {
+			me.timeToFadeBleps = 1.5;
+			return [1,1,1,1,1,1];
+		}
+		return nil;
+	},
+	getCursorAltitudeLimits: func {
+		return nil;
+	},
+};
+
+var F16ACMSTTMode = {
+	rootName: "ACM",
+	shortName: "STT",
+	longName: "Air Combat Mode - Single Target Track",
+	new: func (radar = nil) {
+		var mode = {parents: [F16ACMSTTMode, F16STTMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		return mode;
+	},
+	designatePriority: func (prio) {
+		me.priorityTarget = prio;
+		if (prio != nil) acmLockSound.setBoolValue(1);
+	},
+	undesignate: func {
+		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
+		me.priorityTarget = nil;
+		acmLockSound.setBoolValue(0);
+	},
+};
+
+var F16MultiSTTMode = {
+	rootName: "CRM",
+	shortName: "STT",
+	longName: "Multisearch - Single Target Track",
+	new: func (radar = nil) {
+		var mode = {parents: [F16MultiSTTMode, F16STTMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		return mode;
+	},
+	undesignate: func {
+		if (me.priorityTarget != nil and me.priorityTarget.getRangeDirect()*M2NM < 3) {
+			me.priorityTarget = nil;
+		}
+		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
+		me.priorityTarget = nil;
+		#var log = caller(1); foreach (l;log) print(l);
+	},
+};
+
+
+#  ███████ ████████ ████████ 
+#  ██         ██       ██    
+#  █████      ██       ██ 
+#  ██         ██       ██ 
+#  ██         ██       ██ 
+#                         
+#
+var F16SEAFTTMode = {
+	rootName: "",
+	shortName: "FTT",
+	longName: "SEA Mode - Fixed Target Track",
+	maxRange: 80,
+	detectAIR: 0,
+	detectSURFACE: 0,
+	detectMARINE: 1,
+	pulse: MONO,
+	minimumTimePerReturn: 0.20,
+	new: func (radar = nil) {
+		var mode = {parents: [F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		return mode;
+	},
+};
+
+var F16GMFTTMode = {
+	longName: "Ground Map Mode - Fixed Target Track",
+	detectSURFACE: 1,
+	detectMARINE: 0,
+	mapper: 1,
+	new: func (radar = nil) {
+		var mode = {parents: [F16GMFTTMode, F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		return mode;
+	},
+	getPriority: func {
+		if (me.priorityTarget == nil or (rand() > 0.95 and me.priorityTarget.getSpeed() < 11)) {
+			return me.priorityTarget;
+		} else {
+			return me.priorityTarget.getNearbyVirtualContact(60);
+		}
+	},
+};
+
+var F16GMTFTTMode = {
+	longName: "Ground Moving Target - Fixed Target Track",
+	detectSURFACE: 1,
+	detectMARINE: 0,
+	new: func (radar = nil) {
+		var mode = {parents: [F16GMTFTTMode, F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
+		mode.radar = radar;
+		return mode;
+	},
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+#  ███████        ██  ██████      ██████  ██     ██ ██████ 
+#  ██            ███ ██           ██   ██ ██     ██ ██   ██ 
+#  █████   █████  ██ ███████      ██████  ██  █  ██ ██████  
+#  ██             ██ ██    ██     ██   ██ ██ ███ ██ ██   ██ 
+#  ██             ██  ██████      ██   ██  ███ ███  ██   ██ 
+#                                                           
+#
+
+var noRadarList = {
+	# These have no radar
+	depot:nil, point:nil, struct:nil, rig:nil, truck:nil, hunter:nil,
+	"alphajet":nil, "jaguar":nil, "Jaguar-GR3":nil, "A-10-modelB":nil, "Jaguar-GR1":nil, "A-10-model":nil, "A-10":nil, "G91-R1B":nil, "G91":nil, "g91":nil, "mb339":nil, "mb339pan":nil,
+};
+
+var RWR = {
+	# inherits from Radar
+	# will check radar/transponder and ground occlusion.
+	# will sort according to threat level
+	new: func () {
+		var rr = {parents: [RWR, Radar]};
+
+		rr.vector_aicontacts = [];
+		rr.vector_aicontacts_threats = [];
+		#rr.timer          = maketimer(2, rr, func rr.scan());
+
+		rr.RWRRecipient = emesary.Recipient.new("RWRRecipient");
+		rr.RWRRecipient.radar = rr;
+		rr.RWRRecipient.Receive = func(notification) {
+	        if (notification.NotificationType == "OmniNotification") {
+	        	#printf("RWR recv: %s", notification.NotificationType);
+	            if (me.radar.enabled == 1) {
+	    		    me.radar.vector_aicontacts = notification.vector;
+	    		    me.radar.scan();
+	    	    }
+	            return emesary.Transmitter.ReceiptStatus_OK;
+	        }
+	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+	    };
+		emesary.GlobalTransmitter.Register(rr.RWRRecipient);
+		rr.RWRNotification = VectorNotification.new("RWRNotification");
+		rr.RWRNotification.updateV(rr.vector_aicontacts_threats);
+		#rr.timer.start();
+		return rr;
+	},
+	heatDefense: 0,
+	scan: func {
+		# sort in threat?
+		# run by notification
+		# mock up code, ultra simple threat index, is just here cause rwr have special needs:
+		# 1) It has almost no range restriction
+		# 2) Its omnidirectional
+		# 3) It might have to update fast (like 0.25 secs)
+		# 4) To build a proper threat index it needs at least these properties read:
+		#       model type
+		#       class (AIR/SURFACE/MARINE)
+		#       lock on myself
+		#       missile launch
+		#       transponder on/off
+		#       bearing and heading
+		#       IFF info
+		#       ECM
+		#       radar on/off
+		if (!getprop("instrumentation/rwr/serviceable") or getprop("f16/avionics/power-ufc-warm") != 1 or getprop("f16/ews/ew-rwr-switch") != 1) {
+            setprop("sound/rwr-lck", 0);
+            setprop("ai/submodels/submodel[0]/flare-auto-release-cmd", 0);
+            return;
+        }
+        me.vector_aicontacts_threats = [];
+		me.fct = 10*2.0;
+        me.myCallsign = self.getCallsign();
+        me.myCallsign = size(me.myCallsign) < 8 ? me.myCallsign : left(me.myCallsign,7);
+        me.act_lck = 0;
+        me.autoFlare = 0;
+        me.closestThreat = 0;
+        me.elapsed = elapsedProp.getValue();
+        foreach(me.u ; me.vector_aicontacts) {
+        	# [me.ber,me.head,contact.getCoord(),me.tp,me.radar,contact.getDeviationHeading(),contact.getRangeDirect()*M2NM, contact.getCallsign()]
+        	me.threatDB = me.u.getThreatStored();
+            me.cs = me.threatDB[7];
+            me.rn = me.threatDB[6];
+            if ((me.u["blue"] != nil and me.u.blue == 1 and !me.threatDB[10]) or me.rn > 150) {
+                continue;
+            }
+            me.bearing = me.threatDB[0];
+            me.trAct = me.threatDB[3];
+            me.show = 1;
+            me.heading = me.threatDB[1];
+            me.inv_bearing =  me.bearing+180;#bearing from target to me
+            me.deviation = me.inv_bearing - me.heading;# bearing deviation from target to me
+            me.dev = math.abs(geo.normdeg180(me.deviation));# my degrees from opponents nose
+
+            if (me.show == 1) {
+                if (me.dev < 30 and me.rn < 7 and me.threatDB[8] > 60) {
+                    # he is in position to fire heatseeker at me
+                    me.heatDefenseNow = me.elapsed + me.rn*1.5;
+                    if (me.heatDefenseNow > me.heatDefense) {
+                        me.heatDefense = me.heatDefenseNow;
+                    }
+                }
+                me.threat = 0;
+                if (me.u.getModel() != "missile_frigate" and me.u.getModel() != "S-75" and me.u.getModel() != "SA-6" and me.u.getModel() != "buk-m2" and me.u.getModel() != "MIM104D" and me.u.getModel() != "s-200" and me.u.getModel() != "s-300" and me.u.getModel() != "fleet" and me.u.getModel() != "ZSU-23-4M") {
+                    me.threat += ((180-me.dev)/180)*0.30;# most threat if I am in front of his nose
+                    me.spd = (60-me.threatDB[8])/60;
+                    #me.threat -= me.spd>0?me.spd:0;# if his speed is lower than 60kt then give him minus threat else positive
+                } elsif (me.u.getModel() == "missile_frigate" or me.u.getModel() == "fleet") {
+                    me.threat += 0.30;
+                } else {
+                    me.threat += 0.30;
+                }
+                me.danger = 50;# within this range he is most dangerous
+                if (me.u.getModel() == "missile_frigate" or me.u.getModel() == "fleet" or me.u.getModel() == "s-300") {
+                    me.danger = 80;
+                } elsif (me.u.getModel() == "buk-m2" or me.u.getModel() == "S-75") {
+                    me.danger = 35;
+                } elsif (me.u.getModel() == "SA-6") {
+                    me.danger = 15;
+                } elsif (me.u.getModel() == "s-200") {
+                    me.danger = 150;
+                } elsif (me.u.getModel() == "MIM104D") {
+                    me.danger = 45;
+                } elsif (me.u.getModel() == "ZSU-23-4M") {
+                    me.danger = 7.5;
+                }
+                if (me.threatDB[10]) me.threat += 0.30;# has me locked
+                me.threat += ((me.danger-me.rn)/me.danger)>0?((me.danger-me.rn)/me.danger)*0.60:0;# if inside danger zone then add threat, the closer the more.
+                me.threat += me.threatDB[9]>0?(me.threatDB[9]/500)*0.10:0;# more closing speed means more threat.
+                if (me.u.getModel() == "AI") me.threat = 0.01;
+                if (contains(noRadarList, me.u.getModel())) me.threat = - 1;
+                if (me.threat > me.closestThreat) me.closestThreat = me.threat;
+                #printf("A %s threat:%.2f range:%d dev:%d", me.u.get_Callsign(),me.threat,me.u.get_range(),me.deviation);
+                if (me.threat > 1) me.threat = 1;
+                if (me.threat <= 0) continue;
+                #printf("B %s threat:%.2f range:%d dev:%d", me.u.get_Callsign(),me.threat,me.u.get_range(),me.deviation);
+                append(me.vector_aicontacts_threats,[me.u,me.threat, me.threatDB[5]]);
+            } else {
+#                printf("%s ----", me.u.get_Callsign());
+            }
+        }
+
+        me.launchClose = getprop("payload/armament/MLW-launcher") != "";
+        me.incoming = getprop("payload/armament/MAW-active") or getprop("payload/armament/MAW-semiactive") or me.heatDefense > me.elapsed;
+        me.spike = 0;#getprop("payload/armament/spike")*(getprop("ai/submodels/submodel[0]/count")>15);
+        me.autoFlare = me.spike?math.max(me.closestThreat*0.25,0.05):0;
+
+        if (0 and getprop("f16/ews/ew-mode-knob") == 2)
+        	print("wow: ", getprop("/fdm/jsbsim/gear/unit[0]/WOW"),"  spiked: ",me.spike,"  incoming: ",me.incoming, "  launch: ",me.launchClose,"  spikeResult:", me.autoFlare,"  aggresive:",me.launchClose * 0.85 + me.incoming * 0.85,"  total:",me.launchClose * 0.85 + me.incoming * 0.85+me.autoFlare);
+
+        me.autoFlare += me.launchClose * 0.85 + me.incoming * 0.85;
+
+        me.autoFlare *= 0.1 * 2.5 * !getprop("/fdm/jsbsim/gear/unit[0]/WOW");#0.1 being the update rate for flare dropping code.
+
+        setprop("ai/submodels/submodel[0]/flare-auto-release-cmd", me.autoFlare * (getprop("ai/submodels/submodel[0]/count")>0));
+        if (me.autoFlare > 0.80 and rand()>0.99 and getprop("ai/submodels/submodel[0]/count") < 1) {
+            setprop("ai/submodels/submodel[0]/flare-release-out-snd", 1);
+        }
+        emesary.GlobalTransmitter.NotifyAll(me.RWRNotification.updateV(me.vector_aicontacts_threats));
+	},
+	del: func {
+        emesary.GlobalTransmitter.DeRegister(me.RWRRecipient);
+    },
+};
+
+
+
+var radiation_list = {
+	"buk-m2": "11",
+    "s-300": "20",
+    "s-200": "5",
+    "S-75": "2",
+    "missile_frigate": "SH",
+    "fleet": "SH",
+    "SA-6": "6",
+    "MIM104D": "P",
+    "ZSU-23-4M": "AAA",
+    "gci": "S",
+    "A-50": "S",
+    "EC-137R": "S",
+    "E-3": "S",
+    "E-3R": "S",
+};
+
+var RadSensor = {
+	# inherits from Radar
+	new: func () {
+		var rs = {parents: [RadSensor, Radar]};
+
+		rs.vector_aicontacts = [];
+		rs.vector_aicontacts_seen = [];
+
+		rs.RadSensorRecipient = emesary.Recipient.new("RadSensorRecipient");
+		rs.RadSensorRecipient.radar = rs;
+		rs.RadSensorRecipient.Receive = func(notification) {
+	        if (notification.NotificationType == "OmniNotification") {
+	        	#printf("RadSensor recv: %s", notification.NotificationType);
+	            if (me.radar.enabled == 1) {
+	    		    me.radar.vector_aicontacts = notification.vector;
+	    	    }
+	            return emesary.Transmitter.ReceiptStatus_OK;
+	        }
+	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+	    };
+		emesary.GlobalTransmitter.Register(rs.RadSensorRecipient);
+		rs.timer          = maketimer(0.05, rs, func rs.scan());
+		rs.timer.singleShot = 1;
+		rs.enabled = 0;
+		return rs;
+	},
+	range: 40,
+	area: 10,
+	maxArea: 20,
+	maxDura: 90,
+	dura: 60,
+	searchTime: 0,
+	searchStart: 0,
+	index: -1,
+	timing: 0.05,
+	table: [],
+    tables: [["2","11","20","P","S"],["6","5"],["AAA","SH"]],
+	currtable: 0,
+	handoffTarget: nil,
+	handoffTime: 0,
+	searchCounter: 0,
+	x: [-40, 40],
+	y: [-40, 10],
+	fov: 0,
+	fov_desired: 0,
+	setEnabled: func (e) {
+		me.enabled = e;
+		if (e and !me.timer.isRunning) {
+			me.calcDura();
+        	me.timing = 0.05;
+        	me.timer.restart(me.timing);
+			me.timer.start();
+			me.searchStart = elapsedProp.getValue();
+
+			#print("setEnabled again");
+		} elsif (!e) {
+			me.timer.stop();
+			me.reset();
+		}
+	},
+	reset: func {
+		me.searchTime = 0;
+		me.searchStart = elapsedProp.getValue();
+		foreach(me.seen;me.vector_aicontacts_seen) {
+    		me.seen.discover = 0;
+    		me.seen.discoverSCT = -2;
+    	}
+		me.vector_aicontacts_seen = [];
+		me.calcDura();
+    	me.timing = 0.05;
+	},
+	calcDura: func {
+		me.dura = me.maxDura * me.area/me.maxArea * size(me.table)/5;
+	},
+	scan: func {
+		if (!me.enabled) {
+			foreach(me.seen;me.vector_aicontacts_seen) {
+        		me.seen.discover = 0;
+        		me.seen.discoverSCT = -2;
+        	}
+            me.vector_aicontacts_seen = [];
+            return;
+        }
+        me.elapsed = elapsedProp.getValue();
+
+        me.searchTime = me.elapsed-me.searchStart;
+        if (me.searchTime > me.dura) {
+        	me.index = -1;
+        	me.searchStart = me.elapsed;
+        	me.searchCounter += 1;
+        	me.searchTime = 0;
+        	#print("finished search");
+        }
+
+        if (me.index >= size(me.vector_aicontacts)-1) {
+        	me.index = -1;
+        }
+        if (!size(me.vector_aicontacts)) {
+        	foreach(me.seen;me.vector_aicontacts_seen) {
+        		me.seen.discover = 0;
+        		me.seen.discoverSCT = -2;
+        	}
+        	me.vector_aicontacts_seen = [];
+        	me.timer.restart(me.timing);
+	        if (!me.timer.isRunning) {
+	        	me.timer.start();
+	        }
+        	return;
+        }
+        me.index += 1;
+
+        me.candidate = me.vector_aicontacts[me.index];
+        #print(size(me.vector_aicontacts)," me.candidate.rd is nil: ",me.candidate["isRadiating"]==nil);
+        me.candidateModel = me.candidate.getModel();
+        if (contains(radiation_list, me.candidateModel)) {
+	        me.ownCoord = self.getCoord();
+	        me.myHeading = radar_system.self.getHeading();
+	        me.ok = 0;
+	        if (me.candidate.isRadiating(me.ownCoord)) {
+	        	me.testBearing = me.candidate.getBearing();
+	            me.testElevation = me.candidate.getElevation();
+	            me.testDev = geo.normdeg180(me.testBearing-me.myHeading);
+	            if (me.testDev > me.x[0] and me.testDev < me.x[1] and me.candidate.get_range() < me.range) {
+		            if (me.testElevation < me.y[1] and me.testElevation > me.y[0]) {
+	    	            me.candidate.radiSpike = me.candidate.isSpikingMe()?"T":"A";
+	    	            me.candidate.pos = [me.testDev, me.testElevation];
+	    	            me.candidate.mdl = radiation_list[me.candidateModel];
+
+	                    for (me.i = 0; me.i < size(me.table);me.i+=1) {
+	                        me.tableitem = me.table[me.i];
+	                        if (me.candidate.mdl == me.tableitem) {
+	                            me.ok = 1;
+	                            me.candidate.tblIdx = me.i;
+	                            if (me.candidate["discoverSCT"] != me.searchCounter) {# If we have seen this contact before in this cycle we don't recalc its discover time
+	                            	me.candidate.discover = me.dura*rand();
+	                            	me.candidate.discoverSCT = me.searchCounter;
+	                            }
+	                            break;
+	                        }
+	                    }
+	                    if (me.ok) {
+	                    	if (!me.containsVector(me.vector_aicontacts_seen, me.candidate)) {
+	                    		append(me.vector_aicontacts_seen, me.candidate);
+	                    		#print("Sensor: seen ",me.candidate.mdl,", planning reveal at ",int(me.dura-me.candidate.discover));
+	                    	}
+	                    }
+	    	        }
+	            }
+	        }
+	        if (!me.ok and me.containsVector(me.vector_aicontacts_seen, me.candidate)) {
+	        	#print("Sensor: unseen ",me.candidate.mdl);
+	        	me.temp = [];
+	        	foreach(me.seen;me.vector_aicontacts_seen) {
+	        		if (me.seen == me.candidate) continue;
+	        		append(me.temp,me.seen);
+	        	}
+	        	me.vector_aicontacts_seen = me.temp;
+	        }
+	    }
+        me.calcDura();
+        me.timing = 2/size(me.vector_aicontacts);# Expect there to be 1 to 100 contacts. The last ones in the vector should also be able to show up in the first seconds.
+        me.timing = math.clamp(me.timing, 0.01, 0.15);
+        #printf("dura %.3f  size %d  sleep %.3f",me.dura,size(me.vector_aicontacts),0.95*me.dura/size(me.vector_aicontacts));
+        me.timer.restart(me.timing);
+        if (!me.timer.isRunning) {
+        	me.timer.start();
+        }
+	},
+	containsVector: func (vec, item) {
+		foreach(test; vec) {
+			if (test == item) {
+				return 1;
+			}
+		}
+		return 0;
+	},
+	del: func {
+        emesary.GlobalTransmitter.DeRegister(me.RadSensorRecipient);
+    },
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#   ██████  ██████   ██████  ██    ██ ███    ██ ██████      ███    ███  █████  ██████  ██████  ███████ ██████
+#  ██       ██   ██ ██    ██ ██    ██ ████   ██ ██   ██     ████  ████ ██   ██ ██   ██ ██   ██ ██      ██   ██
+#  ██   ███ ██████  ██    ██ ██    ██ ██ ██  ██ ██   ██     ██ ████ ██ ███████ ██████  ██████  █████   ██████
+#  ██    ██ ██   ██ ██    ██ ██    ██ ██  ██ ██ ██   ██     ██  ██  ██ ██   ██ ██      ██      ██      ██   ██
+#   ██████  ██   ██  ██████   ██████  ██   ████ ██████      ██      ██ ██   ██ ██      ██      ███████ ██   ██
+#
+#
+var TerrainMapper = {
+	new: func (radar, rate) {
+		var tm = {parents: [TerrainMapper, Radar]};
+		tm.radar = radar;
+		tm.timer = maketimer(rate, tm, func tm.loop());
+		tm.timer.start();
+		radar.installMapper(tm);
+		tm.lowestElev = 0;
+		tm.highestElev = 5000;
+		tm.minElev = 35000;
+		tm.maxElev = 0;
+		tm.cleaned = 0;
+		tm.exp = 0;
+		tm.debug = 0;
+		tm.t_geo = 0;
+		tm.t_pix = 0;
+		return tm;
+	},
+	##################################################################################################
+	##################################################################################################
+	#
+	# TODO:
+	#   Remove image painting from this class
+	#   EXP mode
+	#   Optimize
+	#   Find reason for failing Coord._lat
+	#   Pixel rounding error review (fills too few x)
+	#
+	azData: {
+				radius: nil,
+				az: 0,
+				fromDist: nil,
+				toDist: nil,
+				domainNm: nil,
+				domainFwdNm: nil,
+				rangeFwdNm: nil,
+				returns: nil,
+			},
+	scanGM: func (eulerX, eulerY, verticalInstantFoV, horizontalInstantFoV, bottomBar, topBar) {
+		# GM test code
+
+		if (me.radar.currentMode.mapper and me.enabled and me.radar.horizonStabilized and me["gmPic"] != nil and !me.exp) {
+			if (me.debug > 3) {
+				me.t0 = systime();
+			}
+			me.debug = getprop("debug-radar/debug-mapper");
+			me.mapperHeading = eulerX+self.getHeading();
+			me.discDirforGMTop = vector.Math.pitchYawVector(eulerY+verticalInstantFoV,-me.mapperHeading,[1,0,0]);
+			me.discDirforGMBot = vector.Math.pitchYawVector(eulerY-verticalInstantFoV,-me.mapperHeading,[1,0,0]);
+			if (me.debug) {
+				setprop("debug-radar/mapper-pitch-high", eulerY+verticalInstantFoV);
+				setprop("debug-radar/mapper-pitch", eulerY);
+				setprop("debug-radar/mapper-pitch-low", eulerY-verticalInstantFoV);
+			}
+
+			me.selfCoord = self.getCoord();
+
+			me.radarBeamGeoVectorTop = vector.Math.vectorToGeoVector(me.discDirforGMTop, me.selfCoord);
+			me.radarBeamGeoVectorBot = vector.Math.vectorToGeoVector(me.discDirforGMBot, me.selfCoord);
+
+			me.xyzSelf = {"x":me.selfCoord.x(), "y":me.selfCoord.y(), "z":me.selfCoord.z()};
+
+            # Check for terrain at top and bottom of radar instant FoV
+            me.terrainGeodTop = get_cart_ground_intersection(me.xyzSelf, me.radarBeamGeoVectorTop);
+            me.terrainGeodBot = get_cart_ground_intersection(me.xyzSelf, me.radarBeamGeoVectorBot);
+            #if (me.debug) {
+			#	setprop("debug-radar/mapper-last-deg", math.abs(eulerX-me.azData.az));
+			#}
+            me.azData.az = eulerX;
+            me.azData.radius = horizontalInstantFoV;
+            me.azData.returns = [];
+            if (me.terrainGeodBot != nil) {
+            	me.terrainCoordBot = geo.Coord.new().set_latlon(me.terrainGeodBot.lat, me.terrainGeodBot.lon, me.terrainGeodBot.elevation);
+            	me.azData.fromDist = me.selfCoord.distance_to(me.terrainCoordBot)*M2NM;
+            	if (!me.testRange(me.azData.fromDist, me.radar.getRange(), me.azData.az)) return;
+            	if (me.terrainGeodTop != nil) {
+            		me.terrainCoordTop = geo.Coord.new().set_latlon(me.terrainGeodTop.lat, me.terrainGeodTop.lon, me.terrainGeodTop.elevation);
+            		if (me.debug) {
+						setprop("debug-radar/mapper-domain-lost-nm", "works");
+					}
+            	} else {
+            		# The upper part of this instantFoV does not hit terrain here. So we manually add a little bit.
+            		me.terrainCoordTop = geo.Coord.new(me.terrainCoordBot);
+            		if (me.azData.domainNm != nil) {
+            			me.topRange = me.azData.domainNm;
+            		} else {
+            			me.topRange = me.radar.getRange() * 1.25 - me.azData.fromDist;
+            		}
+            		me.topRange = math.max(me.topRange, 15);
+            		if (me.debug) {
+						setprop("debug-radar/mapper-domain-lost-nm", me.topRange);
+					}
+            		me.terrainCoordTop.apply_course_distance(me.mapperHeading, me.topRange*NM2M);
+            	}
+            	me.azData.toDist = me.selfCoord.distance_to(me.terrainCoordTop)*M2NM;
+            	me.azData.domainNm = me.azData.toDist-me.azData.fromDist;
+            	me.azCos = math.cos(me.azData.az*D2R);
+            	me.azData.rangeFwdNm = me.azData.fromDist*me.azCos;
+            	me.azData.domainFwdNm = me.azData.domainNm*me.azCos;
+            	me.pixelsBetweenTopAndBot = math.ceil(me.gmPicSize*me.azData.domainFwdNm/me.radar.getRange());
+				me.maskAlt  = 0;
+				me.maskStep = -1;
+
+				# Amount each step changes in altitude meters for center of beam.
+				# Curvature of earth is negliable.
+				# Each steps has different angle in reality, but its minute.
+				me.maskAltPerStep = math.tan(eulerY*D2R)*NM2M*me.azData.domainNm/me.pixelsBetweenTopAndBot;
+
+            	for (var i = 0; i <= me.pixelsBetweenTopAndBot; i += 1) {
+            		me.testCoord = me.interpolateCoords(me.terrainCoordBot, me.terrainCoordTop, i/me.pixelsBetweenTopAndBot);
+            		me.gm_geod = geodinfo(me.testCoord.lat(), me.testCoord.lon(), 10000);
+            		if (debug.isnan(me.testCoord._lat)) {
+            			#print("self ",me.selfCoord._lat);
+            			print("test ",me.testCoord._lat," , ",me.testCoord.lat()," , ",me.testCoord.alt());
+            			#print("bot  ",me.terrainCoordBot._x," , ",me.terrainCoordBot._y," , ",me.terrainCoordBot._z,"  ,  ",me.terrainGeodBot.elevation*M2FT);
+            			#print(i);
+            			append(me.azData.returns, 0);
+            			continue;
+            		}
+            		me.gmReturn = 0;
+            		if (me.gm_geod != nil) {
+            			if (me.gm_geod[0] > me.maskAlt+(i - me.maskStep)*me.maskAltPerStep) {
+            				# Terrain not masked by previous terrain
+            				me.maskAlt = me.gm_geod[0];
+            				me.maskStep = i;
+            				me.gmReturn = me.backScatter(me.gm_geod);
+            			} else {
+            				me.gmReturn = -1;
+            			}
+            		} else {
+            			me.gmReturn = -2;
+            		}
+            		append(me.azData.returns, me.gmReturn);
+            	}
+            	#me.debugOutput();
+            	if (me.debug > 3) {
+            		me.t1 = systime();
+            	}
+            	me.paintImage(me.azData, bottomBar, topBar);
+            	if (me.debug > 3) {
+	            	me.t2 = systime();
+	            	me.t_geo += me.t1-me.t0;
+	            	me.t_pix += me.t2-me.t1;
+	            }
+            }
+            if (me.dirty) {
+            	me.gmPic.dirtyPixels();
+            	me.dirty = 0;
+            }
+		}
+	},
+	setImage: func (image, origin_x, origin_y, dimension, monochrome, gainNode) {
+		if (me["gmPic"] == nil) {
+			#me.canvas = canvas.Window.new([512,512],"dialog").set('title',"GM").getCanvas(1);
+			#me.canvas_root = me.canvas.createGroup();
+			#me.canvas.setColorBackground(0,0,0,1);
+			me.gainNode = gainNode;
+			me.gmPic = image;
+            me.dirty = 0;
+            me.gmPicSize  = dimension;
+            me.mono = monochrome;
+            me.gm_x_origin = origin_x;
+            me.gm_y_origin = origin_y;
+            #me.gmPic.setPixel(me.gm_x_origin, me.gm_y_origin, [0,0,1,1]);#blue pixel at ownship
+            return 1;
+		} else {
+			return 0;
+		}
+	},
+	paintImage: func (azData, bottomBar, topBar) {
+
+		me.iStart = math.floor(me.gmPicSize*azData.rangeFwdNm/me.radar.getRange());
+
+		if (me.debug) {
+			setprop("debug-radar/mapper-steps", size(azData.returns));
+			setprop("debug-radar/mapper-domain-fwd-nm", azData.domainFwdNm);
+		}
+
+		# If top or bottom or only 1 bar, pad ahead/behind with nil. This will clear old returns on screen.
+		if (bottomBar and me.iStart > 0) {
+			azData.returns = setsize([], me.iStart) ~ azData.returns;
+			me.iStart = 0;
+		}
+		me.behindPad = (int)((1-me.azData.rangeFwdNm/me.radar.getRange())*me.gmPicSize*1.3);
+		if (topBar and me.behindPad > 0) {
+			azData.returns = azData.returns ~ setsize([], me.behindPad);
+		}
+
+		me.jStart = math.tan((azData.az-azData.radius)*D2R);
+		me.jMid   = math.tan(azData.az*D2R);
+		me.jEnd   = math.tan((azData.az+azData.radius)*D2R);
+		me.jFactor = me.jEnd-me.jStart;
+
+		#me.firstY = 0;
+		#me.firstX = 0;
+
+		for (var i = 0; i < size(azData.returns); i+=1 ) {
+			me.debugColor = nil;
+			if (me.debug > 2) {
+				if (azData.returns[i] == nil) {
+					me.debugColor = [0,0,1,1];# Blue for not hit by FoV
+				} elsif (azData.returns[i] == -1) {
+					me.debugColor = [1,1,0,1];# Yellow for terrain masked
+				} elsif (azData.returns[i] == -2) {
+					me.debugColor = [1,0,0,1];# Red for terrasunk
+				} else {
+					me.gmColor = math.pow(math.clamp(azData.returns[i],0,1), me.gainNode.getValue());
+				}
+			} else {
+				me.gmColor = azData.returns[i]==nil?0:math.pow(math.clamp(azData.returns[i],0,1), me.gainNode.getValue());
+			}
+
+			me.gmY  = me.gm_y_origin+me.iStart+i;
+			me.gmX  = math.floor(me.gm_x_origin+me.jMid*(i+me.iStart));
+			me.gmX0 = me.gm_x_origin+me.jStart*(i+me.iStart);
+			me.gmXj = math.round(me.gmX0+(i+me.iStart)*me.jFactor-0.5);
+			me.gmX0 = math.min(me.gmX, math.round(me.gmX0));
+			#if (me.firstY == 0) {
+			#	me.firstY = math.max(me.gmY, 0)-me.gm_y_origin;
+			#	me.firstX = me.gmXj;
+			#}
+			for (var j = me.gmX0; j <= me.gmXj; j += 1) {
+				if (j >= 0 and j <= me.gmPicSize-1 and me.gmY <= me.gmPicSize-1) {
+					me.gmPic.setPixel(j, math.max(me.gmY, 0), me.debugColor==nil?[me.gmColor*me.mono,me.gmColor,me.gmColor*me.mono,1]:me.debugColor);
+					me.dirty = 1;
+				}
+			}
+		}
+		#if (bottomBar and me.firstY != 0) {
+		#	# Clear the field below the bottom bar as we might have risen in alitude so its old data shown closer to ownship that can confuse pilot.
+		#	for (var y = me.firstY-1; y >= 0; y-=1 ) {
+		#		#var x = math.clamp(me.gm_x_origin + (y/me.firstY) * me.firstX, 0, 63);
+		#		if (me.firstX > 31)    {me.gmPic.setPixel(me.firstX,   y, [0,0,0,1]);me.gmPic.setPixel(me.firstX-1, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX-2, y, [0,0,0,1]);}
+		#		elsif (me.firstX < 31) {me.gmPic.setPixel(me.firstX+1, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX+2, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX+3, y, [0,0,0,1]);}
+		#		else                    me.gmPic.setPixel(me.firstX,   y, [0,0,0,1]);
+		#	}
+		#}
+	},
+	expChanged: func (exp) {
+		if (me["gmPic"] == nil or exp == me.exp) return;
+		me.exp = exp;
+		if (me.exp) {
+			me.gmPic.fillRect([0,0,me.gmPicSize,me.gmPicSize], [0.0*me.mono,0.0,0.0*me.mono,0]);# why does it allow 64??
+			me.gmPic.dirtyPixels();
+			me.dirty = 0;
+		} else {
+			me.cleanImage();
+		}
+	},
+	cleanImage: func {
+		if (me["gmPic"] == nil) return;
+		me.gmPic.fillRect([0,0,me.gmPicSize,me.gmPicSize], [0,0,0,0]);# why does it allow 64??
+		#me.gmPic.setPixel(me.gm_x_origin, me.gm_y_origin, [0,0,1,1]);#blue pixel at ownship
+		me.dirty = 1;
+	},
+	loop: func {
+		if (me.enabled and me.radar.currentMode.mapper and me["gmPic"] != nil and me.dirty) {
+			me.gmPic.dirtyPixels();
+		}
+		if (!me.radar.enabled and !me.cleaned) {
+			me.cleanImage();
+			me.cleaned = 1;
+		} else {
+			me.cleaned = 0;
+		}
+		if (me.debug > 3) {
+			printf("geo=%8.6f pix=%8.6f",me.t_geo, me.t_pix);
+			me.t_geo = 0;
+			me.t_pix = 0;
+		}
+	},
+	clear: func {
+		#me.lowestElev = 0;
+		#me.highestElev = 1000*math.ceil(getprop("position/ground-elev-ft")*0.001);
+		#me.minElev = 35000;
+		#me.maxElev = 0;
+		me.cleanImage();
+	},
+	testRange: func (range, maxRange, az) {
+		if (range > maxRange) {
+			return 0;
+		}
+		az = math.abs(az)*D2R;
+		if (math.sin(az)*range > maxRange*0.5) {
+			return 0;
+		}
+		return 1;
+	},
+	debugOutput: func {
+		if (me.radar.currentMode.bars == 4 and me.radar.currentMode["nextPatternNode"] != nil) {
+        	if (me.radar.currentMode.nextPatternNode == 0) {
+        		me.barCount = "4th";
+        	} elsif (me.radar.currentMode.nextPatternNode == 1) {
+        		me.barCount = "   ";return;
+        	} elsif (me.radar.currentMode.nextPatternNode == 2) {
+        		me.barCount = "1st";
+        	} elsif (me.radar.currentMode.nextPatternNode == 3) {
+        		me.barCount = "   ";return;
+        	} elsif (me.radar.currentMode.nextPatternNode == 4) {
+        		me.barCount = "2nd";
+        	} elsif (me.radar.currentMode.nextPatternNode == 5) {
+        		me.barCount = "   ";return;
+        	} elsif (me.radar.currentMode.nextPatternNode == 6) {
+        		me.barCount = "3rd";
+        	} elsif (me.radar.currentMode.nextPatternNode == 7) {
+        		me.barCount = "   ";return;
+        	} else {
+        		me.barCount = "Unk";return;
+        	}
+        	printf("AGL %5dft. Bar %s. Distance to bottom %.1fnm. Bottom to top %6.2fnm. Pitch %5.2f to %5.2f degs",getprop("position/altitude-agl-ft"), me.barCount, me.selfCoord.direct_distance_to(me.terrainCoordBot)*M2NM, me.terrainCoordBot.direct_distance_to(me.terrainCoordTop)*M2NM,me.eulerY-me.radar.instantFoVradius,me.radar.eulerY+me.radar.instantFoVradius);
+        }
+	},
+	backScatter: func (gm_geod) {
+		if (gm_geod == nil) {
+			me.reflection = 0;
+		} else {
+			if (gm_geod[1] == nil) {
+				me.reflection = 1;
+			} elsif (!gm_geod[1].solid) {
+				me.reflection = 0.05;
+				if (me.gm_geod[0] != nil) {
+					me.testElev = me.gm_geod[0]*M2FT;
+					if (me.testElev < me.minElev) {
+						me.minElev = me.testElev;
+					}
+				}
+			} else {
+				me.retur = me.howReflective(gm_geod[1]);
+				if (me.retur == 0) {
+					me.retur = gm_geod[1].bumpiness;
+				}
+				me.testElev = me.gm_geod[0]*M2FT;
+				if (me.testElev < me.minElev) {
+					me.minElev = me.testElev;
+				}
+				if (me.testElev > me.maxElev) {
+					me.maxElev = me.testElev;
+				}
+				me.reflection = math.min(1, me.extrapolate(me.testElev, me.lowestElev, me.highestElev, 0.15, 0.6)+me.retur*0.4);
+			}
+		}
+		return me.reflection;
+	},
+	frameDone: func {
+		if (me.minElev != 35000 or me.maxElev != 0) {
+			me.highestElev = (me.highestElev*1.5+me.maxElev)/2.5;# a simple lowpass filter to prevent it from changing too abrupt.
+			me.lowestElev = (me.lowestElev*1.5+math.max(0, math.min(me.maxElev-1000, me.minElev)))/2.5;# prevent somewhat flat terrain to show as very undulated.
+		}
+		if (me.debug) setprop("debug-radar/mapper-elevation-min", me.lowestElev);
+		if (me.debug) setprop("debug-radar/mapper-elevation-max", me.highestElev);
+
+		me.minElev = 35000;
+		me.maxElev = 0;
+	},
+	howReflective: func(info) {
+		# from AJS-37
+	    foreach (var name; info.names) {
+	        if (contains(me.urban_names, name)) return 1;
+	    }
+	    foreach (var name; info.names) {
+	        if (contains(me.natural_names, name)) return me.natural_names[name];
+	    }
+    	return 0;
+    },
+    urban_names: {
+		# from AJS-37
+	    "Urban": 1,
+	    "BuiltUpCover": 1,
+	    "Construction": 1,
+	    "Industrial": 1,
+	    "Port": 1,
+	    "Town": 1,
+	    "SubUrban": 1,
+	},
+	natural_names: {
+		# TODO: find more real data on this. Best source so far: AP3456 – 11-x - Radar
+	    "Cliffs": 0.8,  # tend to be steep, hence greater return
+	    "Asphalt": 0.7, # very granular hence good backscatter
+	    "Airport": 0.5, #
+	    "Rock": 0.6,    # tend to be somewhat steep, hence some solid backscatter
+	    "RainForest": 0.35,
+	    "MixedForest": 0.35,# wood does very little backscatter, but trees are upright, so good opportunity for specular return
+	    "AgroForest": 0.25,
+	    "SnowCover": 0.2,   # snow is very diffuse, hence very little backscatter
+	    "PolarIce": 0.4,
+	    "PackIce": 0.25,    # very smooth like the water it formed on, hence little return
+	    "Glacier": 0.5,
+	},
+	interpolateCoords: func (start, end, fraction) {
+		if (fraction == 0) {
+			return geo.Coord.new(start);
+		}
+		if (fraction == 1) return geo.Coord.new(end);
+		me.xx = (start.x()*(1-fraction)+end.x()*fraction);
+		me.yy = (start.y()*(1-fraction)+end.y()*fraction);
+		me.zz = (start.z()*(1-fraction)+end.z()*fraction);
+
+		me.cc = geo.Coord.new();
+		me.cc.set_xyz(me.xx,me.yy,me.zz);
+
+		return me.cc;
+	},
+	extrapolate: func (x, x1, x2, y1, y2) {
+    	return y1 + ((x - x1) / (x2 - x1)) * (y2 - y1);
+	},
+	##################################################################################################
+	##################################################################################################
+	##################################################################################################
+	##################################################################################################
+};
+
+
+
+
+
+
+
+
+
+
+#  ████████  ██████  ██████      ██████   ██████  ██ ███    ██ ████████
+#     ██    ██       ██   ██     ██   ██ ██    ██ ██ ████   ██    ██
+#     ██    ██   ███ ██████      ██████  ██    ██ ██ ██ ██  ██    ██
+#     ██    ██    ██ ██          ██      ██    ██ ██ ██  ██ ██    ██
+#     ██     ██████  ██          ██       ██████  ██ ██   ████    ██
+#
+#
+var ContactTGP = {
+	new: func(callsign, coord, laser = 1) {
+		var obj             = { parents : [ContactTGP, Contact]};# in real OO class this should inherit from Contact, but in nasal it does not need to
+		obj.coord           = geo.Coord.new(coord);
+		#obj.coord.set_alt(coord.alt()+1);#avoid z fighting
+		obj.callsign        = callsign;
+		obj.unique          = rand();
+
+		obj.tacobj = {parents: [tacview.tacobj]};
+		obj.tacobj.tacviewID = right((obj.unique~""),5);
+		obj.tacobj.valid = 1;
+
+		obj.laser = laser;
+		return obj;
+	},
+
+	isValid: func () {
+		return 1;
+	},
+
+	isVirtual: func () {
+		return 1;
+	},
+
+	getVirtualType: func {
+		# Used to debug issue #532
+		return "tgp-ground";
+	},
+
+	isPainted: func () {
+		return 0;
+	},
+
+	isLaserPainted: func{
+		return getprop("controls/armament/laser-arm-dmd") and me.laser;
+	},
+
+	isRadiating: func (c) {
+		return 0;
+	},
+
+	getUnique: func () {
+		return me.unique;
+	},
+
+	getElevation: func() {
+		#var e = 0;
+		var selfPos = geo.aircraft_position();
+		#var angleInv = ja37.clamp(self.distance_to(me.coord)/self.direct_distance_to(me.coord), -1, 1);
+		#e = (self.alt()>me.coord.alt()?-1:1)*math.acos(angleInv)*R2D;
+		return vector.Math.getPitch(selfPos, me.coord);
+	},
+
+	getFlareNode: func () {
+		return nil;
+	},
+
+	getChaffNode: func () {
+		return nil;
+	},
+
+	get_Coord: func() {
+		return me.coord;
+	},
+
+	getCoord: func {
+		return me.get_Coord();
+	},
+
+	getETA: func {
+		return nil;
+	},
+
+	getHitChance: func {
+		return nil;
+	},
+
+	get_Callsign: func(){
+		return me.callsign;
+	},
+
+	getModel: func(){
+		return "TGP spot";
+	},
+
+	get_Speed: func(){
+		# return true airspeed
+		return 0;
+	},
+
+	get_uBody: func {
+		return 0;
+	},
+	get_vBody: func {
+		return 0;
+	},
+	get_wBody: func {
+		return 0;
+	},
+
+	get_Longitude: func(){
+		var n = me.coord.lon();
+		return n;
+	},
+
+	get_Latitude: func(){
+		var n = me.coord.lat();
+		return n;
+	},
+
+	get_Pitch: func(){
+		return 0;
+	},
+
+	get_Roll: func(){
+		return 0;
+	},
+
+	get_heading : func(){
+		return 0;
+	},
+
+	get_bearing: func(){
+		var n = me.get_bearing_from_Coord(geo.aircraft_position());
+		return n;
+	},
+
+	get_relative_bearing : func() {
+		return geo.normdeg180(me.get_bearing()-getprop("orientation/heading-deg"));
+	},
+
+	getLastAZDeviation : func() {
+		return me.get_relative_bearing();
+	},
+
+	get_altitude: func(){
+		#Return Alt in feet
+		return me.coord.alt()*M2FT;
+	},
+
+	get_Longitude: func {
+		return me.coord.lon()*M2FT;
+	},
+	get_Latitude: func {
+		return me.coord.lat();
+	},
+
+	get_range: func() {
+		var r = me.coord.direct_distance_to(geo.aircraft_position()) * M2NM;
+		return r;
+	},
+
+	get_type: func () {
+		return armament.POINT;
+	},
+
+	get_bearing_from_Coord: func(MyAircraftCoord){
+		var myBearing = 0;
+		if(me.coord.is_defined()) {
+			myBearing = MyAircraftCoord.course_to(me.coord);
+		}
+		return myBearing;
+	},
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+var scanInterval = 0.05;# 20hz for main radar
+
+
+laserOn = props.globals.getNode("controls/armament/laser-arm-dmd",1);#don't put 'var' keyword in front of this.
+var datalink_power = props.globals.getNode("instrumentation/datalink/power",0);
+enable_tacobject = 1;
+var antennae_knob_prop = props.globals.getNode("controls/radar/antennae-knob",0);
+var wndprop = props.globals.getNode("environment/wind-speed-kt",0);
+
+
+# start generic radar system
+var baser = AIToNasal.new();
+var partitioner = NoseRadar.new();
+var omni = OmniRadar.new(1.0, 150, -1);
+var terrain = TerrainChecker.new(0.05, 1, 30);# 0.05 or 0.10 is fine here
+var callsignToContact = CallsignToContact.new();
+var dlnkRadar = DatalinkRadar.new(0.03, 110, 225);# 3 seconds because cannot be too slow for DLINK targets
+var ecm = ECMChecker.new(0.05, 6);
+
+# start specific radar system
+var rwsMode = F16RWSMode.new(F16RWSSAMMode.new(F16MultiSTTMode.new()));
+var twsMode = F16TWSMode.new(F16MultiSTTMode.new());
+var lrsMode = F16LRSMode.new(F16LRSSAMMode.new(F16MultiSTTMode.new()));
+var vsMode = F16VSMode.new(F16STTMode.new());
+var acm20Mode = F16ACM20Mode.new(F16ACMSTTMode.new());
+var acm60Mode = F16ACM60Mode.new(F16ACMSTTMode.new());
+var acmBoreMode = F16ACMBoreMode.new(F16ACMSTTMode.new());
+var seaMode = F16SeaMode.new(F16SEAFTTMode.new());
+var gmMode = F16GMMode.new(F16GMFTTMode.new());
+var gmtMode = F16GMTMode.new(F16GMTFTTMode.new());
+var apg68Radar = AirborneRadar.newAirborne([[rwsMode,twsMode,lrsMode,vsMode],[acm20Mode,acm60Mode,acmBoreMode],[seaMode],[gmMode],[gmtMode]], APG68);
+var f16_rwr = RWR.new();
+var f16_radSensor = RadSensor.new();
+var acmLockSound = props.globals.getNode("f16/sound/acm-lock");
+var mapper = TerrainMapper.new(apg68Radar, 0.50);
+
+
+
+
+var getCompleteList = func {
+	return baser.vector_aicontacts_last;
+}
+
+
+
+
+
+# BUGS:
+#   HSD radar arc CW vs. CCW
+#
+# TODO:
+#   VS switch speed at each bar instead of each frame
+#
diff --git a/Nasal/Radar/radar-system.nas b/Nasal/Radar/radar-system.nas
index 69d91c8..e304976 100644
--- a/Nasal/Radar/radar-system.nas
+++ b/Nasal/Radar/radar-system.nas
@@ -111,12 +111,12 @@ var RequestFullNotification = {
 };
 
 
-#  ███    ███  ██████  ██████  ███████ ██          ██████   █████  ██████  ███████ ███████ ██████ 
-#  ████  ████ ██    ██ ██   ██ ██      ██          ██   ██ ██   ██ ██   ██ ██      ██      ██   ██ 
-#  ██ ████ ██ ██    ██ ██   ██ █████   ██          ██████  ███████ ██████  ███████ █████   ██████  
-#  ██  ██  ██ ██    ██ ██   ██ ██      ██          ██      ██   ██ ██   ██      ██ ██      ██   ██ 
-#  ██      ██  ██████  ██████  ███████ ███████     ██      ██   ██ ██   ██ ███████ ███████ ██   ██ 
-#                                                                                                  
+#  ███    ███  ██████  ██████  ███████ ██          ██████   █████  ██████  ███████ ███████ ██████ 
+#  ████  ████ ██    ██ ██   ██ ██      ██          ██   ██ ██   ██ ██   ██ ██      ██      ██   ██ 
+#  ██ ████ ██ ██    ██ ██   ██ █████   ██          ██████  ███████ ██████  ███████ █████   ██████  
+#  ██  ██  ██ ██    ██ ██   ██ ██      ██          ██      ██   ██ ██   ██      ██ ██      ██   ██ 
+#  ██      ██  ██████  ██████  ███████ ███████     ██      ██   ██ ██   ██ ███████ ███████ ██   ██ 
+#                                                                                                  
 #
 var AIToNasal = {
 	# convert AI property tree to Nasal vector
@@ -453,12 +453,12 @@ var CallsignToContact = {
 };
 
 
-#   ██████  ██     ██ ███    ██ ███████ ██   ██ ██ ██████ 
-#  ██    ██ ██     ██ ████   ██ ██      ██   ██ ██ ██   ██ 
-#  ██    ██ ██  █  ██ ██ ██  ██ ███████ ███████ ██ ██████  
-#  ██    ██ ██ ███ ██ ██  ██ ██      ██ ██   ██ ██ ██     
-#   ██████   ███ ███  ██   ████ ███████ ██   ██ ██ ██ 
-#                                                     
+#   ██████  ██     ██ ███    ██ ███████ ██   ██ ██ ██████ 
+#  ██    ██ ██     ██ ████   ██ ██      ██   ██ ██ ██   ██ 
+#  ██    ██ ██  █  ██ ██ ██  ██ ███████ ███████ ██ ██████  
+#  ██    ██ ██ ███ ██ ██  ██ ██      ██ ██   ██ ██ ██     
+#   ██████   ███ ███  ██   ████ ███████ ██   ██ ██ ██ 
+#                                                     
 #
 var SelfContact = {
 	#
@@ -727,12 +727,12 @@ var Blep = {
 };
 
 
-#   ██████  ██████  ███    ██ ████████  █████   ██████ ████████ 
-#  ██      ██    ██ ████   ██    ██    ██   ██ ██         ██    
-#  ██      ██    ██ ██ ██  ██    ██    ███████ ██         ██ 
-#  ██      ██    ██ ██  ██ ██    ██    ██   ██ ██         ██ 
-#   ██████  ██████  ██   ████    ██    ██   ██  ██████    ██ 
-#                                                            
+#   ██████  ██████  ███    ██ ████████  █████   ██████ ████████ 
+#  ██      ██    ██ ████   ██    ██    ██   ██ ██         ██    
+#  ██      ██    ██ ██ ██  ██    ██    ███████ ██         ██ 
+#  ██      ██    ██ ██  ██ ██    ██    ██   ██ ██         ██ 
+#   ██████  ██████  ██   ████    ██    ██   ██  ██████    ██ 
+#                                                            
 #
 var AIContact = {
 # Attributes:
@@ -853,7 +853,7 @@ var AIContact = {
 	    #
         if (prop_name == "carrier") {
         	return MARINE;
-        } elsif (prop_name == "aircraft" or prop_name == "Mig-28") {
+        } elsif (prop_name == "aircraft" or prop_name == "swift" or prop_name == "Mig-28") {
         	return AIR;
         } elsif (ordnance != nil) {
         	return ORDNANCE;
@@ -1370,12 +1370,12 @@ var AIContact = {
 	},
 
 
-#  ██     ██ ███████  █████  ██████   ██████  ███    ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████ 
-#  ██     ██ ██      ██   ██ ██   ██ ██    ██ ████   ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██      
-#  ██  █  ██ █████   ███████ ██████  ██    ██ ██ ██  ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████ 
-#  ██ ███ ██ ██      ██   ██ ██      ██    ██ ██  ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██ 
-#   ███ ███  ███████ ██   ██ ██       ██████  ██   ████     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████ 
-#                                                                                                                        
+#  ██     ██ ███████  █████  ██████   ██████  ███    ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████ 
+#  ██     ██ ██      ██   ██ ██   ██ ██    ██ ████   ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██      
+#  ██  █  ██ █████   ███████ ██████  ██    ██ ██ ██  ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████ 
+#  ██ ███ ██ ██      ██   ██ ██      ██    ██ ██  ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██ 
+#   ███ ███  ███████ ██   ██ ██       ██████  ██   ████     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████ 
+#                                                                                                                        
 #
 
 	get_type: func {
@@ -1540,12 +1540,12 @@ var Radar = {
 };
 
 
-#  ██████   █████  ██████  ████████ ██ ████████ ██  ██████  ███    ██ 
-#  ██   ██ ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ████   ██ 
-#  ██████  ███████ ██████     ██    ██    ██    ██ ██    ██ ██ ██  ██ 
-#  ██      ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ██  ██ ██ 
-#  ██      ██   ██ ██   ██    ██    ██    ██    ██  ██████  ██   ████ 
-#                                                                     
+#  ██████   █████  ██████  ████████ ██ ████████ ██  ██████  ███    ██ 
+#  ██   ██ ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ████   ██ 
+#  ██████  ███████ ██████     ██    ██    ██    ██ ██    ██ ██ ██  ██ 
+#  ██      ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ██  ██ ██ 
+#  ██      ██   ██ ██   ██    ██    ██    ██    ██  ██████  ██   ████ 
+#                                                                     
 #
 var NoseRadar = {
 	# I partition the sky into the field of regard and preserve the contacts in that field for it to be scanned by ActiveDiscRadar or similar
@@ -2011,12 +2011,12 @@ var FullRadar = {
 
 
 
-#   ██████  ███    ███ ███    ██ ██ 
-#  ██    ██ ████  ████ ████   ██ ██ 
-#  ██    ██ ██ ████ ██ ██ ██  ██ ██ 
-#  ██    ██ ██  ██  ██ ██  ██ ██ ██ 
-#   ██████  ██      ██ ██   ████ ██ 
-#                                   
+#   ██████  ███    ███ ███    ██ ██ 
+#  ██    ██ ████  ████ ████   ██ ██ 
+#  ██    ██ ██ ████ ██ ██ ██  ██ ██ 
+#  ██    ██ ██  ██  ██ ██  ██ ██ ██ 
+#   ██████  ██      ██ ██   ████ ██ 
+#                                   
 #
 var OmniRadar = {
 	# I check the sky 360 deg for anything potentially detectable by a passive radar system.
@@ -2057,6 +2057,9 @@ var OmniRadar = {
 				# This is not expensive as terrain manager set this in a loop.
 				continue;
 			}
+			if (contact.getType() == ORDNANCE) {
+				continue;
+			}
 			me.rangeDirectNM = contact.getRangeDirect()*M2NM;
 			if (me.rangeDirectNM > me.max_dist_nm) {
 				continue;
@@ -2104,12 +2107,12 @@ var OmniRadar = {
 
 
 
-#  ████████ ███████ ██████  ██████   █████  ██ ███    ██ 
-#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ████   ██ 
-#     ██    █████   ██████  ██████  ███████ ██ ██ ██  ██ 
-#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ██  ██ ██ 
-#     ██    ███████ ██   ██ ██   ██ ██   ██ ██ ██   ████ 
-#                                                        
+#  ████████ ███████ ██████  ██████   █████  ██ ███    ██ 
+#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ████   ██ 
+#     ██    █████   ██████  ██████  ███████ ██ ██ ██  ██ 
+#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ██  ██ ██ 
+#     ██    ███████ ██   ██ ██   ██ ██   ██ ██ ██   ████ 
+#                                                        
 #
 var TerrainChecker = {
 	#
@@ -2349,12 +2352,12 @@ var ECMChecker = {
 
 
 
-#  ███████ ██ ██   ██ ███████ ██████      ██████  ███████  █████  ███    ███ 
-#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ████  ████ 
-#  █████   ██   ███   █████   ██   ██     ██████  █████   ███████ ██ ████ ██ 
-#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ██  ██  ██ 
-#  ██      ██ ██   ██ ███████ ██████      ██████  ███████ ██   ██ ██      ██ 
-#                                                                            
+#  ███████ ██ ██   ██ ███████ ██████      ██████  ███████  █████  ███    ███ 
+#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ████  ████ 
+#  █████   ██   ███   █████   ██   ██     ██████  █████   ███████ ██ ████ ██ 
+#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ██  ██  ██ 
+#  ██      ██ ██   ██ ███████ ██████      ██████  ███████ ██   ██ ██      ██ 
+#                                                                            
 #
 var FixedBeamRadar = {
 
@@ -2401,12 +2404,12 @@ var FixedBeamRadar = {
 
 
 
-#   ██████  ██    ██ ███████ ██████  ██ ██████  ███████ ███████ 
-#  ██    ██ ██    ██ ██      ██   ██ ██ ██   ██ ██      ██      
-#  ██    ██ ██    ██ █████   ██████  ██ ██   ██ █████   ███████ 
-#  ██    ██  ██  ██  ██      ██   ██ ██ ██   ██ ██           ██ 
-#   ██████    ████   ███████ ██   ██ ██ ██████  ███████ ███████ 
-#                                                               
+#   ██████  ██    ██ ███████ ██████  ██ ██████  ███████ ███████ 
+#  ██    ██ ██    ██ ██      ██   ██ ██ ██   ██ ██      ██      
+#  ██    ██ ██    ██ █████   ██████  ██ ██   ██ █████   ███████ 
+#  ██    ██  ██  ██  ██      ██   ██ ██ ██   ██ ██           ██ 
+#   ██████    ████   ███████ ██   ██ ██ ██████  ███████ ███████ 
+#                                                               
 #
 var flareProp = "rotors/main/blade[3]/flap-deg";
 var chaffProp = "rotors/main/blade[3]/position-deg";
@@ -2424,7 +2427,7 @@ var isOmniRadiating = func (model) {
 
 var getRadarFieldRadius = func (model) {
 	# Override this method in your aircraft to do this in another way
-	if (model == "A-50" or model == "EC-137R" or model == "E-3") {
+	if (model == "A-50" or model == "EC-137R" or model == "E-3R" or model == "E-3") {
 		return 180;
 	}
 	if (model == "S-75" or model == "s-200") {
@@ -2442,6 +2445,9 @@ var getRadarFieldRadius = func (model) {
 	if (model == "fleet" or model == "missile-frigate") {
 		return 180;
 	}
+	if (knownSurface[model] == 0) {
+		return 0;
+	}
 	return 60;
 }
 
@@ -2481,6 +2487,7 @@ var knownCarriers = {
 var knownAwacs = {
 	"A-50": nil,
 	"EC-137R": nil,
+	"E-3R": nil,
 	"E-3": nil,
 };
 
@@ -2495,17 +2502,18 @@ var knownShips = {
 };
 
 var knownSurface = {
+	# 0 = has no radar
     "S-75":       nil,
     "buk-m2":       nil,
     "SA-6":       nil,
     "s-300":       nil,
     "s-200":       nil,
-    "depot":       nil,
-    "struct":       nil,
-    "point":       nil,
-    "rig":       nil,
+    "depot":       0,
+    "struct":       0,
+    "point":       0,
+    "rig":       0,
     "gci":       nil,
-    "truck":     nil,
+    "truck":     0,
     "tower":     nil,
     "MIM104D":       nil,
     "ZSU-23-4M":       nil,
diff --git a/Nasal/b1b.nas b/Nasal/b1b.nas
index d7fdfc3..f5837f2 100644
--- a/Nasal/b1b.nas
+++ b/Nasal/b1b.nas
@@ -908,3 +908,20 @@ var nuc = func {
   screen.log.write(ltext);
   }
 }
+
+var vector_aicontacts_links = [];
+var DLRecipient = emesary.Recipient.new("DLRecipient");
+var startDLListener = func {
+    DLRecipient.radar = radar_system.dlnkRadar;
+    DLRecipient.Receive = func(notification) {
+        if (notification.NotificationType == "DatalinkNotification") {
+            #printf("DL recv: %s", notification.NotificationType);
+            if (me.radar.enabled == 1) {
+                vector_aicontacts_links = notification.vector;
+            }
+            return emesary.Transmitter.ReceiptStatus_OK;
+        }
+        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+    };
+    emesary.GlobalTransmitter.Register(DLRecipient);
+}
diff --git a/Nasal/data.nas b/Nasal/data.nas
index ffbeade..26ac88d 100644
--- a/Nasal/data.nas
+++ b/Nasal/data.nas
@@ -1,11 +1,11 @@
 var serialize = func() {
-    # TGT,bay,rack,lat,lon
+    # TGT,bay,rack,lat,lon,alt
     syncData();
 	var ret = "";
 	var iter = 0;
 	for ( var bay = 0; bay < 3; bay = bay + 1 ) {
         for ( var rack = 0; rack < 8; rack = rack + 1 ) {
-            ret = ret~sprintf("TGT,%d,%d,%s,%s|", bay, rack, getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-latitude-deg"), getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-longitude-deg"));
+            ret = ret~sprintf("TGT,%d,%d,%s,%s,%s|", bay, rack, getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-latitude-deg"), getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-longitude-deg"), getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-altitude"));
         }
     }
     return ret;
@@ -21,6 +21,12 @@ var unserialize = func(m) {
             var rack = items[2];
             setprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-latitude-deg", items[3]);
             setprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-longitude-deg", items[4]);
+            if (size(items) > 5) {
+                # Altitude supported
+                setprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-altitude", items[5]);
+            } else {
+                setprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-altitude", 0);
+            }
         }
     }
     syncData();
@@ -64,6 +70,7 @@ var loadSTPTs = func (path) {
 }
 
 var syncData = func {
+    return;
     for ( var bay = 0; bay < 3; bay = bay + 1 ) {
         for ( var rack = 0; rack < 8; rack = rack + 1 ) {
             weapons.wpn_info[bay][rack].lat = getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-latitude-deg");
@@ -78,4 +85,62 @@ var syncData = func {
     }
 }
 
+var select = func (bay, rack) {
+    var t_lat = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-latitude-deg", bay, rack));
+    var t_lon = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-longitude-deg", bay, rack));
+    # t_alt = geo.elevation(t_lat, t_lon);
+    var t_alt = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-altitude", bay, rack));
+    if (t_lat < 90 and t_lat > -90 and t_lon < 180 and t_lon > -180 and pylons.fcs != nil) {
+        pylons.fcs.selectPylon(bay, rack);
+        var wp = pylons.fcs.getSelectedWeapon();
+        if (wp != nil and wp.parents[0] == armament.AIM and wp.target_pnt == 1 and (wp.guidance=="gps" or wp.guidance=="gps-altitude")) {
+            var coord = geo.Coord.new();
+            coord.set_latlon(t_lat,t_lon,t_alt);
+            var spot = radar_system.ContactTGP.new("GPS-Spot",coord,0);
+            armament.contactPoint = spot;
+            if (getprop("f16/stores/tgp-mounted") and 0) {
+                tgp.flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
+                callsign = armament.contactPoint.getUnique();
+                setprop("/aircraft/flir/target/auto-track", 1);
+                flir_updater.offsetP = 0;
+                flir_updater.offsetH = 0;
+                setprop("f16/avionics/tgp-lock", 1);
+            }
+            wp.setContacts([spot]);
+            # Temporarily
+            # TODO: Figure out why this is needed
+            wp.start();
+        }
+    }
+}
+
 setprop("sim/fg-home-export", getprop("sim/fg-home")~"/Export");
+
+
+var status_update_func = func {
+    for ( var bay = 0; bay < 3; bay = bay + 1 ) {
+        for ( var rack = 0; rack < 8; rack = rack + 1 ) {
+            var wpn = pylons.fcs._getSpecificWeapon(bay,rack);
+            var txt = "";
+            if (wpn == nil) {
+                txt = "Not loaded";
+            } else if (!wpn.isPowerOn()) {
+                txt = "Off";
+            } else if (wpn.status == armament.MISSILE_STANDBY) {
+                txt = "Standby";
+            } else if (wpn.status == armament.MISSILE_STARTING) {
+                txt = "Starting";
+            } else if (wpn.status == armament.MISSILE_SEARCH) {
+                txt = "Ready";
+            } else if (wpn.status == armament.MISSILE_LOCK) {
+                txt = "Locked";
+            } else if (wpn.status == armament.MISSILE_FLYING) {
+                txt = "Deployed";
+            } else {
+                txt = "Error";
+            }
+            setprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/status-text", txt);
+        }
+    }
+}
+var status_update = maketimer(0.25, status_update_func);
\ No newline at end of file
diff --git a/Nasal/datalink.nas b/Nasal/datalink.nas
index e8ca836..7b88482 100644
--- a/Nasal/datalink.nas
+++ b/Nasal/datalink.nas
@@ -21,6 +21,15 @@
 # * Optional
 #   /instrumentation/datalink/receive_period = 1        receiving loop update rate
 #
+# Optional: Re-define the function
+#   datalink.can_transmit(callsign, mp_prop, mp_index)
+#
+# This function should return 'true' when the given aircraft is able to transmit over datalink to us.
+# For instance, it can be used to check line of sight and maximum range.
+# The default implementation always returns true (always able to transmit).
+# Arguments are callsign, property node /ai/models/multiplayer[i], index of the former node.
+#
+#
 # API:
 # - get_data(callsign)
 #     Returns all datalink information about 'callsign' as an object, or nil if there is none.
@@ -35,9 +44,15 @@
 # - get_connected_callsigns() / get_connected_indices()
 #     Returns a vector containing all callsigns, resp. indices
 #     in /ai/models/multiplayer[i], of aircrafts connected on datalink.
-#     Both vectors use the same indices, i.e. get_connected_callsigns()[i]
+#     Both vectors use the same order, i.e. get_connected_callsigns()[i]
 #     and get_connected_indices()[i] correspond to the same aircraft.
-# 
+#     Furthermore this order is stable (the relative order of two aircrafts
+#     does not change as long as neither disconnects from multiplayer).
+#
+# - get_all_callsigns()
+#     Returns a vector containing all callsigns of aircraft with any associated data.
+#     There is no guarantee on the order of callsigns.
+#
 # - send_data(data, timeout=nil)
 #     Send data on the datalink. 'data' is a hash of the form
 #       {
@@ -75,6 +90,11 @@
 #       tracked_by():       The callsign of the transmitting aircraft ("A"), or nil if tracked() is false.
 #       tracked_by_index(): The index of the transmitting aircraft, or nil if tracked() is false.
 #                           The index refers to property nodes /ai/models/multiplayer[i].
+#       is_known():         Equivalent to (on_link() or tracked()).
+#                           Indicates if the position of this aircraft is supposed to be known
+#                           (i.e. whether or not it should be displayed on a HSD or whatever).
+#       is_friendly():      Equivalent to (on_link() or iff() == IFF_FRIENDLY).
+#       is_hostile():       Equivalent to (!on_link() and iff() == IFF_HOSTILE).
 #
 ## Sending data
 # usage: send_data({ contacts: <contacts>, ...}, ...)
@@ -93,7 +113,7 @@
 #
 ## Sending data
 # Set the identifier with send_data({"identifier": <identifier>, ...});
-# The identifier must be a string.
+# The identifier must be a string. It must not contain '!'.
 
 ### Coordinate transmission (extension name: "point")
 #
@@ -110,7 +130,7 @@
 #### Protocol:
 #
 # Data is transmitted on MP generic string[7], with the following format:
-#   <channel>(|<data>)+
+#   <channel>(!<data>)+
 #
 # <channel> is a hash of the datalink channel. See hash_channel() and check_channel_hash().
 # Each <data> block corresponds to data sent by an extension.
@@ -120,8 +140,9 @@
 # Remark: '!' as separator is specifically chosen to allow encoding with emesary.Transfer<type>.
 #
 # The current extension prefixes are the following:
-#   contacts: C
+#   contacts:   C
 #   identifier: I
+#   point:      P
 
 #### Extensions API
 #
@@ -135,7 +156,7 @@
 #
 # encode(data)              extension encoding function.
 #   Must return the encoding of the extension data (i.e. <data> when calling
-#   send_data({name: <data>})) into a string, which may use any character except '|'.
+#   send_data({name: <data>})) into a string, which may use any character except '!'.
 #   The extension prefix must not be part of the encoded string.
 #
 # decode(aircrafts_data, callsign, index, string)      extension decoding function.
@@ -158,6 +179,27 @@
 #     unless an entry for 'callsign' already exists. Returns the modified hash.
 
 
+
+#### Version and changelog
+# current: v1.1.0, minimum compatible: v1.0.0
+#
+## v1.1.0:
+# Allow external transmission restrictions
+# Make transmitting contact IFF optional
+# Ensure personal identifier has no '!'
+# '\n' is redundant for printf()
+# Fix separator character in documentation
+# Fix error when sending unknown extension
+#
+## v1.0.1:
+# Add is_known(), is_friendly(), is_hostile() helpers to extension "contacts".
+#
+## v1.0.0: Initial version
+# - Core protocol for datalink channel.
+# - Extensions "contacts", "identifier", and "point".
+
+
+
 ### Parameters
 #
 # Remark: most parameters need to be the same on all aircrafts.
@@ -171,6 +213,11 @@ var channel_hash_period = 600;
 
 var receive_period = getprop("/instrumentation/datalink/receive_period") or 1;
 
+# Should be overwitten to add transmission restrictions.
+var can_transmit = func(contact, mp_prop, mp_index) {
+    return 1;
+}
+
 ### Properties
 
 var input = {
@@ -197,8 +244,7 @@ foreach (var name; keys(input)) {
 # Channel is hashed with current time (rounded to 10min) and own callsign.
 
 var clean_callsign = func(callsign) {
-    if (size(callsign) > 7) return left(callsign, 7);
-    else return callsign;
+    return damage.processCallsign(callsign);
 }
 
 var my_callsign = func {
@@ -283,11 +329,11 @@ var contact_parents = [Contact];
 
 var register_extension = func(name, prefix, class, encode, decode) {
     if (contains(extensions, name)) {
-        printf("Datalink: double registration of extension '%s'. Skipping.\n", name);
+        printf("Datalink: double registration of extension '%s'. Skipping.", name);
         return -1;
     }
     if (contains(extension_prefixes, prefix)) {
-        printf("Datalink: double registration of extension prefix '%s'. Skipping.\n", name);
+        printf("Datalink: double registration of extension prefix '%s'. Skipping.", name);
         return -1;
     }
     extensions[name] = { prefix: prefix, encode: encode, decode: decode, };
@@ -330,7 +376,8 @@ var send_data = func(data, timeout=nil) {
     foreach(var ext; keys(data)) {
         # Skip missing extensions with a warning
         if (!contains(extensions, ext)) {
-            printf("Warning: unknown datalink extension %s in send_data().\n", ext);
+            printf("Warning: unknown datalink extension %s in send_data().", ext);
+            continue;
         }
         str = str ~ data_separator ~ extensions[ext].prefix ~ extensions[ext].encode(data[ext]);
     }
@@ -380,6 +427,10 @@ var get_connected_indices = func {
     return connected_indices;
 }
 
+var get_all_callsigns = func {
+    return keys(aircrafts_data);
+}
+
 # Helper for modifying aircrafts_data.
 var add_if_missing = func(aircrafts_data, callsign) {
     if (!contains(aircrafts_data, callsign)) {
@@ -413,6 +464,10 @@ var receive_loop = func {
         # Check channel
         if (!check_channel(tokens[0], callsign, my_channel)) continue;
 
+        # We check this _after_ the channel. Checking the channel is quite cheap,
+        # and we don't know how slow this function is, it might have a get_cart_ground_intersection()
+        if (!can_transmit(callsign, mp, idx)) continue;
+
         # Add to list of connected aircrafts.
         append(connected_callsigns, callsign);
         append(connected_indices, idx);
@@ -482,7 +537,14 @@ var ContactIdentifier = {
 
 var encode_identifier = func(ident) {
     # Force string conversion
-    return ""~ident;
+    ident = ""~ident;
+
+    if (find("!", ident) >= 0) {
+        printf("Datalink: Identifier is not allowed to contain '!': %s.", ident);
+        return "";
+    } else {
+        return ident;
+    }
 }
 
 var decode_identifier = func(aircrafts_data, callsign, str) {
@@ -528,6 +590,15 @@ var ContactTracked = {
     iff: func {
         return me._iff;
     },
+    is_known: func {
+        return me.on_link() or me.tracked();
+    },
+    is_friendly: func {
+        return me.on_link() or me.iff() == IFF_FRIENDLY;
+    },
+    is_hostile: func {
+        return !me.on_link() and me.iff() == IFF_HOSTILE;
+    },
 };
 
 # Contact encoding: callsign + bits
@@ -539,7 +610,7 @@ var ContactTracked = {
 
 var encode_contact = func(contact) {
     # Encode bitfield
-    var bits = contact.iff != nil ? contact.iff : IFF_UNKNOWN;
+    var bits = contact["iff"] != nil ? contact.iff : IFF_UNKNOWN;
 
     return emesary.TransferString.encode(clean_callsign(contact.callsign))
         ~ emesary.TransferByte.encode(bits);
@@ -607,4 +678,4 @@ var decode_point = func(aircrafts_data, callsign, str) {
     return aircrafts_data;
 }
 
-register_extension("point", "P", ContactPoint, encode_point, decode_point);
+register_extension("point", "P", ContactPoint, encode_point, decode_point);
\ No newline at end of file
diff --git a/Nasal/fire-control.nas b/Nasal/fire-control.nas
index f426aab..bb08984 100644
--- a/Nasal/fire-control.nas
+++ b/Nasal/fire-control.nas
@@ -38,9 +38,18 @@ var FireControl = {
 		#setlistener("controls/armament/master-arm",func{fc.updateCurrent()},nil,0);
 		setlistener(masterArmSwitch,func{fc.masterArmSwitch()},nil,0);
 		setlistener("controls/armament/dual",func{fc.updateDual()},nil,0);
+		setlistener("sim/signals/reinit",func{fc.updateMass()},nil,0);
 		return fc;
 	},
 
+	updateMass: func {
+		# JSBSim seems to reset all properties under fdm/jsbsim/inertia at reinit, so we need to repopulate them.
+		foreach (var p;me.pylons) {
+			p.calculateMass();
+			p.calculateFDM();
+		}
+	},
+
 	cage: func (cageIt) {
 		foreach (var p;me.pylons) {
 			var ws = p.getWeapons();
@@ -139,21 +148,21 @@ var FireControl = {
 		}
 		if (x != 0) me.setXfov(x==-1?1:0);
 	},
-	
+
 	getDropMode: func {
 		#0=ccrp, 1 = ccip
 		me.dropMode;
 	},
-	
+
 	setDropMode: func (mode) {
 		#0=ccrp, 1 = ccip
 		me.dropMode = mode;
 	},
-	
+
 	getRippleMode: func {
 		me.ripple;
 	},
-	
+
 	setRippleMode: func (ripple) {
 		if (ripple >= 1) {
 			me.ripple = int(ripple);
@@ -167,11 +176,11 @@ var FireControl = {
 			me.rippleInterval = type;
 		}
 	},
-	
+
 	getRippleDist: func {
 		me.rippleDist;
 	},
-	
+
 	setRippleDist: func (rippleDist) {
 		if (rippleDist >= 0) {
 			me.rippleDist = rippleDist;
@@ -181,17 +190,30 @@ var FireControl = {
 	getRippleDelay: func {
 		me.rippleDelay;
 	},
-	
+
 	setRippleDelay: func (rippleDelay) {
 		if (rippleDelay >= 0) {
 			me.rippleDelay = rippleDelay;
 		}
 	},
-	
+
 	getSelectedType: func {
 		return me.selectedType;
 	},
 
+	togglePowerOn: func () {
+		me.myType = me.getSelectedType();
+		if (me.myType == nil) return;
+		me.myWeaps = me.getAllOfType(me.myType);
+		me.currPow = 0;
+		if (me.myWeaps != nil and size(me.myWeaps) and me.myWeaps[0].parents[0] == armament.AIM) {
+			me.currPow = me.myWeaps[0].isPowerOn();
+			foreach (me.myWeap ; me.myWeaps) {
+				me.myWeap.setPowerOn(!me.currPow);
+			}
+		}
+	},
+
 	getCategory: func {
 		# get loadout CAT (not to be confused with FBW CAT setting)
 		me.cat = 1;
@@ -265,7 +287,7 @@ var FireControl = {
 			me.selType = me.selectedType;
 			printfDebug(" Now selecting %s",me.selType);
 			me.wp = me.nextWeapon(me.selType);
-			if (me.wp != nil) {			
+			if (me.wp != nil) {
 				printfDebug("FC: Selected next weapon type: %s on pylon %d position %d",me.selectedType,me.selected[0],me.selected[1]);
 			} else {
 				printfDebug("FC: Selected next weapon type: %s, but none is loaded.", me.selectedType);
@@ -297,13 +319,13 @@ var FireControl = {
 			me.selType = me.selectedType;
 			printfDebug(" Now selecting %s",me.selType);
 			me.wp = me.nextWeapon(me.selType);
-			if (me.wp != nil) {			
+			if (me.wp != nil) {
 				printfDebug("FC: Selected next weapon type: %s on pylon %d position %d",me.selectedType,me.selected[0],me.selected[1]);
 				screen.log.write("Selected "~me.selectedType, 0.5, 0.5, 1);
 				return;
 			}
 			me.selTypeIndex += 1;
-		}		
+		}
 		me.selected = nil;
 		me.selectedAdd = nil;
 		me.selectedType = nil;
@@ -368,7 +390,7 @@ var FireControl = {
 				if (!me.hasSeen) {
 					if (me.typeTest == me.selectedType) {
 						me.hasSeen = 1;
-					} 
+					}
 					continue;
 				}
 				me.class = getprop("payload/armament/"~string.lc(me.typeTest)~"/class");
@@ -427,10 +449,10 @@ var FireControl = {
 		if (me.selectedType != nil) {
 			me.stopCurrent();
 		}
-		
+
 		me.selectedType = defaultCannon;
 		me.nextWeapon(me.selectedType);
-		
+
 		me.selectedAdd = nil;
 		me.updateDual();
 	},
@@ -473,7 +495,7 @@ var FireControl = {
 				if (!me.hasSeen) {
 					if (me.typeTest == me.selectedType) {
 						me.hasSeen = 1;
-					} 
+					}
 					continue;
 				}
 				me.class = getprop("payload/armament/"~string.lc(me.typeTest)~"/class");
@@ -530,10 +552,10 @@ var FireControl = {
 		if (me.selectedType != nil) {
 			me.stopCurrent();
 		}
-		
+
 		me.selectedType = defaultCannon;
 		me.nextWeapon(me.selectedType);
-		
+
 		me.selectedAdd = nil;
 		if (me.changeListener != nil) me.changeListener();
 	},
@@ -569,7 +591,7 @@ var FireControl = {
 		}
 		return me.getSelectedPylon().getAmmo() > 0;
 	},
-	
+
 	_getSpecificWeapon: func (p, w) {
 		# return specific weapon or nil
 		if (w < 0 or w > size(me.pylons[p].getWeapons())-1) {
@@ -577,7 +599,7 @@ var FireControl = {
 		}
 		return me.pylons[p].getWeapons()[w];
 	},
-	
+
 	getSelectedWeapons: func {
 		# return selected weapons or nil
 		if (me.selected == nil) {
@@ -602,7 +624,7 @@ var FireControl = {
 		}
 		return me.sw;
 	},
-	
+
 	getSelectedDualWeapons: func {
 		# return selected dual weapons or nil
 		if (me.selected == nil) {
@@ -693,7 +715,7 @@ var FireControl = {
 		}
 		if (me.changeListener != nil) me.changeListener();
 	},
-	
+
 	jettisonSpecificPylons: func (list, also_heat) {
 		# jettison commanded pylons
 		foreach (pyl;me.pylons) {
@@ -710,11 +732,11 @@ var FireControl = {
 					continue;
 				}
 				pyl.jettisonAll();
-			}			
+			}
 		}
 		if (me.changeListener != nil) me.changeListener();
 	},
-	
+
 	jettisonAllButHeat: func (exclude = nil) {
 		# jettison all but heat seekers.
 		foreach (pyl;me.pylons) {
@@ -754,21 +776,21 @@ var FireControl = {
 		}
 		return me.selected[0];
 	},
-	
+
 	selectWeapon: func (w) {
 		me.stopCurrent();
 		me.selectedType = w;
 		var nw = me.nextWeapon(w);
 		return nw;
 	},
-	
+
 	selectNothing: func {
 		me.stopCurrent();
 		me.selectedType = nil;
 		me.selected = nil;
 		if (me.changeListener != nil) me.changeListener();
 	},
-	
+
 	selectPylon: func (p, w=nil) {
 		# select a specified pylon
 		# will stop previous weapon, will start next.
@@ -823,7 +845,7 @@ var FireControl = {
 					}
 				}
 				me.nextWeapon(me.selectedType);
-				
+
 				# start ripple if set
 				me.idx = me.vectorIndex(dualWeapons,me.selectedType);
 				if (me.idx != -1) {
@@ -838,7 +860,7 @@ var FireControl = {
 						setprop("payload/armament/gravity-dropping", 0);
 					}
 				}
-				
+
 				me.triggerTime = 0;
 			} elsif (me.aim != nil and me.aim.parents[0] == armament.AIM and me.aim.loal) {
 				me.triggerTime = getprop("sim/time/elapsed-sec");
@@ -847,7 +869,7 @@ var FireControl = {
 				if (getprop("sim/time/elapsed-sec")>me.gunTriggerTime+10 or me.aim.alternate) {
 					# only say guns guns every 10 seconds.
 					#armament.AIM.sendMessage(me.aim.brevity);
-					
+
 					me.gunTriggerTime = getprop("sim/time/elapsed-sec");
 				}
 				damage.damageLog.push(me.aim.type~" fired");
@@ -865,7 +887,7 @@ var FireControl = {
 			}
 		}
 	},
-	
+
 	fireAIM: func (p,w,g) {
 		# fire a weapon (that is a missile-code instance)
 		me.aim = me._getSpecificWeapon(p,w);
@@ -883,7 +905,7 @@ var FireControl = {
 		if (me.changeListener != nil) me.changeListener();
 		return me.aim;
 	},
-	
+
 	rippleFireStart: func {
 		# First has been fired, now start system to fire the ripple ones.
 		if (me.getSelectedWeapon() != nil) {
@@ -893,7 +915,7 @@ var FireControl = {
 			me.rippleTest();
 		}
 	},
-	
+
 	rippleTest: func {
 		# test for distance if we should fire ripple bombs. And do so if distance is great enough.
 		me.rippleCount += 1;
@@ -980,10 +1002,10 @@ var FireControl = {
 			return;
 		}
 		printDebug("FC: Masterarm "~getprop("controls/armament/master-arm-switch"));
-		
+
 		me.pylons[me.selected[0]].calculateMass();#kind of a hack to get cannon ammo changed.
 	},
-	
+
 	updateDual: func (type = nil) {
 		# will stop all current weapons, and select single and pair weapons and start em all.
 		me.duality = getprop("controls/armament/dual");
@@ -1005,7 +1027,7 @@ var FireControl = {
 			return;
 		}
 	},
-	
+
 	selectDualWeapons: func (type, duality) {
 		# will select additional weapon of same type if dual is supported for the type and dual is greater than 'single'
 		# will NOT start them
@@ -1147,7 +1169,7 @@ var FireControl = {
 		}
 		return me.count;
 	},
-	
+
 	getAllAmmo: func (type = nil) {
         # return ammo count of all pylons in a vector
         me.ammoVector = [];
@@ -1156,7 +1178,7 @@ var FireControl = {
         }
         return me.ammoVector;
     },
-	
+
 	getActiveAmmo: func {
 		# return ammo count of currently selected type that are on active pylons
 		me.count = 0;
@@ -1217,11 +1239,11 @@ var FireControl = {
 			}
 		}
 	},
-	
+
 	getAllOfType: func (typ) {
 		# return vector with all weapons of certain type
 		me.typVec = [];
-		
+
 		foreach(pyl;me.pylons) {
 			foreach(me.pylweap ; pyl.getWeapons()) {
 				if (me.pylweap != nil and me.pylweap.type == typ) {
@@ -1231,6 +1253,30 @@ var FireControl = {
 		}
 		return me.typVec;
 	},
+
+	getStationIndecesForSelectedType: func (typeOnly = nil) {
+		# return vector with all weapons of certain type
+		if (typeOnly == nil) typeOnly = me.selectedType;
+		me.same = typeOnly == me.selectedType;
+		me.indices = [];
+		for (var i = 0; i < size(me.pylons);i +=1) {
+			me.pylo = me.pylons[i];
+			me.value = -1;
+			if (me.selected != nil and i == me.selected[0] and me.same) {
+				me.value = 1;
+			} elsif (typeOnly != nil and me.same) {
+				foreach(me.pylweap ; me.pylo.getWeapons()) {
+					if (me.pylweap != nil and me.pylweap.type == typeOnly) {
+						me.value = 0;
+						break;
+					}
+				}
+			}
+			append(me.indices, me.value);
+		}
+
+		return me.indices;
+	},
 };
 
 var debug = 0;
diff --git a/Nasal/missile-code.nas b/Nasal/missile-code.nas
index 2cad43f..c30bf48 100644
--- a/Nasal/missile-code.nas
+++ b/Nasal/missile-code.nas
@@ -134,7 +134,7 @@ var PATTERN_ROSETTE = 1;
 var PATTERN_DOUBLE_D = 2;
 
 # set these to print stuff to console:
-var DEBUG_STATS            = 0;#most basic stuff
+var DEBUG_STATS            = 1;#most basic stuff
 var DEBUG_FLIGHT           = 0;#for creating missiles sometimes good to have this on to see how it flies.
 
 # set these to debug the code:
diff --git a/Nasal/steerpoints.nas b/Nasal/steerpoints.nas
new file mode 100644
index 0000000..50a8626
--- /dev/null
+++ b/Nasal/steerpoints.nas
@@ -0,0 +1,1071 @@
+ #
+# F-16 Steerpoint/route/mark/bulls-eye system.
+#
+var lines = [nil,nil, nil, nil];
+
+var desired_tos = {};
+
+var number_of_threat_circles  = 15;
+var number_of_generic         = 10;
+var number_of_markpoints_own  = 5;
+var number_of_markpoints_dlnk = 5;
+
+var index_of_threat_circles   = 300;
+var index_of_generic          = 350;
+var index_of_markpoints_own   = 400;
+var index_of_markpoints_dlnk  = 450;
+var index_of_weapon_gps       = 500;
+var index_of_bullseye         = 555;
+var index_of_lines_1          = 100;
+var index_of_lines_2          = 200;
+var index_of_lines_3          = 600;
+var index_of_lines_4          = 700;
+
+var stpt300 = setsize([],number_of_threat_circles);#Threat circles
+var stpt350 = setsize([],10);#Generic
+var stpt400 = setsize([],5);#Markpoints Own
+var stpt450 = setsize([],5);#Markpoints DL
+var stpt500 = setsize([],1);#Weapon
+var stpt555 = setsize([],1);#Bullseye
+var current = nil;#Current STPT number, nil for route/nothing.
+
+var colorRed = 0;
+var colorYellow = 1;
+var colorGreen = 2;
+
+var autoMode = 1;# if change this then also change f16/ded/stpt-auto
+
+var STPT = {
+	# stored in the above vectors for non-route steerpoints
+	lon: 0,
+	lat: 0,
+	alt: 0,
+	type: "   ",
+	radius: 10,
+	color: colorYellow,
+
+	new: func {
+		var n = {parents: [STPT]};
+		return n;
+	},
+
+	copy: func {
+		var cp = STPT.new();
+		cp.lat = me.lat;
+		cp.lon = me.lon;
+		cp.alt = me.alt;
+		cp.type = me.type;
+		cp.radius = me.radius;
+		cp.color = me.color;
+		return cp;
+	},
+};
+
+
+
+var getCurrentNumber = func {
+	# Get current steerpoint. The first is #1. Return 0 for no current steerpoint.
+	if (current != nil) {
+		return current;
+	} elsif (isRouteActive()) {
+		var fp = flightplan();
+		return fp.current + 1;
+	}
+	return 0;
+}
+
+var getLastNumber = func {
+	# Get the steerpoint # for the final steerpoint in current route or for non-route get the current.
+	if (current != nil) {
+		return current;
+	} elsif (isRouteActive()) {
+		var fp = flightplan();
+		return fp.getPlanSize();
+	}
+	return 0;
+}
+
+var getNumber = func (number) {
+	# Return a specific steerpoint, nil if none
+	if (!_isOccupiedNumber(number)) {
+		return nil;
+	}
+	if (number >= 700 and lines[3] != nil) {
+		var fp = lines[3];
+		var leg = fp.getWP(number-700);
+		var new = STPT.new();
+		new.lat = leg.lat;
+		new.lon = leg.lon;
+		if (leg.alt_cstr != nil) {
+			new.alt = leg.alt_cstr;
+		}
+		return new;
+	}
+	if (number >= 600 and lines[2] != nil) {
+		var fp = lines[2];
+		var leg = fp.getWP(number-600);
+		var new = STPT.new();
+		new.lat = leg.lat;
+		new.lon = leg.lon;
+		if (leg.alt_cstr != nil) {
+			new.alt = leg.alt_cstr;
+		}
+		return new;
+	}
+	if (number == 555) {
+		return stpt555[0];
+	}
+	if (number == 500) {
+		return stpt500[0];
+	}
+	if (number >= 450) {
+		return stpt450[number-450];
+	}
+	if (number >= 400) {
+		return stpt400[number-400];
+	}
+	if (number >= 350) {
+		return stpt350[number-350];
+	}
+	if (number >= 300) {
+		return stpt300[number-300];
+	}
+	if (number >= 200 and lines[1] != nil) {
+		var fp = lines[1];
+		var leg = fp.getWP(number-200);
+		var new = STPT.new();
+		new.lat = leg.lat;
+		new.lon = leg.lon;
+		if (leg.alt_cstr != nil) {
+			new.alt = leg.alt_cstr;
+		}
+		return new;
+	}
+	if (number >= 100 and lines[0] != nil) {
+		var fp = lines[0];
+		var leg = fp.getWP(number-100);
+		var new = STPT.new();
+		new.lat = leg.lat;
+		new.lon = leg.lon;
+		if (leg.alt_cstr != nil) {
+			new.alt = leg.alt_cstr;
+		}
+		return new;
+	}
+	if (number < 100 and isRouteActive()) {
+		var fp = flightplan();
+		var leg = fp.getWP(number-1);
+		var new = STPT.new();
+		new.lat = leg.lat;
+		new.lon = leg.lon;
+		if (leg.alt_cstr != nil) {
+			new.alt = leg.alt_cstr;
+		}
+		return new;
+	}
+	return nil;
+}
+
+var setNumber = func (number, stpt) {
+	# Store a non-route steerpoint in memory
+	if (!_isValidNumber(number)) {
+		return 0;
+	}
+	if (number == 555) {
+		stpt555[0] = stpt;
+		return 1;
+	}
+	if (number == 500) {
+		stpt500[0] = stpt;
+		return 1;
+	}
+	if (number >= 450) {
+		stpt450[number-450] = stpt;
+		return 1;
+	}
+	if (number >= 400) {
+		stpt400[number-400] = stpt;
+		return 1;
+	}
+	if (number >= 350) {
+		stpt350[number-350] = stpt;
+		return 1;
+	}
+	if (number >= 300) {
+		stpt300[number-300] = stpt;
+		return 1;
+	}
+	if (number < 300) {
+		return 0;
+	}
+	return 0;
+}
+
+var getCurrentDirection = func {
+	# Get directions to current steerpoint or [nil,nil] for none.
+	if (getCurrentNumber() != 0) {
+		var cc = getCurrentCoord();
+		return [geo.aircraft_position().course_to(cc), vector.Math.getPitch(geo.aircraft_position(), cc)];
+	} else {
+		return [nil, nil];
+	}
+}
+
+var getCurrentDirectionForHUD = func {
+	# Get directions to current steerpoint or [nil,nil] for none.
+	if (getCurrentNumber() != 0) {
+		var cc = getCurrentCoordForHUD();
+		return [geo.aircraft_position().course_to(cc), vector.Math.getPitch(geo.aircraft_position(), cc)];
+	} else {
+		return [nil, nil];
+	}
+}
+
+var getCurrentRange = func {
+	# Return range in nm to current steerpoint.
+	if (getCurrentNumber() == 0) return nil;
+	var s = getCurrentCoord();
+	return s.distance_to(geo.aircraft_position())*M2NM;
+}
+
+var getCurrentGroundPitch = func {
+	#if (getCurrentNumber() != 0) {
+		var gCoord = getCurrentGroundCoord();
+		if (gCoord != nil) {
+			return vector.Math.getPitch(geo.aircraft_position(), gCoord);
+		}
+	#}
+	return nil;
+}
+
+var getCurrentSlantRange = func {
+	# Return slant range in nm to current steerpoint.
+	if (getCurrentNumber() == 0) return nil;
+	var s = getCurrentCoord();
+	return s.direct_distance_to(geo.aircraft_position())*M2NM;
+}
+
+var getCurrentETA = func {
+	# Return seconds till current steerpoint.
+	if (getCurrentNumber() == 0) return nil;
+	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
+	if (gs == 0) return nil;
+	if (current == nil) {
+		return getprop("autopilot/route-manager/wp/eta-seconds");
+	}
+	var range = getCurrentRange()*NM2M;
+	return range/gs;
+}
+
+var getCurrentCoord = func {
+	# returns current steerpoint as geo.Coord
+	var s = getNumber(getCurrentNumber());
+	if (s == nil) return nil;
+	return stpt2coord(s);
+}
+
+var getCurrentCoordForHUD = func {
+	# returns current steerpoint as geo.Coord
+	var s = getNumber(getCurrentNumber());
+	return stpt2coordGrounded(s);
+}
+
+var getCurrentGroundCoord = func {
+	# returns current steerpoint as geo.Coord
+	var s = getNumber(getCurrentNumber());
+	if (s == nil) return nil;
+	var elev = geo.elevation(s.lat, s.lon);
+	if (elev == nil) {
+		if (s.alt != nil) {
+			elev = s.alt * FT2M;
+		} else {
+			return nil;
+		}
+	}
+	var p = geo.Coord.new();
+    p.set_latlon(s.lat, s.lon, elev);
+
+	return p;
+}
+
+var setCurrentNumber = func (number) {
+	# Set current steerpoint number.
+	if (number < 100 and isRouteActive() and number > 0) {
+		var fp = flightplan();
+		if (fp.getPlanSize() >= number) {
+			fp.current = number - 1;
+			current = nil;
+			print("Switching active steerpoint to #"~number);
+			return 1;
+		}
+	} elsif (_isOccupiedNumber(number)) {
+		current = number;
+		print("Switching active steerpoint to #"~number);
+		return 1;
+	}
+	return 0;
+}
+
+var getCurrent = func {
+	# return current steerpoint or nil
+	return getNumber(getCurrentNumber());
+}
+
+var getLastRange = func {
+	# Get nm range to final steerpoint in current route or to current steerpoint for non-route.
+	if (getCurrentNumber() == 0) return nil;
+	if (current == nil) {
+		var fp = flightplan();
+		var dist_nm = steerpoints.getCurrentRange();
+		var stnum = getCurrentNumber();
+		for (var index = stnum; index < fp.getPlanSize(); index+=1) {
+			dist_nm += fp.getWP(index).leg_distance;
+		}
+		return dist_nm;
+	} else {
+		return steerpoints.getCurrentRange();
+	}
+}
+
+var getNumberRange = func (number) {
+	# Get range to specific steerpoint
+	if (getCurrentNumber() == 0) return nil;
+	if (current == nil and number >= getCurrentNumber()) {
+		var dist_nm = steerpoints.getCurrentRange();
+		var stnum = getCurrentNumber();
+		for (var index = stnum; index < number-1; index+=1) {
+			dist_nm += flightplan().getWP(index).leg_distance;
+		}
+		return dist_nm;
+	} elsif (number == getCurrentNumber()) {
+		return steerpoints.getCurrentRange();
+	}
+	return nil;
+}
+
+var getLast = func {
+	# Return final steerpoint
+	if (getCurrentNumber() == 0) return nil;
+	return getNumber(getLastNumber());
+}
+
+var getRequiredSpeed = func (number) {
+    # Get required groundspeed in kts for TOS on specific steerpoint
+    if (getCurrentNumber() == 0) return nil;
+    var range = getNumberRange(number)*NM2M;
+    var des_tos = _getNumberDesiredTOS(number);
+    #var des_tos = getprop("f16/ded/crus-des-tos");
+    if (des_tos == nil) {
+       des_tos = 0;
+    }
+    # Subtract current time from TOS to get relative time
+    #if (des_tos > addSeconds(0, getprop("sim/time/utc/hour"),getprop("sim/time/utc/minute"),getprop("sim/time/utc/second"))) {
+        # Desired TOS is in the past, this shouldn't really matter, since we have a min of 70kts
+    #}
+    var cur_sec = (((getprop("sim/time/utc/hour")*60)+getprop("sim/time/utc/minute"))*60)+getprop("sim/time/utc/second")+math.fmod(getprop("sim/time/steady-clock-sec"), 1);
+    #var tos_sec = addSeconds(des_tos, -getprop("sim/time/utc/hour"),-getprop("sim/time/utc/minute"),-getprop("sim/time/utc/second"));
+    #tos_sec = (((tos_sec[1]*60)+tos_sec[2])*60)+tos_sec[3];
+
+    # MLU M1: if STPT not reached in time, airspeed caret remains at max
+    if (cur_sec > des_tos) {
+        return 1700;
+    }
+    var tos_sec = des_tos - cur_sec;
+    var req_spd = range / tos_sec / KT2MPS;
+    # As per MLU M1, the speed is limited between 70kts and 1700kts
+    return math.max(math.min(req_spd, 1700), 70);
+}
+
+var getLastETA = func {
+	# Get time in seconds till final steerpoint
+	if (getCurrentNumber() == 0) return nil;
+	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
+	if (gs == 0) return nil;
+	var range = getLastRange()*NM2M;
+	return range/gs;
+}
+
+var getNumberETA = func (number) {
+	# Get time in seconds till specific steerpoint
+	if (getCurrentNumber() == 0) return nil;
+	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
+	if (gs == 0) return nil;
+	var range = getNumberRange(number)*NM2M;
+	return range/gs;
+}
+
+var setNumberDesiredTOS = func (number, tos) {
+    if (tos == -1) {
+        tos = nil;
+    }
+    desired_tos[number] = tos;
+    return;
+}
+
+var _getNumberDesiredTOS = func (number) {
+    if (getCurrentNumber() == 0) return nil;
+    return desired_tos[number];
+}
+
+var serializeTOS = func (number) {
+    var result = _getNumberDesiredTOS(number);
+    if (result == nil) {
+        result = -1;
+    }
+    return result;
+}
+
+var getNumberDesiredTOS = func (number) {
+    # Get string with desired time over steerpoint for specific steerpoint
+    var val = _getNumberDesiredTOS(number);
+	return _getTOS(val);
+}
+
+var getNumberTOS = func (number) {
+	# Get string with time on station for specific steerpoint
+	if (getCurrentNumber() == 0) return nil;
+	var eta = getNumberETA(number);
+	return _getTOS(eta);
+}
+
+var _getCurrentDesiredTOS = func {
+    return _getNumberDesiredTOS(getCurrentNumber());
+}
+
+var getCurrentDesiredTOS = func {
+	# Get string with desired time over steerpoint for current steerpoint
+	return getNumberDesiredTOS(getCurrentNumber());
+}
+
+var setCurrentDesiredTOS = func (tos) {
+	# Get string with desired time over steerpoint for current steerpoint
+	return setNumberDesiredTOS(getCurrentNumber(), tos);
+}
+
+var getCurrentRequiredSpeed = func {
+    return getRequiredSpeed(getCurrentNumber());
+}
+
+var getAbsoluteTOS = func (eta) {
+    return _getTOS(eta, 1);
+}
+
+var getCurrentTOS = func {
+	# Get string with time on station for current steerpoint
+	var eta = getCurrentETA();
+	return _getTOS(eta);
+}
+
+var getLastTOS = func {
+	# Get string with time on station for final steerpoint
+	var eta = getLastETA();
+	return _getTOS(eta);
+}
+
+var formatTime = func(time, absolute = 1) {
+    var result = "--:--:--";
+    if (time == nil or time>3600*24 or time < 0) {
+		return result;
+	} else {
+	    if (!absolute) {
+            var hour   = getprop("sim/time/utc/hour");
+            var minute = getprop("sim/time/utc/minute");
+            var second = getprop("sim/time/utc/second");
+        } else {
+            var hour   = 0;
+            var minute = 0;
+            var second = 0;
+        }
+        var final = addSeconds(time,second,minute,hour);
+
+		result = sprintf("%02d:%02d:%02d",final[1],final[2],final[3]);
+	}
+	return result;
+}
+
+var _getTOS = func (eta, absolute = 0) {
+	# Get string with time on station for a specific time in seconds
+	# eta is allowed to be nil
+	# if absolute the eta is assumed to be an exact time, otherwise eta is assumed to be relative to current time
+	var TOS = "--:--:--";
+	if (getCurrentNumber() == 0) return TOS;
+
+	return formatTime(eta, !absolute);
+}
+
+var addSeconds = func (add_secs, secs, mins, hours) {
+	# Add some seconds to 24 hr clock
+
+	# the baseline:
+	var d = 0;
+	var h = hours;
+	var m = mins;
+	var s = secs;
+
+	# the added:
+	var H = int(add_secs/3600);
+    var S = add_secs-H*3600;
+    var M = int(S/60);
+    S = S-M*60;
+
+    s += S;
+    var addOver = 0;
+	while (s > 59) {
+		addOver += 1;
+		s -= 60;
+	}
+
+	m += M+addOver;
+	addOver = 0;
+	while (m > 59) {
+		addOver += 1;
+		m -= 60;
+	}
+
+	h += H+addOver;
+	while (h > 23) {
+		addOver += 1;
+		h -= 24;
+	}
+
+	d = addOver;
+
+    return [d,h,m,s];
+}
+
+var next = func {
+	# Advance steerpoint
+	if (current != nil) return;
+	var active = isRouteActive();
+    var wp = getprop("autopilot/route-manager/current-wp");
+    var max = getprop("autopilot/route-manager/route/num");
+
+    if (active) {
+		wp += 1;
+		if (wp>max-1) {
+			wp = 0;
+		}
+		setprop("autopilot/route-manager/current-wp", wp);
+	}
+}
+
+var prev = func {
+	# Decrease steerpoint
+	if (current != nil) return;
+	var active = isRouteActive();
+    var wp = getprop("autopilot/route-manager/current-wp");
+    var max = getprop("autopilot/route-manager/route/num");
+
+    if (active) {
+		wp -= 1;
+		if (wp<0) {
+			wp = max-1;
+		}
+		setprop("autopilot/route-manager/current-wp", wp);
+    }
+}
+
+var copy = func (from, to) {
+	# Copy steerpoint. Cannot copy TO route or lines steerpoints.
+	var fStpt = getNumber(from);
+	if (fStpt != nil and _isValidNumber(to)) {
+		var tStpt = fStpt.copy();
+		setNumber(to, tStpt);
+		print("Copying steerpoint #"~from~" to #"~to);
+	} else {
+		print("STPT copy unsuccesful.");
+	}
+}
+
+var sendCurrent = func {
+	# Send current steerpoint over DLNK
+	return send(getCurrentNumber());
+}
+
+var stpt2coord = func (stpt) {
+	# Convert steerpoint to geo.Coord
+	var p = geo.Coord.new();
+    p.set_latlon(stpt.lat, stpt.lon, stpt.alt*FT2M);
+    return p;
+}
+
+var stpt2coordGrounded = func (stpt) {
+	# Convert steerpoint to geo.Coord but not lower than ground
+	var p = geo.Coord.new();
+	var elev = stpt.alt*FT2M;
+	if (elev <= 0) {
+		elev = geo.elevation(stpt.lat, stpt.lon);
+		if (elev == nil) {
+			elev = 0;
+		}
+	}
+    p.set_latlon(stpt.lat, stpt.lon, elev);
+    return p;
+}
+
+var send = func (number) {
+	# Send specific steerpoint over DLNK
+	var s = getNumber(number);
+	if (s != nil and sending == nil) {
+		var p = stpt2coord(s);
+	    sending = p;
+	    datalink.send_data({"point": sending});
+	    settimer(func {sending = nil;},7);
+	    print("Sending steerpoint to #"~number~" to DLNK.");
+	    return 1;
+	}
+	return 0;
+}
+
+var markOFLY = func {
+	# Create an OLFY markpoint
+	var mark = STPT.new();
+	mark.lat = getprop("/position/latitude-deg");
+	mark.lon = getprop("/position/longitude-deg");
+	mark.alt = getprop("/position/altitude-ft");
+	mark.type = "OFLY";
+	addOwnMark(mark);
+}
+
+var markTGP = func (coord) {
+	# Create a TGP markpoint
+	var mark = STPT.new();
+	mark.lat = coord.lat();
+	mark.lon = coord.lon();
+	mark.alt = coord.alt()*M2FT;
+	mark.type = "TGP";
+	return addOwnMark(mark);
+}
+
+var markHUD = func (coord) {
+	# Create a HUD markpoint
+	var mark = STPT.new();
+	mark.lat = coord.lat();
+	mark.lon = coord.lon();
+	mark.alt = coord.alt()*M2FT;
+	mark.type = "HUD";
+	return addOwnMark(mark);
+}
+
+var ownMarkIndex = 4;
+
+var addOwnMark = func (mark) {
+	# Store a mark
+	ownMarkIndex += 1;
+	if (ownMarkIndex > 4) ownMarkIndex = 0;
+	stpt400[ownMarkIndex] = mark;
+	return ownMarkIndex+400;
+}
+
+var dlMarkIndex = 4;
+
+var addDLMark = func (mark) {
+	# STore a DLNK mark
+	dlMarkIndex += 1;
+	if (dlMarkIndex > 4) dlMarkIndex = 0;
+	stpt450[dlMarkIndex] = mark;
+	return dlMarkIndex+450;
+}
+
+var applyToWPN = func {
+	# Apply WPN steerpoint to current weapon
+	var lat = getprop("f16/avionics/gps-lat");
+	var lon = getprop("f16/avionics/gps-lon");
+	var alt = getprop("f16/avionics/gps-alt")*FT2M;
+	if (lat < 90 and lat > -90 and lon < 180 and lon > -180 and pylons.fcs != nil) {
+		var wp = pylons.fcs.getSelectedWeapon();
+		if (wp != nil and wp.parents[0] == armament.AIM and wp.target_pnt == 1 and wp.guidance=="gps") {
+			var coord = geo.Coord.new();
+			coord.set_latlon(lat,lon,alt);
+			var spot = radar_system.ContactTGP.new("GPS-Spot",coord,0);
+			armament.contactPoint = spot;
+			tgp.gps = 1;
+			if (getprop("f16/stores/tgp-mounted") and 0) {
+				tgp.flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
+				callsign = armament.contactPoint.getUnique();
+                setprop("/aircraft/flir/target/auto-track", 1);
+                flir_updater.offsetP = 0;
+                flir_updater.offsetH = 0;
+				setprop("f16/avionics/tgp-lock", 1);
+			}
+			wp.setContacts([spot]);
+		}
+	}
+}
+
+var _isValidNumber = func (number) {
+	# Is the number a valid possible steerpoint number?
+	if (number >= 300 and number < 300+number_of_threat_circles) {
+		return 1;
+	} elsif (number >= 350 and number <= 359) {
+		return 1;
+	} elsif (number >= 400 and number <= 404) {
+		return 1;
+	} elsif (number >= 450 and number <= 454) {
+		return 1;
+	} elsif (number == 500) {
+		return 1;
+	} elsif (number == 555) {
+		return 1;
+	} elsif (number >= 1 and number < 300) {
+		return 1;
+	} elsif (number >= 600 and number < 700) {
+		return 1;
+	} elsif (number >= 700 and number < 800) {
+		return 1;
+	}
+	return 0;
+}
+
+var _isOccupiedNumber = func (number) {
+	# Is a steerpoint stored at this memory address?
+	if (!_isValidNumber(number)) {
+		return 0;
+	}
+	if (number < 800 and number >= 700) {
+		if (lines[3] != nil) {
+			var fp = lines[3];
+			return fp.getPlanSize() > number-700;
+		}
+		return 0;
+	}
+	if (number < 700 and number >= 600) {
+		if (lines[2] != nil) {
+			var fp = lines[2];
+			return fp.getPlanSize() > number-600;
+		}
+		return 0;
+	}
+	if (number == 555) {
+		return stpt555[0] != nil;
+	}
+	if (number == 500) {
+		return stpt500[0] != nil;
+	}
+	if (number >= 450) {
+		return stpt450[number-450] != nil;
+	}
+	if (number >= 400) {
+		return stpt400[number-400] != nil;
+	}
+	if (number >= 350) {
+		return stpt350[number-350] != nil;
+	}
+	if (number >= 300) {
+		return stpt300[number-300] != nil;
+	}
+	if (number < 300 and number >= 200 and lines[1] != nil) {
+		var fp = lines[1];
+		return fp.getPlanSize() > number-200;
+	}
+	if (number < 200 and number >= 100 and lines[0] != nil) {
+		var fp = lines[0];
+		return fp.getPlanSize() > number-100;
+	}
+	if (number < 100 and number > 0 and isRouteActive()) {
+		var fp = flightplan();
+		return fp.getPlanSize() > number-1;
+	}
+	return 0;
+}
+
+
+
+var isRouteActive = func {
+	return getprop("autopilot/route-manager/active") and getprop("f16/avionics/power-mmc") and getprop("autopilot/route-manager/current-wp") != nil and getprop("autopilot/route-manager/current-wp") > -1 and getprop("autopilot/route-manager/route/num") != nil and getprop("autopilot/route-manager/current-wp") < getprop("autopilot/route-manager/route/num");
+}
+
+
+var data = nil;
+var sending = nil;
+var dlink_loop = func {
+  if (getprop("instrumentation/datalink/data") != 0) return;
+  foreach(contact; b1b.vector_aicontacts_links) {
+    if (contact.isVisible()) {
+      data = datalink.get_data(contact.get_Callsign());
+      if (data != nil  and data.on_link()) {
+        var p = data.point();
+        if (p != nil) {
+          sending = nil;
+          var mrk = STPT.new();
+          mrk.lat = p.lat();
+          mrk.lon = p.lon();
+          mrk.alt = p.alt()*M2FT;
+          var no = addDLMark(mrk);
+
+          setprop("instrumentation/datalink/data",no);
+
+          settimer(func {setprop("instrumentation/datalink/data",0);}, 10);
+          return;
+        }
+      }
+    }
+  }
+}
+
+var dlnk_timer = maketimer(3.5, dlink_loop);
+dlnk_timer.start();
+
+
+
+
+var loadLine = func  (no,path) {
+    printf("Attempting to load route %s to act as lines %d in HSD.", path, no);
+
+    call(func {lines[no] = createFlightplan(path);}, nil, var err = []);
+    if (size(err) or lines[no] == nil) {
+        print(err[0]);
+        setprop("f16/preplanning-status", err[0]);
+        gui.showDialog("loadfail");
+    } else {
+    	setprop("f16/preplanning-status", "HSD lines loaded");
+    }
+};
+
+var EMPTY_ALT = -99999;
+
+var serialize = func() {
+	var ret = "";
+	var iter = 0;
+	if (lines[0] != nil) {
+		for (var s = 0; s < lines[0].getPlanSize() and s < 100; s+=1) {
+			var key = lines[0].getWP(s);
+		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+100,key.lat,key.lon);
+	  	}
+	}
+	if (lines[1] != nil) {
+		for (var s = 0; s < lines[1].getPlanSize() and s < 100; s+=1) {
+			var key = lines[1].getWP(s);
+		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+200,key.lat,key.lon);
+	  	}
+	}
+	if (lines[2] != nil) {
+		for (var s = 0; s < lines[2].getPlanSize() and s < 100; s+=1) {
+			var key = lines[2].getWP(s);
+		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+600,key.lat,key.lon);
+	  	}
+	}
+	if (lines[3] != nil) {
+		for (var s = 0; s < lines[3].getPlanSize() and s < 100; s+=1) {
+			var key = lines[3].getWP(s);
+		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+700,key.lat,key.lon);
+	  	}
+	}
+	if (flightplan() != nil) {
+		var plan = flightplan();
+		for (var s = 0; s < plan.getPlanSize(); s+=1) {
+			var key = plan.getWP(s);
+		  	ret = ret~sprintf("PLAN,%d,%.6f,%.6f,%d,%d|",s+0,key.lat,key.lon,(key.alt_cstr_type!=nil and key.alt_cstr != nil)?key.alt_cstr:EMPTY_ALT,serializeTOS(s+1));
+	  	}
+	}
+  foreach(key;stpt300) {
+  	if (key == nil) {
+		ret = ret~sprintf("STPT,%d,nil|",iter+300);
+  	} else {
+    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+300,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+300));
+    }
+    iter += 1;
+  }
+  iter = 0;
+  foreach(key;stpt350) {
+  	if (key == nil) {
+  		ret = ret~sprintf("STPT,%d,nil|",iter+350);
+  	} else {
+    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+350,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+350));
+    }
+    iter += 1;
+  }
+  iter = 0;
+  foreach(key;stpt400) {
+  	if (key == nil) {
+  		ret = ret~sprintf("STPT,%d,nil|",iter+400);
+  	} else {
+    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+400,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+400));
+    }
+    iter += 1;
+  }
+  iter = 0;
+  foreach(key;stpt450) {
+  	if (key == nil) {
+  		ret = ret~sprintf("STPT,%d,nil|",iter+450);
+  	} else {
+    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+450,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+450));
+    }
+    iter += 1;
+  }
+  iter = 0;
+  foreach(key;stpt500) {
+  	if (key == nil) {
+  		ret = ret~sprintf("STPT,%d,nil|",iter+500);
+  	} else {
+    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+500,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+500));
+    }
+    iter += 1;
+  }
+  iter = 0;
+  foreach(key;stpt555) {
+  	if (key == nil) {
+  		ret = ret~sprintf("STPT,%d,nil|",iter+555);
+  	} else {
+    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+555,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+555));
+    }
+    iter += 1;
+  }
+  ret = ret~sprintf("IFF,%d|",getprop("instrumentation/iff/channel-selection"));
+  ret = ret~sprintf("DATALINK,%d|",getprop("instrumentation/datalink/channel"));
+  ret = ret~sprintf("COM1,%.2f|",getprop("instrumentation/comm[0]/frequencies/selected-mhz"));
+  ret = ret~sprintf("COM1S,%.2f|",getprop("instrumentation/comm[0]/frequencies/standby-mhz"));
+  ret = ret~sprintf("COM2,%.2f|",getprop("instrumentation/comm[1]/frequencies/selected-mhz"));
+  ret = ret~sprintf("COM2S,%.2f|",getprop("instrumentation/comm[1]/frequencies/standby-mhz"));
+  ret = ret~sprintf("ALOW,%d|",getprop("f16/settings/cara-alow"));
+  ret = ret~sprintf("BINGO,%d|",getprop("f16/settings/bingo"));
+  ret = ret~sprintf("SQUAWK,%04d|",getprop("instrumentation/transponder/id-code"));
+  return ret;
+}
+
+var unserialize = func(m) {
+  var stpts = split("|",m);
+  var planned = nil;
+
+  # clear memory:
+  lines = [nil,nil,nil,nil];
+  stpt300 = setsize([],number_of_threat_circles);#Threat circles
+  stpt350 = setsize([],10);#Generic
+  stpt400 = setsize([],5);#Markpoints Own
+  stpt450 = setsize([],5);#Markpoints DL
+  stpt500 = setsize([],1);#Weapon
+  stpt555 = setsize([],1);#Bullseye
+  ded.dataEntryDisplay.page = ded.pCNI;
+  current = nil;
+
+  foreach(item;stpts) {
+    #if (size(item)>4) {#why is this chekc even here???!
+      var items = split(",", item);
+      var key = items[0];
+
+      if (key == "PLAN") {
+      	var number = num(items[1]);
+      	if (planned == nil) planned = createFlightplan();
+      	var plan = planned;
+      	var wp = createWP(num(items[2]), num(items[3]), sprintf("STPT-%02d",number+1));
+		plan.insertWP(wp, number);
+		if (num(items[4]) != EMPTY_ALT) {
+			var leg = plan.getWP(plan.getPlanSize()-1);
+			leg.setAltitude(num(items[4]), "at");
+		}
+		if (size(items) > 5) { # TOS is supported
+            setNumberDesiredTOS(number+1, num(items[5]));
+        }
+      } elsif (key == "LINE") {
+      	var number = num(items[1]);
+      	var no = number >= 200;
+      	if (number >= 700) {
+      		no = 3;
+      	} elsif (number >= 600) {
+      		no = 2;
+      	}
+      	if (lines[no] == nil) {
+      		lines[no] = createFlightplan();
+      	}
+      	var wp = createWP(num(items[2]), num(items[3]), ""~number);
+      	number = no==1?number-200:(no==0?number-100:(no==2?number-600:number-700));
+		lines[no].insertWP(wp, number);
+      } elsif (key == "STPT") {
+      	var newST = nil;
+      	if (items[2]!="nil") {
+      		newST = STPT.new();
+      		newST.lat    = num(items[2]);
+      		newST.lon    = num(items[3]);
+      		newST.alt    = num(items[4]);
+      		newST.radius = num(items[5]);
+      		newST.color  = num(items[6]);
+      		newST.type   =     items[7];
+      	}
+      	var number = num(items[1]);
+      	if (number >= 555) {
+      		stpt555[number-555] = newST;
+
+      	} elsif (number >= 500) {
+      		stpt500[number-500] = newST;
+
+      	} elsif (number >= 450) {
+      		stpt450[number-450] = newST;
+      		dlMarkIndex = number-450;
+      	} elsif (number >= 400) {
+      		stpt400[number-400] = newST;
+      		ownMarkIndex = number-400;
+      	} elsif (number >= 350) {
+      		stpt350[number-350] = newST;
+
+      	} elsif (number >= 300) {
+      		stpt300[number-300] = newST;
+      	}
+      	if (size(items) > 8) { # TOS is supported
+            setNumberDesiredTOS(number, num(items[8]));
+        }
+
+      } elsif (key == "IFF") {
+      	setprop("instrumentation/iff/channel-selection", num(items[1]));
+      } elsif (key == "DATALINK") {
+      	setprop("instrumentation/datalink/channel", num(items[1]));
+      } elsif (key == "COM1") {
+      	setprop("instrumentation/comm[0]/frequencies/selected-mhz", num(items[1]));
+      } elsif (key == "COM1S") {
+      	setprop("instrumentation/comm[0]/frequencies/standby-mhz", num(items[1]));
+      } elsif (key == "COM2") {
+      	setprop("instrumentation/comm[1]/frequencies/selected-mhz", num(items[1]));
+      } elsif (key == "COM2S") {
+      	setprop("instrumentation/comm[1]/frequencies/standby-mhz", num(items[1]));
+      } elsif (key == "ALOW") {
+      	setprop("f16/settings/cara-alow", num(items[1]));
+      } elsif (key == "BINGO") {
+      	setprop("f16/settings/bingo", num(items[1]));
+      } elsif (key == "SQUAWK") {
+      	setprop("instrumentation/transponder/id-code", num(items[1]));
+      }
+    #}
+  }
+  if (planned != nil) {
+  	fgcommand("activate-flightplan", props.Node.new({"activate": 0}));
+  	planned.activate();
+  	fgcommand("activate-flightplan", props.Node.new({"activate": 1}));
+  }
+}
+
+var saveSTPTs = func (path) {
+    var text = serialize();
+    var opn = nil;
+    call(func{opn = io.open(path,"w");},nil, var err = []);
+    if (size(err) or opn == nil) {
+      print("error open file for writing STPTs");
+      gui.showDialog("savefail");
+      return 0;
+    }
+    call(func{var text = io.write(opn,text);},nil, var err = []);
+    if (size(err)) {
+      print("error writing file with STPTs");
+      setprop("f16/preplanning-status", err[0]);
+      io.close(opn);
+      gui.showDialog("savefail");
+      return 0;
+    } else {
+      io.close(opn);
+      setprop("f16/preplanning-status", "DTC data saved");
+      return 1;
+    }
+}
+
+var loadSTPTs = func (path) {
+    var text = nil;
+    call(func{text=io.readfile(path);},nil, var err = []);
+    if (size(err)) {
+      print("Loading STPTs failed.");
+      setprop("f16/preplanning-status", err[0]);
+      gui.showDialog("loadfail");
+    } elsif (text != nil) {
+      unserialize(text);
+      setprop("f16/preplanning-status", "DTC data loaded");
+    }
+}
+
+setprop("sim/fg-home-export", getprop("sim/fg-home")~"/Export");
\ No newline at end of file
diff --git a/Nasal/tacview.nas b/Nasal/tacview.nas
new file mode 100644
index 0000000..3090bf9
--- /dev/null
+++ b/Nasal/tacview.nas
@@ -0,0 +1,437 @@
+# Copyright by Justin Nicholson (aka Pinto)
+# Released under the GNU General Public License version 2.0
+#
+# Authors: Pinto, Nikolai V. Chr., Colin Geniet
+
+# Short installation instructions:
+# - Add and load this file in the 'tacview' namespace.
+# - Adjust the four parameters just below.
+# - Set property /payload/d-config/tacview_supported=1
+# - Ensure the radar code sets 'tacobj' fields properly.
+#   In Nikolai/Richard generic 'radar-system.nas',
+#   this simply requires setting 'enable_tacobject=1'.
+# - Add some way to start/stop recording.
+
+### Parameters to adjust (example values from the F-16)
+
+# Aircraft type string for tacview
+var tacview_ac_type = "F-16A";
+# Aircraft type as inserted in the output file name
+var filename_ac_type = "f16";
+
+# Function returning an array of "contact" objects, containing all aicrafts tacview is to show.
+# A contact object must
+# - implement the API specified by missile-code.nas
+# - have a getModel() method, which will be used as aircraft type designator in tacview.
+# - contain a field 'tacobj', which must be an instance of the 'tacobj' class below,
+#   and have the 'tacviewID' and 'valid' fields set appropriately.
+#
+var get_contacts_list = func {
+    return radar_system.getCompleteList();
+}
+
+# Function returning the focused/locked aircraft, as a "contact" object (or nil).
+var get_primary_contact = func {
+    return radar_system.apg68Radar.getPriorityTarget();
+}
+
+# Radar range. May return nil if n/a
+var get_radar_range_nm = func {
+    return radar_system.apg68Radar.getRange();
+}
+
+### End of parameters
+
+
+var main_update_rate = 0.3;
+var write_rate = 10;
+
+var outstr = "";
+
+var timestamp = "";
+var output_file = "";
+var f = "";
+var myplaneID = int(rand()*10000);
+var starttime = 0;
+var writetime = 0;
+
+var seen_ids = [];
+
+var tacobj = {
+    tacviewID: 0,
+    lat: 0,
+    lon: 0,
+    alt: 0,
+    roll: 0,
+    pitch: 0,
+    heading: 0,
+    speed: -1,
+    valid: 0,
+};
+
+var lat = 0;
+var lon = 0;
+var alt = 0;
+var roll = 0;
+var pitch = 0;
+var heading = 0;
+var speed = 0;
+var mutexWrite = thread.newlock();
+
+var input = {
+    mp_host:    "sim/multiplay/txhost",
+    radar:      "sim/multiplay/generic/int[2]",
+    fuel:       "consumables/fuel/total-fuel-lbs",
+    gear:       "gear/gear[0]/position-norm",
+    lat:        "position/latitude-deg",
+    lon:        "position/longitude-deg",
+    alt:        "position/altitude-ft",
+    roll:       "orientation/roll-deg",
+    pitch:      "orientation/pitch-deg",
+    heading:    "orientation/heading-deg",
+    tas:        "fdm/jsbsim/velocities/vtrue-kts",
+    cas:        "velocities/airspeed-kt",
+    mach:       "velocities/mach",
+    aoa:        "orientation/alpha-deg",
+    gforce:     "accelerations/pilot-g",
+};
+
+foreach (var name; keys(input)) {
+    input[name] = props.globals.getNode(input[name], 1);
+}
+
+
+var startwrite = func() {
+    if (starttime)
+        return;
+
+    timestamp = getprop("/sim/time/utc/year") ~ "-" ~ getprop("/sim/time/utc/month") ~ "-" ~ getprop("/sim/time/utc/day") ~ "T";
+    timestamp = timestamp ~ getprop("/sim/time/utc/hour") ~ ":" ~ getprop("/sim/time/utc/minute") ~ ":" ~ getprop("/sim/time/utc/second") ~ "Z";
+    var filetimestamp = string.replace(timestamp,":","-");
+    output_file = getprop("/sim/fg-home") ~ "/Export/tacview-" ~ filename_ac_type ~ "-" ~ filetimestamp ~ ".acmi";
+    # create the file
+    f = io.open(output_file, "w");
+    io.close(f);
+    var color = ",Color=Blue";
+    if (left(getprop("sim/multiplay/callsign"),5)=="OPFOR") {
+        color=",Color=Red";
+    }
+    var meta = sprintf(",DataSource=FlightGear %s,DataRecorder=%s v%s", getprop("sim/version/flightgear"), getprop("sim/description"), getprop("sim/aircraft-version"));
+    thread.lock(mutexWrite);
+    write("FileType=text/acmi/tacview\nFileVersion=2.1\n");
+    write("0,ReferenceTime=" ~ timestamp ~ meta ~ "\n#0\n");
+    write(myplaneID ~ ",T=" ~ getLon() ~ "|" ~ getLat() ~ "|" ~ getAlt() ~ "|" ~ getRoll() ~ "|" ~ getPitch() ~ "|" ~ getHeading() ~ ",Name="~tacview_ac_type~",CallSign="~getprop("/sim/multiplay/callsign")~color~"\n"); #
+    thread.unlock(mutexWrite);
+    starttime = systime();
+    setprop("/sim/screen/black","Starting Tacview recording");
+    main_timer.start();
+}
+
+var stopwrite = func() {
+    main_timer.stop();
+    setprop("/sim/screen/black","Stopping Tacview recording");
+    writetofile();
+    starttime = 0;
+    seen_ids = [];
+    explo_arr = [];
+    explosion_timeout_loop(1);
+}
+
+var mainloop = func() {
+    if (!starttime) {
+        main_timer.stop();
+        return;
+    }
+    if (systime() - writetime > write_rate) {
+        writetofile();
+    }
+    thread.lock(mutexWrite);
+    write("#" ~ (systime() - starttime)~"\n");
+    thread.unlock(mutexWrite);
+    writeMyPlanePos();
+    writeMyPlaneAttributes();
+    foreach (var cx; get_contacts_list()) {
+        if(cx.get_type() == armament.ORDNANCE) {
+            continue;
+        }
+        if (cx["prop"] != nil and cx.prop.getName() == "multiplayer" and input.mp_host.getValue() == "mpserver.opredflag.com") {
+            continue;
+        }
+        var color = ",Color=Blue";
+        if (left(cx.get_Callsign(),5)=="OPFOR" or left(cx.get_Callsign(),4)=="OPFR") {
+            color=",Color=Red";
+        }
+        thread.lock(mutexWrite);
+        if (find_in_array(seen_ids, cx.tacobj.tacviewID) == -1) {
+            append(seen_ids, cx.tacobj.tacviewID);
+            var model_is = cx.getModel();
+            if (model_is=="Mig-28") {
+                model_is = tacview_ac_type;
+                color=",Color=Red";
+            }
+            write(cx.tacobj.tacviewID ~ ",Name="~ model_is~ ",CallSign=" ~ cx.get_Callsign() ~color~"\n")
+        }
+        if (cx.tacobj.valid) {
+            var cxC = cx.getCoord();
+            lon = cxC.lon();
+            lat = cxC.lat();
+            alt = cxC.alt();
+            roll = cx.get_Roll();
+            pitch = cx.get_Pitch();
+            heading = cx.get_heading();
+            speed = cx.get_Speed()*KT2MPS;
+
+            write(cx.tacobj.tacviewID ~ ",T=");
+            if (lon != cx.tacobj.lon) {
+                write(sprintf("%.6f",lon));
+                cx.tacobj.lon = lon;
+            }
+            write("|");
+            if (lat != cx.tacobj.lat) {
+                write(sprintf("%.6f",lat));
+                cx.tacobj.lat = lat;
+            }
+            write("|");
+            if (alt != cx.tacobj.alt) {
+                write(sprintf("%.1f",alt));
+                cx.tacobj.alt = alt;
+            }
+            write("|");
+            if (roll != cx.tacobj.roll) {
+                write(sprintf("%.1f",roll));
+                cx.tacobj.roll = roll;
+            }
+            write("|");
+            if (pitch != cx.tacobj.pitch) {
+                write(sprintf("%.1f",pitch));
+                cx.tacobj.pitch = pitch;
+            }
+            write("|");
+            if (heading != cx.tacobj.heading) {
+                write(sprintf("%.1f",heading));
+                cx.tacobj.heading = heading;
+            }
+            if (speed != cx.tacobj.speed) {
+                write(sprintf(",TAS=%.1f",speed));
+                cx.tacobj.speed = speed;
+            }
+            write("\n");
+        }
+        thread.unlock(mutexWrite);
+    }
+    explosion_timeout_loop();
+}
+
+var main_timer = maketimer(main_update_rate, mainloop);
+
+
+var writeMyPlanePos = func() {
+    thread.lock(mutexWrite);
+    write(myplaneID ~ ",T=" ~ getLon() ~ "|" ~ getLat() ~ "|" ~ getAlt() ~ "|" ~ getRoll() ~ "|" ~ getPitch() ~ "|" ~ getHeading() ~ "\n");
+    thread.unlock(mutexWrite);
+}
+
+var writeMyPlaneAttributes = func() {
+    var tgt = "";
+    var contact = get_primary_contact();
+    if (contact != nil) {
+        tgt= ",FocusedTarget="~contact.tacobj.tacviewID;
+    }
+    var rmode = ",RadarMode=1";
+    if (input.radar.getBoolValue()) {
+        rmode = ",RadarMode=0";
+    }
+    var rrange = get_radar_range_nm();
+    if (rrange != nil) {
+        rrange = sprintf(",RadarRange=%.0f", get_radar_range_nm()*NM2M);
+    } else {
+        rrange = "";
+    }
+    var fuel = sprintf(",FuelWeight=%.0f", input.fuel.getValue());
+    var gear = sprintf(",LandingGear=%.2f", input.gear.getValue());
+    var tas = getTas();
+    if (tas != nil) {
+        tas = ",TAS="~tas;
+    } else {
+        tas = "";
+    }
+    var str = myplaneID ~ fuel~rmode~rrange~gear~tas~",CAS="~getCas()~",Mach="~getMach()~",AOA="~getAoA()~",HDG="~getHeading()~tgt~",VerticalGForce="~getG()~"\n";#",Throttle="~getThrottle()~",Afterburner="~getAfterburner()~
+    thread.lock(mutexWrite);
+    write(str);
+    thread.unlock(mutexWrite);
+}
+
+var explo = {
+    tacviewID: 0,
+    time: 0,
+};
+
+var explo_arr = [];
+
+# needs threadlocked before calling
+var writeExplosion = func(lat,lon,altm,rad) {
+    var e = {parents:[explo]};
+    e.tacviewID = 21000 + int(math.floor(rand()*20000));
+    e.time = systime();
+    append(explo_arr, e);
+    write("#" ~ (systime() - starttime)~"\n");
+    write(e.tacviewID ~",T="~lon~"|"~lat~"|"~altm~",Radius="~rad~",Type=Explosion\n");
+}
+
+var explosion_timeout_loop = func(all = 0) {
+    foreach(var e; explo_arr) {
+        if (e.time) {
+            if (systime() - e.time > 15 or all) {
+                thread.lock(mutexWrite);
+                write("#" ~ (systime() - starttime)~"\n");
+                write("-"~e.tacviewID);
+                thread.unlock(mutexWrite);
+                e.time = 0;
+            }
+        }
+    }
+}
+
+var write = func(str) {
+    outstr = outstr ~ str;
+}
+
+var writetofile = func() {
+    if (outstr == "") {
+        return;
+    }
+    writetime = systime();
+    f = io.open(output_file, "a");
+    io.write(f, outstr);
+    io.close(f);
+    outstr = "";
+}
+
+var getLat = func() {
+    return input.lat.getValue();
+}
+
+var getLon = func() {
+    return input.lon.getValue();
+}
+
+var getAlt = func() {
+    return sprintf("%.2f", input.alt.getValue() * FT2M);
+}
+
+var getRoll = func() {
+    return sprintf("%.2f", input.roll.getValue());
+}
+
+var getPitch = func() {
+    return sprintf("%.2f", input.pitch.getValue());
+}
+
+var getHeading = func() {
+    return sprintf("%.2f", input.heading.getValue());
+}
+
+var getTas = func() {
+    var tas = input.tas.getValue();
+    if (tas != nil)
+        return sprintf("%.1f", tas * KT2MPS);
+    else
+        return nil;
+}
+
+var getCas = func() {
+    return sprintf("%.1f", input.cas.getValue() * KT2MPS);
+}
+
+var getMach = func() {
+    return sprintf("%.3f", input.mach.getValue());
+}
+
+var getAoA = func() {
+    return sprintf("%.2f", input.aoa.getValue());
+}
+
+var getG = func() {
+    return sprintf("%.2f", input.gforce.getValue());
+}
+
+#var getThrottle = func() {
+#    return sprintf("%.2f", getprop("velocities/thrust");
+#}
+
+#var getAfterburner = func() {
+#    return getprop("velocities/thrust")>0.61*0.61;
+#}
+
+var find_in_array = func(arr,val) {
+    forindex(var i; arr) {
+        if ( arr[i] == val ) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+#setlistener("/controls/armament/pickle", func() {
+#    if (!starttime) {
+#        return;
+#    }
+#    thread.lock(mutexWrite);
+#    write("#" ~ (systime() - starttime)~"\n");
+#    write("0,Event=Message|"~ myplaneID ~ "|Pickle, selection at " ~ (getprop("controls/armament/pylon-knob") + 1) ~ "\n");
+#    thread.unlock(mutexWrite);
+#},0,0);
+
+setlistener("/controls/armament/trigger", func(p) {
+    if (!starttime) {
+        return;
+    }
+    thread.lock(mutexWrite);
+    if (p.getValue()) {
+        write("#" ~ (systime() - starttime)~"\n");
+        write("0,Event=Message|"~ myplaneID ~ "|Trigger pressed.\n");
+    } else {
+        write("#" ~ (systime() - starttime)~"\n");
+        write("0,Event=Message|"~ myplaneID ~ "|Trigger released.\n");
+    }
+    thread.unlock(mutexWrite);
+},0,0);
+
+setlistener("/sim/multiplay/chat-history", func(p) {
+    if (!starttime) {
+        return;
+    }
+    var hist_vector = split("\n",p.getValue());
+    if (size(hist_vector) > 0) {
+        var last = hist_vector[size(hist_vector)-1];
+        last = string.replace(last,",",chr(92)~chr(44));#"\x5C"~"\x2C"
+        thread.lock(mutexWrite);
+        write("#" ~ (systime() - tacview.starttime)~"\n");
+        write("0,Event=Message|Chat ["~last~"]\n");
+        thread.unlock(mutexWrite);
+    }
+},0,0);
+
+
+var msg = func (txt) {
+    if (!starttime) {
+        return;
+    }
+    thread.lock(mutexWrite);
+    write("#" ~ (systime() - tacview.starttime)~"\n");
+    write("0,Event=Message|"~myplaneID~"|AI ["~txt~"]\n");
+    thread.unlock(mutexWrite);
+}
+
+setlistener("damage/sounds/explode-on", func(p) {
+    if (!starttime) {
+        return;
+    }
+
+    if (p.getValue()) {
+        thread.lock(mutexWrite);
+        write("#" ~ (systime() - tacview.starttime)~"\n");
+        write("0,Event=Destroyed|"~myplaneID~"\n");
+        thread.unlock(mutexWrite);
+    }
+},0,0);
diff --git a/Nasal/tgp.nas b/Nasal/tgp.nas
new file mode 100644
index 0000000..36a168e
--- /dev/null
+++ b/Nasal/tgp.nas
@@ -0,0 +1,977 @@
+# Copyright (C) 2016  onox
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+# Lines below FLIRCameraUpdater has been modified/added by Nikolai V. Chr.
+#
+# Position of the FLIR camera ([z (back), x (right), y (up)])
+var coords_cam = [
+    getprop("/sim/view[105]/config/z-offset-m"),
+    getprop("/sim/view[105]/config/x-offset-m"),
+    getprop("/sim/view[105]/config/y-offset-m")
+];
+io.include("Aircraft/Generic/updateloop.nas");
+#io.load_nasal(getprop("/sim/fg-root") ~ "/Aircraft/c172p/Nasal/generic/math_ext2.nas","math_ext2");
+var FLIRCameraUpdater = {
+
+    new: func {
+        var m = {
+            parents: [FLIRCameraUpdater, Updatable]
+        };
+        m.loop = UpdateLoop.new(components: [m], update_period: 0.0);
+
+        # Create a function to update the position of the FLIR camera
+        m.update_cam = me._get_flir_auto_updater(180.0);
+
+        # Create a function to update the position using an input device
+        m.manual_update_cam = me._get_flir_updater(180.0, m.update_cam);
+
+        m.click_coord_cam = nil;
+
+        m.listeners = std.Vector.new();
+
+        m.offsetP = 0;
+        m.offsetH = 0;
+
+        return m;
+    },
+
+    enable: func {
+        #me.loop.reset();
+        me.loop.enable();
+    },
+
+    disable: func {
+        #me.remove_listeners();
+        me.loop.disable();
+    },
+
+    enable_or_disable: func (enable) {
+        if (enable) {
+            me.enable();
+        }
+        else {
+            me.disable();
+        }
+    },
+
+    remove_listeners: func {
+        foreach (var listener; me.listeners.vector) {
+            removelistener(listener);
+        }
+        me.listeners.clear();
+    },
+
+    reset: func {
+        #print("reset called?!?!");
+        return;
+        me.remove_listeners();
+        me.listeners.append(setlistener("/sim/signals/click", func {
+            var lat = getprop("/sim/input/click/latitude-deg");
+            var lon = getprop("/sim/input/click/longitude-deg");
+            var elev = getprop("/sim/input/click/elevation-m");
+
+            var click_position = geo.Coord.new().set_latlon(lat, lon, elev);
+
+            var origin_position = geo.aircraft_position();
+            var distance_m = origin_position.direct_distance_to(click_position);
+
+            if (getprop("/aircraft/flir/locks/auto-track")) {
+                me.click_coord_cam = click_position;
+                setprop("/aircraft/flir/target/auto-track", 1);
+                logger.screen.white(sprintf("New tracking position at %d meter distance", distance_m));
+            }
+            else {
+                setprop("/aircraft/flir/target/auto-track", 0);
+                me.click_coord_cam = nil;
+                logger.screen.red("Press F6 to enable automatic tracking by FLIR camera");
+            }
+        }));
+
+        me.listeners.append(setlistener("/aircraft/flir/locks/auto-track", func (n) {
+            setprop("/aircraft/flir/target/auto-track", 0);
+            me.click_coord_cam = nil;
+            if (n.getBoolValue()) {
+                logger.screen.green("Automatic tracking by FLIR camera enabled. Click on the terrain to start tracking.");
+            }
+            else {
+                logger.screen.red("Automatic tracking by FLIR camera disabled");
+            }
+        }));
+    },
+
+    update: func (dt) {
+        var roll_deg  = getprop("/orientation/roll-deg");
+        var pitch_deg = getprop("/orientation/pitch-deg");
+        var heading   = getprop("/orientation/heading-deg");
+
+        var computer = me._get_flir_computer(roll_deg, pitch_deg, heading);
+
+        if (getprop("/aircraft/flir/target/auto-track") and me.click_coord_cam != nil) {
+
+            var (yaw, pitch, distance) = computer(coords_cam, me.click_coord_cam);
+            #printf("C %.5f,%.5f,%.5f",me.click_coord_cam.lat(),me.click_coord_cam.lon(),me.click_coord_cam.alt());
+            if (lock_tgp) {
+                #print("L");
+                me.update_cam(roll_deg, pitch_deg, yaw, pitch);
+            } else {
+                #print("NO      LLLLLLLLLLL");
+                me.update_cam(roll_deg, pitch_deg, yaw+me.offsetH, pitch+me.offsetP);
+            }
+        }
+#        else {
+#            me.manual_update_cam(roll_deg, pitch_deg);
+#        }
+    },
+
+    aim: func () {
+        var roll_deg  = getprop("/orientation/roll-deg");
+        var pitch_deg = getprop("/orientation/pitch-deg");
+        var heading   = getprop("/orientation/heading-deg");
+
+        var computer = me._get_flir_computer(roll_deg, pitch_deg, heading);
+
+        if (getprop("/sim/current-view/name") == "TGP" and me.click_coord_cam != nil) {
+            #printf("B %.5f,%.5f,%.5f",me.click_coord_cam.lat(),me.click_coord_cam.lon(),me.click_coord_cam.alt());
+            me.click_coord_cam.lat();
+            var (yaw, pitch, distance) = computer(coords_cam, me.click_coord_cam);
+            me.update_cam(roll_deg, pitch_deg, yaw, pitch);
+        }
+    },
+
+    ######################################################################
+    # Gyro stabilization                                                 #
+    ######################################################################
+
+    _get_flir_updater: func (offset, updater) {
+        return func (roll_deg, pitch_deg) {
+            var yaw   = getprop("/aircraft/flir/input/yaw-deg") + (180.0 - offset);
+            var pitch = getprop("/aircraft/flir/input/pitch-deg");
+
+            updater(roll_deg, pitch_deg, yaw, pitch);
+        };
+    },
+
+    ######################################################################
+    # Automatic tracking computation                                     #
+    ######################################################################
+
+    _get_flir_auto_updater: func (offset) {
+        return func (roll_deg, pitch_deg, yaw, pitch) {
+            (yaw, pitch) = math_ext2.get_yaw_pitch_body(roll_deg, pitch_deg, yaw, pitch, offset);
+
+            setprop("/aircraft/flir/target/yaw-deg", yaw);
+            setprop("/aircraft/flir/target/pitch-deg", pitch);
+            if (getprop("/sim/current-view/name") == "TGP") {
+                setprop("/sim/current-view/goal-heading-offset-deg", -yaw);
+                setprop("/sim/current-view/goal-pitch-offset-deg", pitch);
+            }
+            setprop("sim/view[105]/heading-offset-deg", yaw);
+            setprop("sim/view[105]/pitch-offset-deg", pitch);
+        };
+    },
+
+    _get_flir_computer: func (roll_deg, pitch_deg, heading) {
+        return func (coords, target) {
+            var (position_2d, position) = math_ext2.get_point(coords[0], coords[1], coords[2], roll_deg, pitch_deg, heading);
+            return get_yaw_pitch_distance_inert(position_2d, position, target, heading);
+        }
+    }
+
+};
+
+get_yaw_pitch_distance_inert = func (position_2d, position, target_position, heading, f=nil) {
+    # Does the same as Onox's version, except takes curvature of Earth into account.
+    #printf("A %.5f,%.5f,%.5f",target_position.lat(),target_position.lon(),target_position.alt());
+    target_position.lat();
+    var heading_deg = positioned.courseAndDistance(position_2d, target_position)[0] - heading;
+    var pitch_deg   = vector.Math.getPitch(position, target_position);
+    var distance_m  = position.direct_distance_to(target_position);
+    return [heading_deg, pitch_deg, distance_m];
+}
+
+var flir_updater = FLIRCameraUpdater.new();
+
+setlistener("/sim/signals/fdm-initialized", func {
+    setlistener("/aircraft/flir/target/view-enabled", func (node) {
+        flir_updater.enable_or_disable(node.getBoolValue());
+    }, 1, 0);
+});
+
+var steerlock = 0;
+var enable = 1;
+var camera_movement_speed_lock = 75;#Higher number means slower
+var camera_movement_speed_free =  5;
+
+var list = func (node) {
+    var button = getprop("controls/MFD[2]/button-pressed");
+
+    if (button == 20) {#BACK
+        view.setViewByIndex(0);
+        #setprop("/aircraft/flir/target/auto-track", 0);
+        #lock.hide();
+        #setprop("f16/avionics/lock-flir",0.05);
+        return;
+    } elsif (button == 3) {#STBY/A-G/A-A
+        if (getprop("f16/avionics/power-mfd") and getprop("f16/avionics/power-ufc-warm")==1 and getprop("f16/avionics/power-right-hdpt") == 1 and getprop("fdm/jsbsim/elec/bus/ess-dc") > 20) {
+            masterMode = !masterMode;
+        }
+    }
+    if (!enable) return;
+
+    if (button == 0 and node.getName() == "button-pressed") {
+        setprop("controls/displays/cursor-slew-x", 0);
+        setprop("controls/displays/cursor-slew-y", 0);
+    }
+
+    if (button == 1 or (getprop("controls/displays/cursor-click") and getprop("/sim/current-view/name") == "TGP")) {#LOCK
+        gps = 0;
+        if (lock_tgp) {
+            lock_tgp = 0;
+            armament.contactPoint = nil;print("Second click with TGP lock unlocks!");
+            return;
+        }
+        var x = -2.5856;
+        var y =  0.8536;
+        var z = -1.4121;
+        var pos = aircraftToCart({x:-x, y:y, z: -z});
+        var coordA = geo.Coord.new();
+        coordA.set_xyz(pos.x, pos.y, pos.z);
+        coordA.alt();# TODO: once fixed in FG this line is no longer needed.
+        var matrixMath = 0;
+        if (matrixMath) {
+            var dirCoord = geo.Coord.new(coordA);
+            var vHead = getprop("sim/current-view/heading-offset-deg");
+            var vPitch = getprop("sim/current-view/pitch-offset-deg");
+
+            var vectorF = vector.Math.eulerToCartesian3X(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
+            var vectorL = vector.Math.eulerToCartesian3Y(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
+            var vectorU = vector.Math.eulerToCartesian3Z(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
+            var viewM   = vector.Math.viewMatrix(vectorF,vectorL,vectorU);
+            var pitchM = vector.Math.pitchMatrix(vPitch);
+            var yawM   = vector.Math.yawMatrix(-vHead);
+            var rotation = vector.Math.multiplyMatrices(pitchM, yawM);#heading, pitch
+            var viewGlobal = vector.Math.multiplyMatrices4(viewM, vector.Math.to4x4(rotation));#order?
+            #viewGlobal = vector.Math.multiplyMatrices4(viewGlobal,vector.Math.mirrorMatrix);
+            #var vectorA = [viewGlobal[2],viewGlobal[6],viewGlobal[10]];
+            var vectorA = vector.Math.normalize(vector.Math.xFromView(viewGlobal));
+            #vectorA = vector.Math.multiplyMatrixWithVector(rotation, vectorF);
+            print(vector.Math.format(vectorA));
+            var set = vector.Math.cartesianToEuler(vectorA);
+
+            #if (set[0] == nil) {print("0 heading");return;}
+            #printf("%d heading %d pitch",set[0],set[1]);
+            dirCoord.apply_course_distance(set[0],50);
+            var up = math.tan(set[1]*D2R)*50;
+            dirCoord.set_alt(coordA.alt()+up);
+        }
+
+        # get quaternion for view rotation:
+        var q = [getprop("sim/current-view/debug/orientation-w"),getprop("sim/current-view/debug/orientation-x"),getprop("sim/current-view/debug/orientation-y"),getprop("sim/current-view/debug/orientation-z")];
+
+        var V = [2 * (q[1] * q[3] - q[0] * q[2]), 2 * (q[2] * q[3] + q[0] * q[1]),1 - 2 * (q[1] * q[1] + q[2] * q[2])];
+        var w= q[0];
+        var x= q[1];
+        var y= q[2];
+        var z= q[3];
+
+        #rotate from x axis using the quaternion:
+        V = [1 - 2 * (y*y + z*z),2 * (x*y + w*z),2 * (x*z - w*y)];
+
+        var xyz          = {"x":coordA.x(),                "y":coordA.y(),               "z":coordA.z()};
+        #var directionLOS = {"x":dirCoord.x()-coordA.x(),   "y":dirCoord.y()-coordA.y(),  "z":dirCoord.z()-coordA.z()};
+        var directionLOS = {"x":V[0],   "y":V[1],  "z":V[2]};
+
+        # Check for terrain between own weapon and target:
+        var terrainGeod = get_cart_ground_intersection(xyz, directionLOS);
+        if (terrainGeod == nil) {
+            #print("0 terrain");
+            return;
+        } else {
+            var terrain = geo.Coord.new();
+            terrain.set_latlon(terrainGeod.lat, terrainGeod.lon, terrainGeod.elevation);
+            var ut = nil;
+            foreach (u ; radar_system.getCompleteList()) {
+                if (terrain.direct_distance_to(u.get_Coord())<45) {
+                    ut = u;
+                    break;
+                }
+            }
+            if (ut!=nil) {
+                var contact = ut.getNearbyVirtualTGPContact();
+                armament.contactPoint = contact;
+                #var tc = contact.getCoord();
+                #print("contactPoint "~tc.lat()~", "~tc.lon()~" at "~(tc.alt()*M2FT)~" ft");
+            } else {
+                armament.contactPoint = radar_system.ContactTGP.new("TGP-Spot",terrain,1);
+            }
+            #flir_updater.click_coord_cam = terrain;
+            #setprop("/aircraft/flir/target/auto-track", 1);
+            #interpolate("f16/avionics/lock-flir",1,1.5);
+            #flir_updater.offsetP = 0;
+            #flir_updater.offsetH = 0;# commented so we get back to where we were when unlocking
+            lock_tgp = 1;
+        }
+    } elsif (button == 6) {#TV/IR
+        ir = !ir;
+    } elsif (button == 9) {#CZ
+        if (lock_tgp) return;
+        gps = 0;
+        if (getprop("/aircraft/flir/target/auto-track")) {
+            flir_updater.offsetP = 0;
+            flir_updater.offsetH = 0;
+        } else {
+            interpolate("sim/current-view/pitch-offset-deg", -30, 2.5);
+            interpolate("sim/current-view/heading-offset-deg", 0, 2.5);
+        }
+    } elsif (button == 10) {#MARK
+        if (!lock_tgp or armament.contactPoint == nil) return;
+        line10.setText("#"~steerpoints.markTGP(armament.contactPoint.get_Coord()));
+        settimer(func {line10.setText("MARK");}, 2.5);
+    } elsif (button == 11) {#UP
+        if (lock_tgp) return;
+        gps = 0;
+        setprop("controls/displays/cursor-slew-y", -1);
+        return;
+        var fov = getprop("sim/current-view/field-of-view");
+        if (getprop("/aircraft/flir/target/auto-track")) {
+            flir_updater.offsetP += fov/camera_movement_speed_lock;
+        } else {
+            setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")+fov/camera_movement_speed_free);
+        }
+    } elsif (button == 12) {#DOWN
+        if (lock_tgp) return;
+        gps = 0;
+        setprop("controls/displays/cursor-slew-y", 1);
+        return;
+        var fov = getprop("sim/current-view/field-of-view");
+        if (getprop("/aircraft/flir/target/auto-track")) {
+            flir_updater.offsetP -= fov/camera_movement_speed_lock;
+        } else {
+            setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")-fov/camera_movement_speed_free);
+        }
+    } elsif (button == 14) {#LEFT
+        if (lock_tgp) return;
+        gps = 0;
+        setprop("controls/displays/cursor-slew-x", -1);
+        return;
+        var fov = getprop("sim/current-view/field-of-view");
+        if (getprop("/aircraft/flir/target/auto-track")) {
+            flir_updater.offsetH -= fov/camera_movement_speed_lock;
+        } else {
+            setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")+fov/camera_movement_speed_free);
+        }
+    } elsif (button == 15) {#RGHT
+        if (lock_tgp) return;
+        gps = 0;
+        setprop("controls/displays/cursor-slew-x", 1);
+        return;
+        var fov = getprop("sim/current-view/field-of-view");
+        if (getprop("/aircraft/flir/target/auto-track")) {
+            flir_updater.offsetH += fov/camera_movement_speed_lock;
+        } else {
+            setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")-fov/camera_movement_speed_free);
+        }
+    } elsif (button == 13) {#WIDE/NARO
+        wide = !wide;
+    } elsif (button == 2) {#ZOOM
+        zoomlvl += 1;
+        if (zoomlvl > 4) {
+            zoomlvl = 1;
+        }
+    }
+};
+setlistener("controls/MFD[2]/button-pressed", list);
+setlistener("controls/displays/cursor-click", list);
+
+
+var flyupTime = 0;
+var flyupVis = 0;
+
+var fast_loop = func {
+  var viewName = getprop("/sim/current-view/name");
+
+    if (viewName == "TGP" and (getprop("/fdm/jsbsim/gear/unit[0]/WOW") or !getprop("f16/stores/tgp-mounted"))) {
+        # deselect view back to pilot default
+        masterMode = STBY;
+        view.setViewByIndex(0);
+        setprop("sim/rendering/als-filters/use-IR-vision", 0);
+        setprop("sim/view[105]/enabled", 0);
+        pullup_cue_3.setVisible(0);
+    } elsif (viewName == "TGP") {
+        if (!getprop("f16/avionics/power-mfd") or getprop("f16/avionics/power-ufc-warm")!=1) {
+            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+            midl.setText("    MFD OFF   ");
+            bott.setText("");
+            ralt.setText("");
+            line9.hide();
+            line10.hide();
+            line3.setText("");
+            cross.hide();
+            enable = 0;
+            masterMode = STBY;
+            pullup_cue_3.setVisible(0);
+        } elsif (getprop("f16/avionics/power-right-hdpt") == 0 or getprop("fdm/jsbsim/elec/bus/ess-dc") <=20) {
+            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+            midl.setText("      OFF     ");
+            bott.setText("");
+            ralt.setText("");
+            line9.hide();
+            line10.hide();
+            line3.setText("");
+            cross.hide();
+            enable = 0;
+            masterMode = STBY;
+            pullup_cue_3.setVisible(0);
+        } elsif (getprop("f16/avionics/power-right-hdpt-warm") < 1) {
+            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+
+            var to_secs = (1.0-getprop("/f16/avionics/power-right-hdpt-warm"))*180;
+            var mins = int(to_secs/60);
+            var secs = to_secs-mins*60;
+            var ttxt = sprintf(" %1d:%02d ", mins, secs);
+            midl.setText("NOT TIMED OUT");
+            bott.setText(ttxt);
+            ralt.setText("");
+            line9.hide();
+            line10.hide();
+            line3.setText(masterMode==0?"STBY":(hiddenMode==AG?"A-G":"A-A"));
+            cross.hide();
+            enable = 0;
+            pullup_cue_3.setVisible(0);
+        } elsif (masterMode == STBY) {
+            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+            midl.setText("   STANDBY   ");
+            bott.setText("");
+            ralt.setText("");
+            line9.hide();
+            line10.hide();
+            line3.setText("STBY");
+            cross.hide();
+            enable = 0;
+            flyupTime = getprop("instrumentation/radar/time-till-crash");
+            if (flyupTime != nil and flyupTime > 0 and flyupTime < 8) {
+                flyupVis = math.mod(getprop("sim/time/elapsed-sec"), 0.50) < 0.25;
+            } else {
+                flyupVis = 0;
+            }
+            pullup_cue_3.setVisible(flyupVis);
+        } else {
+            canvasMFDext.setColorBackground(1.00, 1.00, 1.00, 0.00);
+            line3.setText(hiddenMode==AG?"A-G":"A-A");
+            cross.show();
+            enable = 1;
+            flyupTime = getprop("instrumentation/radar/time-till-crash");
+            if (flyupTime != nil and flyupTime > 0 and flyupTime < 8) {
+                flyupVis = math.mod(getprop("sim/time/elapsed-sec"), 0.50) < 0.25;
+            } else {
+                flyupVis = 0;
+            }
+            pullup_cue_3.setVisible(flyupVis);
+        }
+
+        # FLIR TGP stuff:
+        setprop("aircraft/flir/target/view-enabled", viewName == "TGP");
+        setprop("sim/rendering/als-filters/use-filtering", viewName == "TGP");
+        setprop("sim/rendering/als-filters/use-IR-vision", viewName == "TGP" and ir);
+        setprop("sim/rendering/als-filters/use-night-vision", 0);
+
+        var x = getprop("sim/gui/canvas/size[0]");
+        var y = getprop("sim/gui/canvas/size[1]");
+
+        var degs = 3.6/zoomlvl;
+        if (wide) {
+            line13.setText("WIDE");
+        } else {
+            degs = 1.0/zoomlvl;
+            line13.setText("NARO");
+        }
+        var fov = degs*(x/y);
+        var format = (x/y)/2.25;#16/9 = 1.777
+        var scale = format*20/fov;# we take into account that different pilots have different screen formats so the height of the MFD in screen stays same relative.
+        setprop("sim/current-view/field-of-view-scale",scale);
+        setprop("sim/current-view/field-of-view",fov);
+
+        zoom.setText(sprintf("%.1fX",zoomlvl));
+
+        line6.setText(ir==1?"WHOT":"TV");
+
+        if (enable) {
+            lasercode = getprop("f16/avionics/laser-code");
+            if (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil) {
+                var dist = flir_updater.click_coord_cam.direct_distance_to(geo.aircraft_position())*M2NM;
+                bott.setText(sprintf("%2.1f  CMBT  %04d",dist,lasercode));
+                lat.setText(ded.convertDegreeToStringLat(flir_updater.click_coord_cam.lat()));
+                lon.setText(ded.convertDegreeToStringLon(flir_updater.click_coord_cam.lon()));
+            } else {
+                bott.setText(sprintf("      CMBT  %04d",lasercode));
+                lat.setText("");
+                lon.setText("");
+            }
+            if (getprop("f16/avionics/cara-on")) {
+                #1F-F16CJ-34-1 page 1-224
+                ralt.setText(sprintf("%4d",getprop("position/altitude-agl-ft")));
+            } else {
+                ralt.setText("");
+            }
+        } else {
+            lat.setText("");
+            lon.setText("");
+        }
+        if (!getprop("/aircraft/flir/target/auto-track") or flir_updater.click_coord_cam == nil) {
+            setprop("sim/view[105]/heading-offset-deg", -getprop("sim/current-view/heading-offset-deg"));
+            setprop("sim/view[105]/pitch-offset-deg", getprop("sim/current-view/pitch-offset-deg"));
+        }
+        setprop("sim/current-view/x-offset-m",0.8536);
+        setprop("sim/current-view/y-offset-m",-1.4121);
+        setprop("sim/current-view/z-offset-m",-2.5856);
+    } else {
+        # remove FLIR effects and disable TGP view
+        setprop("sim/rendering/als-filters/use-IR-vision", 0);
+        setprop("sim/view[105]/enabled", 0);#!getprop("gear/gear/wow"));
+        #lock.hide();
+        #setprop("f16/avionics/lock-flir",0.05);
+    }
+
+    steerlock = 0;
+    var follow = 0;
+    if (armament.contactPoint !=nil and armament.contactPoint.get_range()>35 and armament.contactPoint.get_Callsign() != "GPS-Spot") {
+        print("TGP attempted lock at 35+ nm: ",armament.contactPoint.get_range());
+        armament.contactPoint = nil;
+    }
+    var gpps = 0;
+    if (armament.contactPoint == nil or !enable) {
+        # no TGP lock
+        if (armament.contact == nil and enable and masterMode) {# we do not check for get_display here since as long as something is selected we dont show steerpoint.
+            if (steerpoints.getCurrentNumber() != 0) {
+                # TGP follow steerpoint
+                hiddenMode = AG;
+                var stpt = steerpoints.getCurrent();
+                var ele = stpt.alt;
+                var lat = stpt.lat;
+                var lon = stpt.lon;
+                if (ele == nil) {
+                    ele = 0;
+                }
+                ele *= FT2M;
+                var ele2 = geo.elevation(lat,lon);
+                if (ele2 != nil) {
+                    ele = ele2;
+                }
+                var sp = geo.Coord.new();
+                sp.set_latlon(lat,lon,ele);
+                flir_updater.click_coord_cam = sp;
+                setprop("/aircraft/flir/target/auto-track", 1);
+                if (callsign != "#"~steerpoints.getCurrentNumber()) {
+                    # we switched steerpoint or from radar to steerpoint
+                    flir_updater.offsetP = 0;
+                    flir_updater.offsetH = 0;
+                }
+                callsign = "#"~steerpoints.getCurrentNumber();
+                steerlock = 1;
+                steer = 1;
+            } else {
+                # TGP not follow, locked from aircraft
+                hiddenMode = AG;
+                setprop("/aircraft/flir/target/auto-track", 0);
+                flir_updater.click_coord_cam = nil;
+                flir_updater.offsetP = 0;
+                flir_updater.offsetH = 0;
+                steer = 0;
+                callsign = nil;
+            }
+        } elsif (armament.contact != nil and armament.contact.isVisible() and enable and masterMode) {
+            # TGP follow radar lock
+            flir_updater.click_coord_cam = armament.contact.get_Coord();
+            setprop("/aircraft/flir/target/auto-track", 1);
+            if (callsign != armament.contact.getUnique()) {
+                flir_updater.offsetP = 0;
+                flir_updater.offsetH = 0;
+            }
+            callsign = armament.contact.getUnique();
+            hiddenMode = armament.contact.get_type() == armament.AIR?AA:AG;
+            steer = 0;
+        } else {
+            hiddenMode = AG;
+            setprop("/aircraft/flir/target/auto-track", 0);
+            flir_updater.click_coord_cam = nil;
+            callsign = nil;
+            flir_updater.offsetP = 0;
+            flir_updater.offsetH = 0;
+            steer = 0;
+        }
+        lock_tgp = 0;
+        gps = 0;
+    } else {
+        # TGP lock
+        var vis = 1;
+        line10.show();
+        gpss = armament.contactPoint.get_Callsign() == "GPS-Spot";# GPS-Spot only used by "program GPS dialog"
+        if (armament.contactPoint.get_Callsign() != "TGP-Spot" and !gps and !gpss and !steer) {
+            # we do not check for visibility if:
+            # - following steerpoint
+            # - a GPS coord has been entered manually by "program GPS dialog"
+            follow = 1;
+            vis = radar_system.terrain.fastTerrainCheck(armament.contactPoint);
+            if (vis > 0) vis = 1;
+        }
+        if (!vis or !masterMode) {
+            setprop("/aircraft/flir/target/auto-track", 0);
+            flir_updater.click_coord_cam = nil;
+            callsign = nil;
+            flir_updater.offsetP = 0;
+            flir_updater.offsetH = 0;
+            lock_tgp = 0;
+            armament.contactPoint = nil;print("No vis on TGP lock");
+            hiddenMode = AG;
+        } else {
+            lock_tgp = 1;
+            flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
+            #callsign = armament.contactPoint.getUnique();
+            setprop("/aircraft/flir/target/auto-track", 1);
+            #flir_updater.offsetP = 0;
+            #flir_updater.offsetH = 0;# commented so we get back to where we were when unlocking
+        }
+    }
+    setprop("f16/avionics/tgp-lock", lock_tgp);#used in HUD
+
+    if (getprop("f16/stores/tgp-mounted") and enable) {
+        if (lock_tgp and !lock_tgp_last) {
+            interpolate("f16/avionics/lock-flir",1,1.5);
+        } elsif (!lock_tgp) {
+            setprop("f16/avionics/lock-flir",0.05);
+        }
+        lock_tgp_last = lock_tgp;
+        if (lock_tgp) {
+            line1box.show();
+            line9.hide();
+            line11.hide();
+            line12.hide();
+            line14.hide();
+            line15.hide();
+        } else {
+            line1box.hide();
+            line9.show();
+            line11.show();
+            line12.show();
+            line14.show();
+            line15.show();
+        }
+        if (lock_tgp and gps) {
+            midl.setText(sprintf("%s      %s", "GPS", getprop("controls/armament/laser-arm-dmd")?"L":""));
+        } elsif (lock_tgp and follow) {
+            midl.setText(sprintf("%s POINT %s", gps?"GPS":(ir==1?"IR":"TV"), getprop("controls/armament/laser-arm-dmd")?"L":""));
+        } elsif (lock_tgp) {
+            midl.setText(sprintf("%s AREA  %s", gps?"GPS":(ir==1?"IR":"TV"), getprop("controls/armament/laser-arm-dmd")?"L":""));
+        } elsif (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil and steerlock) {
+            midl.setText(sprintf("STPT %s  %s", "#"~steerpoints.getCurrentNumber(), getprop("controls/armament/laser-arm-dmd")?"L":""));
+        } elsif (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil) {
+            midl.setText(sprintf("  RADAR  %s", getprop("controls/armament/laser-arm-dmd")?"L":""));
+        } else {
+            midl.setText(sprintf("         %s", getprop("controls/armament/laser-arm-dmd")?"L":""));
+        }
+
+        var scaleLock = getprop("f16/avionics/lock-flir");
+        lock.setScale(scaleLock,scaleLock);
+        lock.setStrokeLineWidth(1/scaleLock);
+        if (scaleLock != 0.05) {
+            lock.show();
+        } else {
+            lock.hide();
+        }
+        lock.update();
+
+        # animate the LANTIRN camera:
+        var b = geo.normdeg180(getprop("sim/view[105]/heading-offset-deg"));
+        var p = getprop("sim/view[105]/pitch-offset-deg");
+        var polarL = math.sqrt(p*p+b*b);
+        var polarD = polarL!=0 and b!=0?math.atan2(p,b)*R2D:-90;
+        setprop("aircraft/flir/swivel/pitch-deg",polarL);
+        setprop("aircraft/flir/swivel/roll-deg",polarD);
+    } elsif (!masterMode) {
+        lock.hide();
+    }
+    var dt = systime();
+    if (viewName == "TGP" and getprop("f16/stores/tgp-mounted") and enable) {
+        var cx = -getprop("/controls/displays/cursor-slew-x-delta");
+        var cy = -getprop("/controls/displays/cursor-slew-y-delta");
+        setprop("/controls/displays/cursor-slew-x-delta",0);
+        setprop("/controls/displays/cursor-slew-y-delta",0);
+        var modifier = getprop("/controls/displays/tgp-movement-modifier");
+        if (!lock_tgp and (cy != 0 or cx != 0)) {
+            gps = 0;
+            var fov = getprop("sim/current-view/field-of-view");
+            #var tme = dt - dt_old;
+            if (getprop("/aircraft/flir/target/auto-track")) {
+                var dist_modi = 1.0;
+                if (flir_updater.click_coord_cam != nil) {
+                    # 5nm is 5.0, 50 nm is 1.0
+                    dist_modi = 5 + ((flir_updater.click_coord_cam.direct_distance_to(radar_system.self.getCoord())*M2NM - 5) / (50 - 5)) * (1 - 5);
+                }
+                flir_updater.offsetP += dist_modi*modifier*cy*fov/camera_movement_speed_lock;
+                flir_updater.offsetH -= dist_modi*modifier*cx*fov/camera_movement_speed_lock;
+            } else {
+                setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")+modifier*cy*fov/camera_movement_speed_free);
+                setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")+modifier*cx*fov/camera_movement_speed_free);
+            }
+        }
+    }
+    dt_old = dt;
+}
+
+var flooptimer = nil;# started from f16.nas
+
+var dt_old = 0;
+
+var line1 = nil;
+var line1box = nil;
+var line2 = nil;
+var line3 = nil;
+var line4 = nil;
+var line6 = nil;
+var line7 = nil;
+var line10 = nil;
+var line11 = nil;
+var line12 = nil;
+var line13 = nil;
+var line14 = nil;
+var line15 = nil;
+var line20 = nil;
+var cross = nil;
+var lock = nil;
+var zoom = nil;
+var bott = nil;
+var ralt = nil;
+var lat = nil;
+var lon = nil;
+var line9 = nil;
+var midl = nil;
+var ir = 1;
+var lasercode = int(rand()*1778+1111);setprop("f16/avionics/laser-code",lasercode);
+var callsign = nil;
+var lock_tgp = 0;
+var lock_tgp_last = 0;
+var wide = 1;
+var zoomlvl = 1.0;
+var gps = 0;# set from Program GPS dialog
+var steer = 0;
+var STBY = 0;
+var AG = 1;
+var AA = 2;
+var masterMode = STBY;
+var hiddenMode = AG;
+var pullup_cue_3 = nil;
+
+var canvasMFDext = nil;
+var callInit = func {
+  canvasMFDext = canvas.new({
+        "name": "MFD-EXT",
+        "size": [256, 256],
+        "view": [256, 256],
+        "mipmapping": 1
+  });
+
+  canvasMFDext.addPlacement({"node": "MFDimage3", "texture": "tranbg.png"});
+  canvasMFDext.setColorBackground(1.00, 1.00, 1.00, 0.00);
+
+  dedGroup = canvasMFDext.createGroup();
+  dedGroup.show();
+  var color = [getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"),1];
+  line1 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("left-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("LOCK")
+        .setTranslation(5, 256*0.20);# 1
+  line1box = dedGroup.createChild("path")
+        .moveTo(0,-7)
+        .vert(14)
+        .horiz(35)
+        .vert(-14)
+        .horiz(-35)
+        .setStrokeLineWidth(1)
+        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+        .hide()
+        .setTranslation(5, 256*0.20);
+  line2 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("left-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("ZOOM")
+        .setTranslation(5, 256*0.35);# 2
+  line3 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("left-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("STBY")
+        .setTranslation(5, 256*0.50);# 3
+  line4 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("left-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("")
+        .setTranslation(5, 256*0.65);# 4
+  line6 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("right-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("WHOT")
+        .setTranslation(256-5, 256*0.2);# 6
+  line7 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("right-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("XFER")
+        .hide()
+        .setTranslation(256-5, 256*0.35);# 7
+  line9 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("right-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("CZ")
+        .hide()
+        .setTranslation(256-5, 256*0.65);# 9
+  line10 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("right-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("MARK")
+        .hide()
+        .setTranslation(256-5, 256*0.8);# 10
+  line11 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("center-top")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("UP")
+        .setTranslation(256*0.2, 5);# 11
+  line12 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("center-top")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("DOWN")
+        .setTranslation(256*0.35, 5);# 12
+  line13 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("center-top")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("WIDE")
+        .setTranslation(256*0.50, 5);# 13
+  line14 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("center-top")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("LEFT")
+        .setTranslation(256*0.65, 5);# 14
+  line15 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("center-top")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("RGHT")
+        .setTranslation(256*0.8, 5);# 15
+  line20 = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("center-bottom")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("BACK")
+        .setTranslation(256*0.8, 256-5);# 20
+
+    zoom = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+        .setAlignment("center-top")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("1.0X")
+        .setTranslation(256*0.5, 20);
+    midl = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+        .setAlignment("center-bottom")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("IR POINT    L")
+        .setTranslation(256*0.5, 256*0.8);
+    bott = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+        .setAlignment("center-bottom")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("13.0  CMBT  1538")
+        .setTranslation(256*0.5, 256*0.9);
+    ralt = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("right-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("RALT")
+        .setTranslation(256-25, 256*0.1);
+    lat = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("left-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("LAT")
+        .setTranslation(50, 256*0.2);
+    lon = dedGroup.createChild("text")
+        .setFontSize(13, 1)
+        .setColor(color)
+        .setAlignment("left-center")
+        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+        .setText("LON")
+        .setTranslation(50, 256*0.25);
+
+  cross = dedGroup.createChild("path")
+            .moveTo(128,0)
+            .vert(120)
+            .moveTo(128,256)
+            .vert(-120)
+            .moveTo(0,128)
+            .horiz(120)
+            .moveTo(256,128)
+            .horiz(-120)
+            .setStrokeLineWidth(1)
+            .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"));
+    lock = dedGroup.createChild("path")
+            #.setCenter(128,128)
+            .moveTo(48,48)
+            .vert(-96)
+            .horiz(-96)
+            .vert(96)
+            .horiz(96)
+            .hide()
+            .setTranslation(128,128)
+            .setStrokeLineWidth(1)
+            .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"));
+
+    pullup_cue_3 = canvasMFDext.createGroup().set("z-index", 9000).hide();
+    pullup_cue_3.createChild("path")
+               .moveTo(0, 0)
+               .lineTo(256, 256)
+               .moveTo(0, 256)
+               .lineTo(256, 0)
+               .setStrokeLineWidth(3)
+               .setColor([getprop("/sim/model/MFD-color/circle1/red"), getprop("/sim/model/MFD-color/circle1/green"), getprop("/sim/model/MFD-color/circle1/blue")]);
+};
diff --git a/Systems/b1-payload.xml b/Systems/b1-payload.xml
index 089126a..60ce9da 100644
--- a/Systems/b1-payload.xml
+++ b/Systems/b1-payload.xml
@@ -328,7 +328,7 @@
             <terminal-rise-time type="double">20.0</terminal-rise-time>
             <terminal-dive-time type="double">12.0</terminal-dive-time>
             <seeker-angular-speed-dps type="double">150</seeker-angular-speed-dps>
-            <ready-time type="double">300</ready-time>
+            <ready-time type="double">10</ready-time>
             <requires-power-on type="bool">true</requires-power-on>
             <power-on-battery-time type="double">2700</power-on-battery-time>
             <ejector-speed-fps type="double">5</ejector-speed-fps>
diff --git a/changes.patch b/changes.patch
new file mode 100644
index 0000000..30bf1d3
--- /dev/null
+++ b/changes.patch
@@ -0,0 +1,14611 @@
+diff --git a/B-1B-set.xml b/B-1B-set.xml
+index fd12235..dd64a04 100644
+--- a/B-1B-set.xml
++++ b/B-1B-set.xml
+@@ -100,6 +100,14 @@ B-1B set file.
+                 <default-field-of-view-deg>60</default-field-of-view-deg>
+             </config>
+         </view>
++        <view n="101">
++            <!-- also used for ejection view, if change this number, also change it in MissileView.nas -->
++            <name>Missile View</name>
++            <type>lookat</type>
++            <enabled>true</enabled>
++            <heading-offset-deg>180</heading-offset-deg>
++            <pitch-offset-deg>10</pitch-offset-deg>
++        </view>
+ 
+         <view n="96000">
+             <name>DSO/OSO centered view</name>
+@@ -337,11 +345,12 @@ B-1B set file.
+                             <script>weapons.repair_damage()</script>
+                         </binding>
+                     </item>
+-                    <item n="4">
++                    <item>
+                         <label>Targeting Computer</label>
++                        <name>targeting_comp</name>
+                         <binding>
+-                            <command>nasal</command>
+-                            <script>weapons.targeting_comp.open()</script>
++                            <command>dialog-show</command>
++                            <dialog-name>targeting_comp</dialog-name>
+                         </binding>
+                     </item>
+                     <item n="10">
+@@ -764,6 +773,15 @@ B-1B set file.
+             <lightning type="bool" archive="y">true</lightning>
+             <display-mode archive="y">arc</display-mode>
+         </wxradar>
++        <datalink>
++            <data type="int">0</data>
++            <power type="bool">false</power>
++            <channel type="int">42</channel>
++            <power_prop type="string">/instrumentation/datalink/power</power_prop>
++            <channel_prop type="string">instrumentation/datalink/channel</channel_prop>
++            <receive_period type="double">1</receive_period>
++            <!--identifier_prop type="string">instrumentation/datalink/ident</identifier_prop-->
++        </datalink>
+     </instrumentation>
+ 
+     <input>
+@@ -935,8 +953,27 @@ B-1B set file.
+         <vector>
+             <file>Aircraft/B-1B/Nasal/vector.nas</file>
+         </vector>
++        <ai>
++          <file>Aircraft/f16/Nasal/AI_list.nas</file>
++        </ai>
++        <view>
++          <file>Aircraft/B-1B/Nasal/MissileView.nas</file>
++        </view>
++        <tgp>
++          <file>Aircraft/B-1B/Nasal/tgp.nas</file>
++        </tgp>
++        <tacview>
++            <file>Aircraft/B-1B/Nasal/tacview.nas</file>
++        </tacview>
++        <datalink>
++            <file>Aircraft/B-1B/Nasal/datalink.nas</file>
++        </datalink>
++        <steerpoints>
++            <file>Aircraft/B-1B/Nasal/steerpoints.nas</file>
++        </steerpoints>
+         <radar_system>
+             <file>Aircraft/B-1B/Nasal/radar/radar-system.nas</file>
++            <file>Aircraft/B-1B/Nasal/radar/apg-68.nas</file>
+             <file>Aircraft/B-1B/Nasal/radar/rwr_new.nas</file>
+         </radar_system>
+         <armament>
+diff --git a/Nasal/AI_list.nas b/Nasal/AI_list.nas
+new file mode 100644
+index 0000000..27a1a79
+--- /dev/null
++++ b/Nasal/AI_list.nas
+@@ -0,0 +1,98 @@
++#print("*** LOADING AI_list.nas ... ***");
++# Autonomous singleton class that monitors AI object,
++# maintains data in various structures, and raises signal
++# "/sim/signals/ai-updated" whenever an aircraft
++# joined or left. Available data containers are:
++#
++#   ai.AImodel.data:        hash, key := /ai/models/~ path
++#   ai.AImodel.callsign     hash, key := callsign
++#   ai.AImodel.list         vector, sorted alphabetically (ASCII, case insensitive)
++#
++# All of them contain hash entries of this form:
++#
++# {
++#    callsign: "BiMaus", or 5H1N0B1 ;)
++#    root: "/ai/models/multiplayer[4]",            # root property
++#    node: {...},        # root property as props.Node hash
++#    sort: "bimaus",     # callsign in lower case (for sorting)
++# }
++
++var AImodel = {
++    new: func() {
++        var m = { parents: [AImodel] };
++        m.data = {};
++        m.callsign = {};
++        m.list = {};
++
++        # return our new object
++        return m;
++    },
++
++    init: func() {
++        #me.L = [];
++        #append(me.L, setlistener("ai/models/model-added", func(n) {
++            # Defer update() to the next convenient time to allow the
++            # new MP entry to become fully initialized.
++            #settimer(func me.update(), 0);
++        #}));
++        #append(me.L, setlistener("ai/models/model-removed", func(n) {
++            # Defer update() to the next convenient time to allow the
++            # old MP entry to become fully deactivated.
++            #settimer(func me.update(), 0);
++        #}));
++        me.update();
++    },
++    update: func(n = nil) {
++        var changedNode = props.globals.getNode(n, 1);
++        me.data = {};
++        me.callsign = {};
++        #print("UPDATE AI LIST");
++        foreach(var n ; props.globals.getNode("ai/models", 1).getChildren())
++        {
++            #print(n.getName());
++
++            if((var valid = n.getNode("valid")) == nil or !valid.getValue() or ((n.getNode("missile") == nil or n.getNode("missile").getValue() != 1) and (n.getNode("type") == nil or (n.getNode("type").getValue() != "Mig-28" and n.getNode("type").getValue() != "F-16"))))
++            {
++                continue;
++            }
++            var myName = string.replace(n.getPath(), "/ai/models/", "");
++            if (n.getNode("callsign") != nil and n.getNode("callsign").getValue()!=nil) {
++              myName = n.getNode("callsign").getValue();
++            }
++            #print( string.replace(n.getPath(),"/ai/models/",""));
++
++            var root = n.getPath();
++
++            var data = {
++                node: n,
++                callsign: myName,
++                root: root,
++                sort: string.lc(myName)
++            };
++            me.data[root] = data;
++            me.callsign[myName] = data;
++        }
++        #print(size(me.data));
++        me.list = sort(values(me.data), func(a, b) cmp(a.sort, b.sort));
++
++        if(size(me.data) > 0)
++        {
++            #print(me.list[1]);
++            setprop("ai/models/num-ai", size(me.list));
++            setprop("sim/signals/ai-updated", 1);
++        }
++        settimer(func(){ me.update() }, 0.5);
++    },
++    get_list: func(){
++        return me.list;
++    },
++
++    remove_suffix: func(s, x) {
++        var len = size(x);
++        if(substr(s, -len) == x)
++        {
++            return substr(s, 0, size(s) - len);
++        }
++        return s;
++    },
++};
+diff --git a/Nasal/MissileView.nas b/Nasal/MissileView.nas
+new file mode 100644
+index 0000000..542bcd2
+--- /dev/null
++++ b/Nasal/MissileView.nas
+@@ -0,0 +1,113 @@
++#print("*** LOADING MissileView.nas ... ***");
++var missile_view_handler = {
++  init: func(node) {
++    me.viewN = node;
++    me.current = nil;
++    me.legendN = props.globals.initNode("/sim/current-view/missile-view", "");
++    me.dialog = props.Node.new({ "dialog-name": "missile-view" });
++    me.listener = nil;
++  },
++  start: func {
++    me.listener = setlistener("/sim/signals/ai-updated", func me._update_(), 1);
++    me.reset();
++    fgcommand("dialog-show", me.dialog);
++  },
++  stop: func {
++    fgcommand("dialog-close", me.dialog);
++    if (me.listener!=nil)
++    {
++      removelistener(me.listener);
++      me.listener=nil;
++    }
++  },
++  reset: func {
++    me.select(0);
++  },
++  find: func(callsign) {
++    forindex (var i; me.list)
++      if (me.list[i].callsign == callsign)
++        return i;
++    return nil;
++  },
++  select: func(which, by_callsign=0) {
++    if (by_callsign or num(which) == nil)
++      which = me.find(which) or 0;  # turn callsign into index
++
++    me.setup(me.list[which]);
++  },
++  next: func(step) {
++    #ai.model.update();
++    me._update_();
++    var i = me.find(me.current);
++    i = i == nil ? 0 : math.mod(i + step, size(me.list));
++    me.setup(me.list[i]);
++  },
++  _update_: func {
++    var self = { callsign: getprop("/sim/multiplay/callsign"), model:,
++        node: props.globals, root: '/' };
++    #ai.myModel.update();
++    me.list = [self] ~ myModel.get_list();
++    if (!me.find(me.current))
++      me.select(0);
++  },
++  setup: func(data) {
++    if (data.root == '/') {
++      var zoffset = getprop("/sim/chase-distance-m");
++      var ident = '[' ~ data.callsign ~ ']';
++    } else {
++      var zoffset = 70;
++      #var ident = '"' ~ data.callsign ~ '" (' ~ data.model ~ ')';
++      var ident = '"' ~ data.callsign ~ '"';
++    }
++
++    me.current = data.callsign;
++    me.legendN.setValue(ident);
++    setprop("/sim/current-view/z-offset-m", zoffset);
++    setprop("/sim/current-view/heading-offset-deg", 110);
++    setprop("/sim/current-view/pitch-offset-deg", 30);
++
++    #print(me.current);
++
++    me.viewN.getNode("config").setValues({
++      "eye-lat-deg-path": data.root ~ "/position/latitude-deg",
++      "eye-lon-deg-path": data.root ~ "/position/longitude-deg",
++      "eye-alt-ft-path": data.root ~ "/position/altitude-ft",
++      "eye-heading-deg-path": data.root ~ "/orientation/true-heading-deg",
++      "target-lat-deg-path": data.root ~ "/position/latitude-deg",
++      "target-lon-deg-path": data.root ~ "/position/longitude-deg",
++      "target-alt-ft-path": data.root ~ "/position/altitude-ft",
++      "target-heading-deg-path": data.root ~ "/orientation/true-heading-deg",
++      "target-pitch-deg-path": data.root ~ "/orientation/pitch-deg",
++      "target-roll-deg-path": data.root ~ "/orientation/roll-deg",
++      "heading-offset-deg":180
++    });
++  },
++};
++
++var myModel = ai.AImodel.new();
++myModel.init();
++
++view.manager.register("Missile View",missile_view_handler);
++
++
++var view_firing_missile = func(myMissile)
++{
++
++    # We select the missile name
++    var myMissileName = string.replace(myMissile.ai.getPath(), "/ai/models/", "");
++    if (myMissile.ai.getNode("callsign") != nil and myMissile.ai.getNode("callsign").getValue()!=nil) {
++      myMissileName = myMissile.ai.getNode("callsign").getValue();
++    }
++
++    # We memorize the initial view number
++    var actualView = getprop("/sim/current-view/view-number");
++
++    # We recreate the data vector to feed the missile_view_handler
++    var data = { node: myMissile.ai, callsign: myMissileName, root: myMissile.ai.getPath()};
++
++    # We activate the AI view (on this aircraft it is the number 8)
++    view.setViewByIndex(101);
++
++    # We feed the handler
++    view.missile_view_handler.setup(data);
++}
+diff --git a/Nasal/Radar/apg-68.nas b/Nasal/Radar/apg-68.nas
+new file mode 100644
+index 0000000..3b2f73f
+--- /dev/null
++++ b/Nasal/Radar/apg-68.nas
+@@ -0,0 +1,3515 @@
++
++
++
++
++
++############# BEGIN SOMEWHAT GENERIC CLASSES ###########################################
++
++
++
++# Field of regard requests
++var FOR_ROUND  = 0;# TODO: be able to ask noseradar for round field of regard.
++var FOR_SQUARE = 1;
++#Pulses
++var DOPPLER = 1;
++var MONO = 0;
++
++var overlapHorizontal = 1.5;
++
++
++#   █████  ██ ██████  ██████   ██████  ██████  ███    ██ ███████     ██████   █████  ██████   █████  ██████
++#  ██   ██ ██ ██   ██ ██   ██ ██    ██ ██   ██ ████   ██ ██          ██   ██ ██   ██ ██   ██ ██   ██ ██   ██
++#  ███████ ██ ██████  ██████  ██    ██ ██████  ██ ██  ██ █████       ██████  ███████ ██   ██ ███████ ██████
++#  ██   ██ ██ ██   ██ ██   ██ ██    ██ ██   ██ ██  ██ ██ ██          ██   ██ ██   ██ ██   ██ ██   ██ ██   ██
++#  ██   ██ ██ ██   ██ ██████   ██████  ██   ██ ██   ████ ███████     ██   ██ ██   ██ ██████  ██   ██ ██   ██
++#
++#
++var AirborneRadar = {
++	#
++	# This is an base class for an airborne forward looking radar
++	# The class RadarMode uses this. Subclass as needed.
++	#
++	# TODO: Cleaner calls to optional ground mapper
++	#
++	fieldOfRegardType: FOR_SQUARE,
++	fieldOfRegardMaxAz: 60,
++	fieldOfRegardMaxElev: 60,
++	fieldOfRegardMinElev: -60,
++	currentMode: nil, # vector of cascading modes ending with current submode
++	currentModeIndex: nil,
++	rootMode: 0,
++	mainModes: nil,
++	instantFoVradius: 2.0,#average of horiz/vert radius
++	instantVertFoVradius: 2.5,# real vert radius (could be used by ground mapper)
++	instantHoriFoVradius: 1.5,# real hori radius (not used)
++	rcsRefDistance: 70,
++	rcsRefValue: 3.2,
++	#closureReject: -1, # The minimum kt closure speed it will pick up, else rejected.
++	#positionEuler: [0,0,0,0],# euler direction
++	positionDirection: [1,0,0],# vector direction
++	positionCart: [0,0,0,0],
++	eulerX: 0,
++	eulerY: 0,
++	horizonStabilized: 1, # When true antennae ignore roll (and pitch until its high)
++	vector_aicontacts_for: [],# vector of contacts found in field of regard
++	vector_aicontacts_bleps: [],# vector of not timed out bleps
++	chaffList: [],
++	chaffSeenList: [],
++	chaffFilter: 0.60,# 1=filters all chaff, 0=sees all chaff all the time
++	timer: nil,
++	timerMedium: nil,
++	timerSlow: nil,
++	timeToKeepBleps: 13,
++	elapsed: elapsedProp.getValue(),
++	lastElapsed: elapsedProp.getValue(),
++	debug: 0,
++	newAirborne: func (mainModes, child) {
++		var rdr = {parents: [child, AirborneRadar, Radar]};
++
++		rdr.mainModes = mainModes;
++
++		foreach (modes ; mainModes) {
++			foreach (mode ; modes) {
++				# this needs to be set on submodes also...hmmm
++				mode.radar = rdr;
++			}
++		}
++
++		rdr.currentModeIndex = setsize([], size(mainModes));
++		forindex (var i; rdr.currentModeIndex) {
++			rdr.currentModeIndex[i] = 0;
++		}
++
++		rdr.setCurrentMode(rdr.mainModes[0][0], nil);
++
++		rdr.SliceNotification = SliceNotification.new();
++		rdr.ContactNotification = VectorNotification.new("ContactNotification");
++		rdr.ActiveDiscRadarRecipient = emesary.Recipient.new("ActiveDiscRadarRecipient");
++		rdr.ActiveDiscRadarRecipient.radar = rdr;
++		rdr.ActiveDiscRadarRecipient.Receive = func(notification) {
++	        if (notification.NotificationType == "FORNotification") {
++	        	#printf("DiscRadar recv: %s", notification.NotificationType);
++	            #if (rdr.enabled == 1) { no, lets keep this part running, so we have fresh data when its re-enabled
++	    		    rdr.vector_aicontacts_for = notification.vector;
++	    		    rdr.purgeBleps();
++	    		    #print("size(rdr.vector_aicontacts_for)=",size(rdr.vector_aicontacts_for));
++	    	    #}
++	            return emesary.Transmitter.ReceiptStatus_OK;
++	        }
++	        if (notification.NotificationType == "ChaffReleaseNotification") {
++	    		rdr.chaffList ~= notification.vector;
++	            return emesary.Transmitter.ReceiptStatus_OK;
++	        }
++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
++	    };
++		emesary.GlobalTransmitter.Register(rdr.ActiveDiscRadarRecipient);
++		rdr.timer = maketimer(scanInterval, rdr, func rdr.loop());
++		rdr.timerSlow = maketimer(0.75, rdr, func rdr.loopSlow());
++		rdr.timerMedium = maketimer(0.25, rdr, func rdr.loopMedium());
++		rdr.timerMedium.start();
++		rdr.timerSlow.start();
++		rdr.timer.start();
++    	return rdr;
++	},
++	getTiltKnob: func {
++		me.theKnob = antennae_knob_prop.getValue();
++		if (math.abs(me.theKnob) < 0.01) {
++			antennae_knob_prop.setValue(0);
++			me.theKnob = 0;
++		}
++		return me.theKnob*60;
++	},
++	increaseRange: func {
++		if (me["gmapper"] != nil) me.gmapper.clear();
++		me.currentMode.increaseRange();
++	},
++	decreaseRange: func {
++		if (me["gmapper"] != nil) me.gmapper.clear();
++		me.currentMode.decreaseRange();
++	},
++	designate: func (designate_contact) {
++		me.currentMode.designate(designate_contact);
++	},
++	designateRandom: func {
++		# Use this method mostly for testing
++		if (size(me.vector_aicontacts_bleps) > 0) {
++			me.designate(me.vector_aicontacts_bleps[size(me.vector_aicontacts_bleps)-1]);
++		}
++	},
++	undesignate: func {
++		me.currentMode.undesignate();
++	},
++	getPriorityTarget: func {
++		if (!me.enabled) return nil;
++		return me.currentMode.getPriority();
++	},
++	cycleDesignate: func {
++		me.currentMode.cycleDesignate();
++	},
++	cycleMode: func {
++		me.currentModeIndex[me.rootMode] += 1;
++		if (me.currentModeIndex[me.rootMode] >= size(me.mainModes[me.rootMode])) {
++			me.currentModeIndex[me.rootMode] = 0;
++		}
++		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
++		me.newMode.setRange(me.currentMode.getRange());
++		me.oldMode = me.currentMode;
++		me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
++	},
++	cycleRootMode: func {
++		me.rootMode += 1;
++		if (me.rootMode >= size(me.mainModes)) {
++			me.rootMode = 0;
++		}
++
++		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
++		#me.newMode.setRange(me.currentMode.getRange());
++		me.oldMode = me.currentMode;
++		me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
++	},
++	cycleAZ: func {
++		if (me["gmapper"] != nil) me.gmapper.clear();
++		me.clearShowScan();
++		me.currentMode.cycleAZ();
++	},
++	cycleBars: func {
++		me.currentMode.cycleBars();
++		me.clearShowScan();
++	},
++	getDeviation: func {
++		return me.currentMode.getDeviation();
++	},
++	setCursorDeviation: func (cursor_az) {
++		return me.currentMode.setCursorDeviation(cursor_az);
++	},
++	getCursorDeviation: func {
++		return me.currentMode.getCursorDeviation();
++	},
++	setCursorDistance: func (nm) {
++		# Return if the cursor should be distance zeroed.
++		return me.currentMode.setCursorDistance(nm);;
++	},
++	getCursorAltitudeLimits: func {
++		if (!me.enabled) return nil;
++		return me.currentMode.getCursorAltitudeLimits();
++	},
++	getBars: func {
++		return me.currentMode.getBars();
++	},
++	getAzimuthRadius: func {
++		return me.currentMode.getAz();
++	},
++	getMode: func {
++		return me.currentMode.shortName;
++	},
++	setCurrentMode: func (new_mode, priority = nil) {
++		me.olderMode = me.currentMode;
++		me.currentMode = new_mode;
++		new_mode.radar = me;
++		#new_mode.setCursorDeviation(me.currentMode.getCursorDeviation()); # no need since submodes don't overwrite this
++		new_mode.designatePriority(priority);
++		if (me.olderMode != nil) me.olderMode.leaveMode();
++		new_mode.enterMode();
++		settimer(func me.clearShowScan(), 0.5);
++	},
++	setRootMode: func (mode_number, priority = nil) {
++		me.rootMode = mode_number;
++		if (me.rootMode >= size(me.mainModes)) {
++			me.rootMode = 0;
++		}
++
++		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
++		#me.newMode.setRange(me.currentMode.getRange());
++		me.oldMode = me.currentMode;
++		me.setCurrentMode(me.newMode, priority);
++	},
++	getRange: func {
++		return me.currentMode.getRange();
++	},
++	getCaretPosition: func {
++		if (me["eulerX"] == nil or me["eulerY"] == nil) {
++			return [0,0];
++		} elsif (me.horizonStabilized) {
++			return [me.eulerX/me.fieldOfRegardMaxAz,me.eulerY/me.fieldOfRegardMaxElev];
++		} else {
++			return [me.eulerX/me.fieldOfRegardMaxAz,me.eulerY/me.fieldOfRegardMaxElev];
++		}
++	},
++	setAntennae: func (local_dir) {
++		# remember to set horizonStabilized when calling this.
++
++		# convert from coordinates to polar
++		me.eulerDir = vector.Math.cartesianToEuler(local_dir);
++
++		# Make sure if pitch is 90 or -90 that heading gets set to something sensible
++		me.eulerX = me.eulerDir[0]==nil?0:geo.normdeg180(me.eulerDir[0]);
++		me.eulerY = me.eulerDir[1];
++
++		# Make array: [heading_degs, pitch_degs, heading_norm, pitch_norm], for convinience, not used atm.
++		#me.positionEuler = [me.eulerX,me.eulerDir[1],me.eulerX/me.fieldOfRegardMaxAz,me.eulerDir[1]/me.fieldOfRegardMaxElev];
++
++		# Make the antennae direction-vector be length 1.0
++		me.positionDirection = vector.Math.normalize(local_dir);
++
++		# Decompose the antennae direction-vector into seperate angles for Azimuth and Elevation
++		me.posAZDeg = -90+R2D*math.acos(vector.Math.normalize(vector.Math.projVectorOnPlane([0,0,1],me.positionDirection))[1]);
++		me.posElDeg = R2D*math.asin(vector.Math.normalize(vector.Math.projVectorOnPlane([0,1,0],me.positionDirection))[2]);
++
++		# Make an array that holds: [azimuth_norm, elevation_norm, azimuth_deg, elevation_deg]
++		me.positionCart = [me.posAZDeg/me.fieldOfRegardMaxAz, me.posElDeg/me.fieldOfRegardMaxElev,me.posAZDeg,me.posElDeg];
++
++		# Note: that all these numbers can be either relative to aircraft or relative to scenery.
++		# Its the modes responsibility to call this method with antennae local_dir that is either relative to
++		# aircraft, or to landscape so that they match how scanFOV compares the antennae direction to target positions.
++		#
++		# Make sure that scanFOV() knows what coord system you are operating in. By setting me.horizonStabilized.
++	},
++	installMapper: func (gmapper) {
++		me.gmapper = gmapper;
++	},
++	isEnabled: func {
++		return 1;
++	},
++	loop: func {
++		me.enabled = me.isEnabled();
++		setprop("instrumentation/radar/radar-standby", !me.enabled);
++		# calc dt here, so we don't get a massive dt when going from disabled to enabled:
++		me.elapsed = elapsedProp.getValue();
++		me.dt = me.elapsed - me.lastElapsed;
++		me.lastElapsed = me.elapsed;
++		if (me.enabled) {
++			if (me.currentMode.painter and me.currentMode.detectAIR) {
++				# We need faster updates to not lose track of oblique flying locks close by when in STT.
++				me.ContactNotification.vector = [me.getPriorityTarget()];
++				emesary.GlobalTransmitter.NotifyAll(me.ContactNotification);
++			}
++
++			while (me.dt > 0.001) {
++				# mode tells us how to move disc and to scan
++				me.dt = me.currentMode.step(me.dt);# mode already knows where in pattern we are and AZ and bars.
++
++				# we then step to the new position, and scan for each step
++				me.scanFOV();
++				me.showScan();
++			}
++
++		} elsif (size(me.vector_aicontacts_bleps)) {
++			# So that when radar is restarted there is not old bleps.
++			me.purgeAllBleps();
++		}
++	},
++	loopMedium: func {
++		#
++		# It send out what target we are Single-target-track locked onto if any so the target get RWR warning.
++		# It also sends out on datalink what we are STT/SAM/TWS locked onto.
++		# In addition it notifies the weapons what we have targeted.
++		# Plus it sets the MP property for radar standby so others can see us on RWR.
++		if (me.enabled) {
++			me.focus = me.getPriorityTarget();
++			if (me.focus != nil and me.focus.callsign != "") {
++				if (me.currentMode.painter) sttSend.setValue(left(md5(me.focus.callsign), 4));
++				else sttSend.setValue("");
++				if (steerpoints.sending == nil) {
++			        datalink.send_data({"contacts":[{"callsign":me.focus.callsign,"iff":0}]});
++			    }
++			} else {
++				sttSend.setValue("");
++				if (steerpoints.sending == nil) {
++		            datalink.clear_data();
++		        }
++			}
++			armament.contact = me.focus;
++			stbySend.setIntValue(0);
++		} else {
++			armament.contact = nil;
++			sttSend.setValue("");
++			stbySend.setIntValue(1);
++			if (steerpoints.sending == nil) {
++	            datalink.clear_data();
++	        }
++		}
++
++		me.debug = getprop("debug-radar/debug-main");
++	},
++	loopSlow: func {
++		#
++		# Here we ask the NoseRadar for a slice of the sky once in a while.
++		#
++		if (me.enabled and !(me.currentMode.painter and me.currentMode.detectAIR)) {
++			emesary.GlobalTransmitter.NotifyAll(me.SliceNotification.slice(self.getPitch(), self.getHeading(), math.max(-me.fieldOfRegardMinElev, me.fieldOfRegardMaxElev)*1.414, me.fieldOfRegardMaxAz*1.414, me.getRange()*NM2M, !me.currentMode.detectAIR, !me.currentMode.detectSURFACE, !me.currentMode.detectMARINE));
++		}
++	},
++	scanFOV: func {
++		#
++		# Here we test for IFF and test the radar beam against targets to see if the radar picks them up.
++		#
++		# Note that this can happen in aircraft coords (ACM modes) or in landscape coords (the other modes).
++		me.doIFF = getprop("instrumentation/radar/iff");
++    	setprop("instrumentation/radar/iff",0);
++    	if (me.doIFF) iff.last_interogate = systime();
++    	if (me["gmapper"] != nil) me.gmapper.scanGM(me.eulerX, me.eulerY, me.instantVertFoVradius, me.instantFoVradius,
++    		 me.currentMode.bars == 1 or (me.currentMode.bars == 4 and me.currentMode["nextPatternNode"] == 0) or (me.currentMode.bars == 3 and me.currentMode["nextPatternNode"] == 7) or (me.currentMode.bars == 2 and me.currentMode["nextPatternNode"] == 1),
++    		 me.currentMode.bars == 1 or (me.currentMode.bars == 4 and me.currentMode["nextPatternNode"] == 2) or (me.currentMode.bars == 3 and me.currentMode["nextPatternNode"] == 3) or (me.currentMode.bars == 2 and me.currentMode["nextPatternNode"] == 3));# The last two parameter is hack
++
++    	# test for passive ECM (chaff)
++		#
++		me.closestChaff = 1000000;# meters
++		if (size(me.chaffList)) {
++			if (me.horizonStabilized) {
++				me.globalAntennaeDir = vector.Math.yawVector(-self.getHeading(), me.positionDirection);
++			} else {
++				me.globalAntennaeDir = vector.Math.rollPitchYawVector(self.getRoll(), self.getPitch(), -self.getHeading(), me.positionDirection);
++			}
++
++			foreach (me.chaff ; me.chaffList) {
++				if (rand() < me.chaffFilter or me.chaff.meters < 10000+10000*rand()) continue;# some chaff are filtered out.
++				me.globalToTarget = vector.Math.pitchYawVector(me.chaff.pitch, -me.chaff.bearing, [1,0,0]);
++
++				# Degrees from center of radar beam to center of chaff cloud
++				me.beamDeviation = vector.Math.angleBetweenVectors(me.globalAntennaeDir, me.globalToTarget);
++
++				if (me.beamDeviation < me.instantFoVradius) {
++					if (me.chaff.meters < me.closestChaff) {
++						me.closestChaff = me.chaff.meters;
++					}
++					me.registerChaff(me.chaff);# for displays
++					#print("REGISTER CHAFF");
++				}# elsif(me.debug > -1) {
++					# This is too detailed for most debugging, remove later
++				#	setprop("debug-radar/main-beam-deviation-chaff", me.beamDeviation);
++				#}
++			}
++		}
++
++    	me.testedPrio = 0;
++		foreach(contact ; me.vector_aicontacts_for) {
++			if (me.doIFF == 1) {
++	            me.iffr = iff.interrogate(contact.prop);
++	            if (me.iffr) {
++	                contact.iff = me.elapsed;
++	            } else {
++	                contact.iff = -me.elapsed;
++	            }
++	        }
++			if (me.elapsed - contact.getLastBlepTime() < me.currentMode.minimumTimePerReturn) {
++				if(me.debug > 1 and me.currentMode.painter and contact == me.getPriorityTarget()) {
++					me.testedPrio = 1;
++				}
++				continue;# To prevent double detecting in overlapping beams
++			}
++
++			me.dev = contact.getDeviationStored();
++
++			if (me.horizonStabilized) {
++				# ignore roll and pitch
++
++				# Vector that points to target in radar coordinates as if aircraft it was not rolled or pitched.
++				me.globalToTarget = vector.Math.eulerToCartesian3X(-me.dev.bearing,me.dev.elevationGlobal,0);
++
++				# Vector that points to target in radar coordinates as if aircraft it was not yawed, rolled or pitched.
++				me.localToTarget = vector.Math.yawVector(self.getHeading(), me.globalToTarget);
++			} else {
++				# Vector that points to target in local radar coordinates.
++				me.localToTarget = vector.Math.eulerToCartesian3X(-me.dev.azimuthLocal,me.dev.elevationLocal,0);
++			}
++
++			# Degrees from center of radar beam to target, note that positionDirection must match the coord system defined by horizonStabilized.
++			me.beamDeviation = vector.Math.angleBetweenVectors(me.positionDirection, me.localToTarget);
++
++			if(me.debug > 1 and me.currentMode.painter and contact == me.getPriorityTarget()) {
++				# This is too detailed for most debugging, remove later
++				setprop("debug-radar/main-beam-deviation", me.beamDeviation);
++				me.testedPrio = 1;
++			}
++			if (me.beamDeviation < me.instantFoVradius and (me.dev.rangeDirect_m < me.closestChaff or rand() < me.chaffFilter) ) {#  and (me.closureReject == -1 or me.dev.closureSpeed > me.closureReject)
++				# TODO: Refine the chaff conditional (ALOT)
++				me.registerBlep(contact, me.dev, me.currentMode.painter, me.currentMode.pulse);
++				#print("REGISTER BLEP");
++
++				# Return here, so that each instant FoV max gets 1 target:
++				# TODO: refine by testing angle between contacts seen in this FoV
++				break;
++			}
++		}
++
++		if(me.debug > 1 and me.currentMode.painter and !me.testedPrio) {
++			setprop("debug-radar/main-beam-deviation", "--unseen-lock--");
++		}
++	},
++	registerBlep: func (contact, dev, stt, doppler = 1) {
++		if (!contact.isVisible()) return 0;
++		if (doppler) {
++			if (contact.isHiddenFromDoppler()) {
++				return 0;
++			}
++			if (math.abs(dev.closureSpeed) < me.currentMode.minClosure) {
++				return 0;
++			}
++		}
++
++		me.maxDistVisible = me.currentMode.rcsFactor * me.targetRCSSignal(self.getCoord(), dev.coord, contact.model, dev.heading, dev.pitch, dev.roll,me.rcsRefDistance*NM2M,me.rcsRefValue);
++
++		if (me.maxDistVisible > dev.rangeDirect_m) {
++			me.extInfo = me.currentMode.getSearchInfo(contact);# if the scan gives heading info etc..
++
++			if (me.extInfo == nil) {
++				return 0;
++			}
++			contact.blep(me.elapsed, me.extInfo, me.maxDistVisible, stt);
++			if (!me.containsVectorContact(me.vector_aicontacts_bleps, contact)) {
++				append(me.vector_aicontacts_bleps, contact);
++			}
++			return 1;
++		}
++		return 0;
++	},
++	registerChaff: func (chaff) {
++		chaff.seenTime = me.elapsed;
++		if (!me.containsVector(me.chaffSeenList, chaff)) {
++			append(me.chaffSeenList, chaff);
++		}
++	},
++	purgeBleps: func {
++		#ok, lets clean up old bleps:
++		me.vector_aicontacts_bleps_tmp = [];
++		me.elapsed = elapsedProp.getValue();
++		foreach(contact ; me.vector_aicontacts_bleps) {
++			me.bleps_cleaned = [];
++			foreach (me.blep;contact.getBleps()) {
++				if (me.elapsed - me.blep.getBlepTime() < me.currentMode.timeToFadeBleps) {
++					append(me.bleps_cleaned, me.blep);
++				}
++			}
++			contact.setBleps(me.bleps_cleaned);
++			if (size(me.bleps_cleaned)) {
++				append(me.vector_aicontacts_bleps_tmp, contact);
++				me.currentMode.testContact(contact);# TODO: do this smarter
++			} else {
++				me.currentMode.prunedContact(contact);
++			}
++		}
++		#print("Purged ", size(me.vector_aicontacts_bleps) - size(me.vector_aicontacts_bleps_tmp), " bleps   remains:",size(me.vector_aicontacts_bleps_tmp), " orig ",size(me.vector_aicontacts_bleps));
++		me.vector_aicontacts_bleps = me.vector_aicontacts_bleps_tmp;
++
++		#lets purge the old chaff also, both seen and unseen
++		me.wnd = wndprop.getValue();
++		me.chaffLifetime = math.max(0, me.wnd==0?25:25*(1-me.wnd/50));
++		me.chaffList_tmp = [];
++		foreach(me.evilchaff ; me.chaffList) {
++			if (me.elapsed - me.evilchaff.releaseTime < me.chaffLifetime) {
++				append(me.chaffList_tmp, me.evilchaff);
++			}
++		}
++		me.chaffList = me.chaffList_tmp;
++
++		me.chaffSeenList_tmp = [];
++		foreach(me.evilchaff ; me.chaffSeenList) {
++			if (me.elapsed - me.evilchaff.releaseTime < me.chaffLifetime or me.elapsed - me.evilchaff.seenTime < me.timeToKeepBleps) {
++				append(me.chaffSeenList_tmp, me.evilchaff);
++			}
++		}
++		me.chaffSeenList = me.chaffSeenList_tmp;
++	},
++	purgeAllBleps: func {
++		#ok, lets delete all bleps:
++		foreach(contact ; me.vector_aicontacts_bleps) {
++			contact.setBleps([]);
++			me.currentMode.prunedContact(contact);
++		}
++		me.vector_aicontacts_bleps = [];
++		me.chaffSeenList = [];
++	},
++	targetRCSSignal: func(aircraftCoord, targetCoord, targetModel, targetHeading, targetPitch, targetRoll, myRadarDistance_m = 74000, myRadarStrength_rcs = 3.2) {
++		#
++		# test method. Belongs in rcs.nas.
++		#
++	    me.target_front_rcs = nil;
++	    if ( contains(rcs.rcs_oprf_database,targetModel) ) {
++	        me.target_front_rcs = rcs.rcs_oprf_database[targetModel];
++	    } elsif ( contains(rcs.rcs_database,targetModel) ) {
++	        me.target_front_rcs = rcs.rcs_database[targetModel];
++	    } else {
++	        # GA/Commercial return most likely
++	        me.target_front_rcs = rcs.rcs_oprf_database["default"];
++	    }
++	    me.target_rcs = rcs.getRCS(targetCoord, targetHeading, targetPitch, targetRoll, aircraftCoord, me.target_front_rcs);
++
++	    # standard formula
++	    return myRadarDistance_m/math.pow(myRadarStrength_rcs/me.target_rcs, 1/4);
++	},
++	getActiveBleps: func {
++		return me.vector_aicontacts_bleps;
++	},
++	getActiveChaff: func {
++		return me.chaffSeenList;
++	},
++	showScan: func {
++		if (me.debug > 0) {
++			if (me["canvas2"] == nil) {
++	            me.canvas2 = canvas.Window.new([512,512],"dialog").set('title',"Scan").getCanvas(1);
++				me.canvas_root2 = me.canvas2.createGroup().setTranslation(256,256);
++				me.canvas2.setColorBackground(0.25,0.25,1);
++			}
++
++			if (me.elapsed - me.currentMode.lastFrameStart < 0.1) {
++				me.clearShowScan();
++			}
++			me.canvas_root2.createChild("path")
++				.setTranslation(256*me.eulerX/60, -256*me.eulerY/60)
++				.moveTo(0, 256*me.instantFoVradius/60)
++				.lineTo(0, -256*me.instantFoVradius/60)
++				.setColor(1,1,1);
++		}
++	},
++	clearShowScan: func {
++		if (me["canvas2"] == nil or me.debug < 1) return;
++		me.canvas_root2.removeAllChildren();
++		if (me.horizonStabilized) {
++			me.canvas_root2.createChild("path")
++				.moveTo(-250, 0)
++				.lineTo(250, 0)
++				.setColor(1,1,0)
++				.setStrokeLineWidth(4);
++		} else {
++			me.canvas_root2.createChild("path")
++				.moveTo(256*-5/60, 256*-1.5/60)
++				.lineTo(256*5/60, 256*-1.5/60)
++				.lineTo(256*5/60,  256*15/60)
++				.lineTo(256*-5/60,  256*15/60)
++				.lineTo(256*-5/60, 256*-1.5/60)
++				.setColor(1,1,0)
++				.setStrokeLineWidth(4);
++		}
++	},
++	containsVector: func (vec, item) {
++		foreach(test; vec) {
++			if (test == item) {
++				return 1;
++			}
++		}
++		return 0;
++	},
++
++	containsVectorContact: func (vec, item) {
++		foreach(test; vec) {
++			if (test.equals(item)) {
++				return 1;
++			}
++		}
++		return 0;
++	},
++
++	vectorIndex: func (vec, item) {
++		me.i = 0;
++		foreach(test; vec) {
++			if (test == item) {
++				return me.i;
++			}
++			me.i += 1;
++		}
++		return -1;
++	},
++	del: func {
++        emesary.GlobalTransmitter.DeRegister(me.ActiveDiscRadarRecipient);
++    },
++};
++
++
++
++
++
++
++
++
++
++
++var SPOT_SCAN = -1; # must be -1
++
++
++
++
++
++#  ██████   █████  ██████   █████  ██████      ███    ███  ██████  ██████  ███████
++#  ██   ██ ██   ██ ██   ██ ██   ██ ██   ██     ████  ████ ██    ██ ██   ██ ██
++#  ██████  ███████ ██   ██ ███████ ██████      ██ ████ ██ ██    ██ ██   ██ █████
++#  ██   ██ ██   ██ ██   ██ ██   ██ ██   ██     ██  ██  ██ ██    ██ ██   ██ ██
++#  ██   ██ ██   ██ ██████  ██   ██ ██   ██     ██      ██  ██████  ██████  ███████
++#
++#
++var RadarMode = {
++	#
++	# Subclass and modify as needed.
++	#
++	radar: nil,
++	range: 40,
++	minRange: 5,
++	maxRange: 160,
++	az: 60,
++	bars: 1,
++	azimuthTilt: 0,# modes set these depending on where they want the pattern to be centered.
++	elevationTilt: 0,
++	barHeight: 0.80,# multiple of instantFoVradius
++	barPattern:  [ [[-1,0],[1,0]] ],     # The second is multitude of instantFoVradius, the first is multitudes of me.az
++	barPatternMin: [0],
++	barPatternMax: [0],
++	nextPatternNode: 0,
++	scanPriorityEveryFrame: 0,# Related to SPOT_SCAN.
++	timeToFadeBleps: 13,
++	rootName: "Base",
++	shortName: "",
++	longName: "",
++	superMode: nil,
++	minimumTimePerReturn: 0.5,
++	rcsFactor: 0.9,
++	lastFrameStart: -1,
++	lastFrameDuration: 5,
++	detectAIR: 1,
++	detectSURFACE: 0,
++	detectMARINE: 0,
++	pulse: DOPPLER, # MONO or DOPPLER
++	minClosure: 0, # kt
++	cursorAz: 0,
++	cursorNm: 20,
++	upperAngle: 10,
++	lowerAngle: 10,
++	painter: 0, # if the mode when having a priority target will produce a hard lock on target.
++	mapper: 0,
++	discSpeed_dps: 1,# current disc speed. Must never be zero.
++	setRange: func (range) {
++		me.testMulti = me.maxRange/range;
++		if (int(me.testMulti) != me.testMulti) {
++			# max range is not dividable by range, so we don't change range
++			return 0;
++		}
++		me.range = math.min(me.maxRange, range);
++		me.range = math.max(me.minRange, me.range);
++		return range == me.range;
++	},
++	getRange: func {
++		return me.range;
++	},
++	_increaseRange: func {
++		me.range*=2;
++		if (me.range>me.maxRange) {
++			me.range*=0.5;
++			return 0;
++		}
++		return 1;
++	},
++	_decreaseRange: func {
++		me.range *= 0.5;
++		if (me.range < me.minRange) {
++			me.range *= 2;
++			return 0;
++		}
++		return 1;
++	},
++	getDeviation: func {
++		# how much the pattern is deviated from straight ahead in azimuth
++		return me.azimuthTilt;
++	},
++	getBars: func {
++		return me.bars;
++	},
++	getAz: func {
++		return me.az;
++	},
++	constrainAz: func () {
++		# Convinience method that the modes can use.
++		if (me.az == me.radar.fieldOfRegardMaxAz) {
++			me.azimuthTilt = 0;
++		} elsif (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
++		}
++	},
++	getPriority: func {
++		return me["priorityTarget"];
++	},
++	computePattern: func {
++		# Translate the normalized pattern nodes into degrees. Since me.az or maybe me.bars have tendency to change rapidly
++		# We do this every step. Its fast anyway.
++		me.currentPattern = [];
++		foreach (me.eulerNorm ; me.barPattern[me.bars-1]) {
++			me.patternNode = [me.eulerNorm[0]*me.az, me.eulerNorm[1]*me.radar.instantFoVradius*me.barHeight];
++			append(me.currentPattern, me.patternNode);
++		}
++		return me.currentPattern;
++	},
++	step: func (dt) {
++		me.radar.horizonStabilized = 1;# Might be unset inside preStep()
++
++		# Individual modes override this method and get ready for the step.
++		# Inside this they typically set 'azimuthTilt' and 'elevationTilt' for moving the pattern around.
++		me.preStep();
++
++		# Lets figure out the desired antennae tilts
++	 	me.azimuthTiltIntern = me.azimuthTilt;
++	 	me.elevationTiltIntern = me.elevationTilt;
++		if (me.nextPatternNode == SPOT_SCAN and me.priorityTarget != nil) {
++			# We never do spot scans in ACM modes so no check for horizonStabilized here.
++			me.lastBlep = me.priorityTarget.getLastBlep();
++			if (me.lastBlep != nil) {
++				me.azimuthTiltIntern = me.lastBlep.getAZDeviation();
++				me.elevationTiltIntern = me.lastBlep.getElev();
++			} else {
++				me.priorityTarget = nil;
++				me.undesignate();
++				me.nextPatternNode == 0;
++			}
++		} elsif (me.nextPatternNode == SPOT_SCAN) {
++			# We cannot do spot scan on stuff we cannot see, reverting back to pattern
++			me.nextPatternNode = 0;
++		}
++
++		# now lets check where we want to move the disc to
++		me.currentPattern      = me.computePattern();
++		me.targetAzimuthTilt   = me.azimuthTiltIntern+(me.nextPatternNode!=SPOT_SCAN?me.currentPattern[me.nextPatternNode][0]:0);
++		me.targetElevationTilt = me.elevationTiltIntern+(me.nextPatternNode!=SPOT_SCAN?me.currentPattern[me.nextPatternNode][1]:0);
++
++		# The pattern min/max pitch when not tilted.
++		me.min = me.barPatternMin[me.bars-1]*me.barHeight*me.radar.instantFoVradius;
++		me.max = me.barPatternMax[me.bars-1]*me.barHeight*me.radar.instantFoVradius;
++
++		# We check if radar gimbal mount can turn enough.
++		me.gimbalInBounds = 1;
++		if (me.radar.horizonStabilized) {
++			# figure out if we reach the gimbal limit
++	 		me.actualMin = self.getPitch()+me.radar.fieldOfRegardMinElev;
++	 		me.actualMax = self.getPitch()+me.radar.fieldOfRegardMaxElev;
++	 		if (me.targetElevationTilt < me.actualMin) {
++	 			me.gimbalInBounds = 0;
++	 		} elsif (me.targetElevationTilt > me.actualMax) {
++	 			me.gimbalInBounds = 0;
++	 		}
++ 		}
++ 		if (!me.gimbalInBounds) {
++ 			# Don't move the antennae if it cannot reach whats requested.
++ 			# This basically stop the radar from working while still not on standby
++ 			# until better attitude is reached.
++ 			#
++ 			# It used to attempt to scan in edge of FoR but thats not really helpful to a pilot.
++ 			# If need to scan while extreme attitudes then the are specific modes for that (in some aircraft).
++ 			me.radar.setAntennae(me.radar.positionDirection);
++ 			#print("db-Out of gimbal bounds");
++	 		return 0;
++	 	}
++
++	 	# For help with cursor limits we need to compute these
++		if (me.radar.horizonStabilized and me.gimbalInBounds) {
++			me.lowerAngle = me.min+me.elevationTiltIntern;
++			me.upperAngle = me.max+me.elevationTiltIntern;
++		} else {
++			me.lowerAngle = 0;
++			me.upperAngle = 0;
++		}
++
++	 	# Lets get a status for where we are in relation to where we are going
++		me.targetDir = vector.Math.pitchYawVector(me.targetElevationTilt, -me.targetAzimuthTilt, [1,0,0]);# A vector for where we want the disc to go
++		me.angleToNextNode = vector.Math.angleBetweenVectors(me.radar.positionDirection, me.targetDir);# Lets test how far from the target tilts we are.
++
++		# Move the disc
++		if (me.angleToNextNode < me.radar.instantFoVradius) {
++			# We have reached our target
++			me.radar.setAntennae(me.targetDir);
++			me.nextPatternNode += 1;
++			if (me.nextPatternNode >= size(me.currentPattern)) {
++				me.nextPatternNode = (me.scanPriorityEveryFrame and me.priorityTarget!=nil)?SPOT_SCAN:0;
++				me.frameCompleted();
++			}
++			#print("db-node:", me.nextPatternNode);
++			# Now the antennae has been moved and we return how much leftover dt there is to the main radar.
++			return dt-me.angleToNextNode/me.discSpeed_dps;# Since we move disc seperately in axes, this is not strictly correct, but close enough.
++		}
++
++		# Lets move each axis of the radar seperate, as most radars likely has 2 joints anyway.
++		me.maxMove = math.min(me.radar.instantFoVradius*overlapHorizontal, me.discSpeed_dps*dt);# 1.75 instead of 2 is because the FoV is round so we overlap em a bit
++
++		# Azimuth
++		me.distance_deg = me.targetAzimuthTilt - me.radar.eulerX;
++		if (me.distance_deg >= 0) {
++			me.moveX =  math.min(me.maxMove, me.distance_deg);
++		} else {
++			me.moveX = math.max(-me.maxMove, me.distance_deg);
++		}
++		me.newX = me.radar.eulerX + me.moveX;
++
++		# Elevation
++		me.distance_deg = me.targetElevationTilt - me.radar.eulerY;
++		if (me.distance_deg >= 0) {
++			me.moveY =  math.min(me.maxMove, me.distance_deg);
++		} else {
++			me.moveY =  math.max(-me.maxMove, me.distance_deg);
++		}
++		me.newY = me.radar.eulerY + me.moveY;
++
++		# Convert the angles to a vector and set the new antennae position
++		me.newPos = vector.Math.pitchYawVector(me.newY, -me.newX, [1,0,0]);
++		me.radar.setAntennae(me.newPos);
++
++		# As the two joins move at the same time, we find out which moved the most
++		me.movedMax = math.max(math.abs(me.moveX), math.abs(me.moveY));
++		if (me.movedMax == 0) {
++			# This should really not happen, we return 0 to make sure the while loop don't get infinite.
++			print("me.movedMax == 0");
++			return 0;
++		}
++		if (me.movedMax > me.discSpeed_dps) {
++			print("me.movedMax > me.discSpeed_dps");
++			return 0;
++		}
++		return dt-me.movedMax/me.discSpeed_dps;
++	},
++	frameCompleted: func {
++		if (me.lastFrameStart != -1) {
++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
++		}
++		me.lastFrameStart = me.radar.elapsed;
++	},
++	setCursorDeviation: func (cursor_az) {
++		me.cursorAz = cursor_az;
++	},
++	getCursorDeviation: func {
++		return me.cursorAz;
++	},
++	setCursorDistance: func (nm) {
++		# Return if the cursor should be distance zeroed.
++		return 0;
++	},
++	getCursorAltitudeLimits: func {
++		# Used in F-16 with two numbers next to cursor that indicates min/max for radar pattern in altitude above sealevel.
++		# It needs: me.lowerAngle, me.upperAngle and me.cursorNm
++		me.vectorToDist = [math.cos(me.upperAngle*D2R), 0, math.sin(me.upperAngle*D2R)];
++		me.selfC = self.getCoord();
++		me.geo = vector.Math.vectorToGeoVector(me.vectorToDist, me.selfC);
++		me.geo = vector.Math.product(me.cursorNm*NM2M, vector.Math.normalize(me.geo.vector));
++		me.up = geo.Coord.new();
++		me.up.set_xyz(me.selfC.x()+me.geo[0],me.selfC.y()+me.geo[1],me.selfC.z()+me.geo[2]);
++		me.vectorToDist = [math.cos(me.lowerAngle*D2R), 0, math.sin(me.lowerAngle*D2R)];
++		me.geo = vector.Math.vectorToGeoVector(me.vectorToDist, me.selfC);
++		me.geo = vector.Math.product(me.cursorNm*NM2M, vector.Math.normalize(me.geo.vector));
++		me.down = geo.Coord.new();
++		me.down.set_xyz(me.selfC.x()+me.geo[0],me.selfC.y()+me.geo[1],me.selfC.z()+me.geo[2]);
++		return [me.up.alt()*M2FT, me.down.alt()*M2FT];
++	},
++	leaveMode: func {
++		# Warning: In this method do not set anything on me.radar only on me.
++		me.lastFrameStart = -1;
++	},
++	enterMode: func {
++	},
++	designatePriority: func (contact) {},
++	cycleDesignate: func {},
++	testContact: func (contact) {},
++	prunedContact: func (c) {
++		if (c.equalsFast(me["priorityTarget"])) {
++			me.priorityTarget = nil;
++		}
++	},
++};#                                    END Radar Mode class
++
++
++
++
++
++
++#  ██████   █████  ████████  █████  ██      ██ ███    ██ ██   ██ 
++#  ██   ██ ██   ██    ██    ██   ██ ██      ██ ████   ██ ██  ██  
++#  ██   ██ ███████    ██    ███████ ██      ██ ██ ██  ██ █████  
++#  ██   ██ ██   ██    ██    ██   ██ ██      ██ ██  ██ ██ ██  ██ 
++#  ██████  ██   ██    ██    ██   ██ ███████ ██ ██   ████ ██   ██ 
++#                                                                
++#
++DatalinkRadar = {
++	# I check the sky 360 deg for anything on datalink
++	#
++	# I will set 'blue' and 'blueIndex' on contacts.
++	# blue==1: On our datalink
++	# blue==2: Targeted by someone on our datalink
++	#
++	# Direct line of sight required for ~1000MHz signal.
++	#
++	# This class is only semi generic!
++	new: func (rate, max_dist_fighter_nm, max_dist_station_nm) {
++		var dlnk = {parents: [DatalinkRadar, Radar]};
++
++		dlnk.max_dist_fighter_nm = max_dist_fighter_nm;
++		dlnk.max_dist_station_nm = max_dist_station_nm;
++
++		datalink.can_transmit = func(callsign, mp_prop, mp_index) {
++		    dlnk.contactSender = callsignToContact.get(callsign);
++		    if (dlnk.contactSender == nil) return 0;
++		    if (!dlnk.contactSender.isValid()) return 0;
++		    if (!dlnk.contactSender.isVisible()) return 0;
++
++		    dlnk.isContactStation = isKnownSurface(dlnk.contactSender.getModel()) or isKnownShip(dlnk.contactSender.getModel()) or isKnownAwacs(dlnk.contactSender.getModel());
++		    dlnk.max_dist_nm = dlnk.isContactStation?dlnk.max_dist_station_nm:dlnk.max_dist_fighter_nm;
++
++		    return dlnk.contactSender.get_range() < dlnk.max_dist_nm;
++		}
++
++
++		dlnk.index = 0;
++		dlnk.vector_aicontacts = [];
++		dlnk.vector_aicontacts_for = [];
++		dlnk.timer          = maketimer(rate, dlnk, func dlnk.scan());
++
++		dlnk.DatalinkRadarRecipient = emesary.Recipient.new("DatalinkRadarRecipient");
++		dlnk.DatalinkRadarRecipient.radar = dlnk;
++		dlnk.DatalinkRadarRecipient.Receive = func(notification) {
++	        if (notification.NotificationType == "AINotification") {
++	        	#printf("DLNKRadar recv: %s", notification.NotificationType);
++	        	#printf("DLNKRadar notified of %d contacts", size(notification.vector));
++    		    me.radar.vector_aicontacts = notification.vector;
++    		    me.radar.index = 0;
++	            return emesary.Transmitter.ReceiptStatus_OK;
++	        }
++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
++	    };
++		emesary.GlobalTransmitter.Register(dlnk.DatalinkRadarRecipient);
++		dlnk.DatalinkNotification = VectorNotification.new("DatalinkNotification");
++		dlnk.DatalinkNotification.updateV(dlnk.vector_aicontacts_for);
++		dlnk.timer.start();
++		return dlnk;
++	},
++
++	scan: func () {
++		if (!me.enabled) return;
++
++		#this loop is really fast. But we only check 1 contact per call
++		if (me.index >= size(me.vector_aicontacts)) {
++			# will happen if there is no contacts or if contact(s) went away
++			me.index = 0;
++			return;
++		}
++		me.contact = me.vector_aicontacts[me.index];
++		me.wasBlue = me.contact["blue"];
++		me.cs = me.contact.get_Callsign();
++		if (me.wasBlue == nil) me.wasBlue = 0;
++
++		if (!me.contact.isValid()) {
++			me.contact.blue = 0;
++			if (me.wasBlue > 0) {
++				#print(me.cs," is invalid and purged from Datalink");
++				me.new_vector_aicontacts_for = [];
++				foreach (me.c ; me.vector_aicontacts_for) {
++					if (!me.c.equals(me.contact) and !me.c.equalsFast(me.contact)) {
++						append(me.new_vector_aicontacts_for, me.c);
++					}
++				}
++				me.vector_aicontacts_for = me.new_vector_aicontacts_for;
++			}
++		} else {
++
++
++	        if (!me.contact.isValid()) {
++	        	me.lnk = nil;
++	        } else {
++	        	me.lnk = datalink.get_data(damage.processCallsign(me.cs));
++	        }
++
++	        if (me.lnk != nil and me.lnk.on_link() == 1) {
++	            me.blue = 1;
++	            me.blueIndex = me.lnk.index()+1;
++	        } elsif (me.cs == getprop("link16/wingman-4")) { # Hack that the F16 need. Just ignore it, as nil wont cause expection.
++	            me.blue = 1;
++	            me.blueIndex = 0;
++	        } else {
++	        	me.blue = 0;
++	            me.blueIndex = -1;
++	        }
++	        if (!me.blue and me.lnk != nil and me.lnk.tracked() == 1) {
++	        	me.dl_idx = me.lnk.tracked_by_index();
++	        	if (me.dl_idx != nil and me.dl_idx > -1) {
++		            me.blue = 2;
++		            me.blueIndex = me.dl_idx+1;
++			    }
++	        }
++
++	        me.contact.blue = me.blue;
++	        if (me.blue > 0) {
++	        	me.contact.blueIndex = me.blueIndex;
++				if (!AirborneRadar.containsVectorContact(me.vector_aicontacts_for, me.contact)) {
++					append(me.vector_aicontacts_for, me.contact);
++					emesary.GlobalTransmitter.NotifyAll(me.DatalinkNotification.updateV(me.vector_aicontacts_for));
++				}
++			} elsif (me.wasBlue > 0) {
++				me.new_vector_aicontacts_for = [];
++				foreach (me.c ; me.vector_aicontacts_for) {
++					if (!me.c.equals(me.contact) and !me.c.equalsFast(me.contact)) {
++						append(me.new_vector_aicontacts_for, me.c);
++					}
++				}
++				me.vector_aicontacts_for = me.new_vector_aicontacts_for;
++			}
++		}
++		me.index += 1;
++        if (me.index > size(me.vector_aicontacts)-1) {
++        	me.index = 0;
++
++        	# Lets not keep contacts no longer in our scene
++        	me.new_vector_aicontacts_for = [];
++			foreach (me.c ; me.vector_aicontacts_for) {
++				if (AirborneRadar.containsVectorContact(me.vector_aicontacts, me.c)) {
++					append(me.new_vector_aicontacts_for, me.c);
++				}
++			}
++			me.vector_aicontacts_for = me.new_vector_aicontacts_for;
++
++        	emesary.GlobalTransmitter.NotifyAll(me.DatalinkNotification.updateV(me.vector_aicontacts_for));
++        }
++	},
++	del: func {
++        emesary.GlobalTransmitter.DeRegister(me.DatalinkRadarRecipient);
++    },
++};
++
++
++
++
++
++
++
++
++
++
++########################### BEGIN NON-GENERIC CLASSES ##########################
++
++
++
++
++
++
++
++#   █████  ██████   ██████         ██████   █████ 
++#  ██   ██ ██   ██ ██             ██       ██   ██ 
++#  ███████ ██████  ██   ███ █████ ███████   █████  
++#  ██   ██ ██      ██    ██       ██    ██ ██   ██ 
++#  ██   ██ ██       ██████         ██████   █████  
++#                                                 
++#
++var APG68 = {
++	#
++	# Root modes is  0: CRM  1: ACM 2: SEA 3: GM 4: GMT
++	#
++	instantFoVradius: 3.90*0.5,#average of horiz/vert radius
++	instantVertFoVradius: 4.55*0.5,# real vert radius (used by ground mapper)
++	instantHoriFoVradius: 3.25*0.5,# real hori radius (not used)
++	rcsRefDistance: 70,
++	rcsRefValue: 3.2,
++	targetHistory: 3,# Not used in TWS
++	isEnabled: func {
++		return getprop("/f16/avionics/power-fcr-bit") == 2 and getprop("instrumentation/radar/radar-enable") and !getprop("/fdm/jsbsim/gear/unit[0]/WOW") and getprop("instrumentation/radar/serviceable");
++	},
++	setAGMode: func {
++		if (me.rootMode != 3) {
++			me.rootMode = 3;
++			me.oldMode = me.currentMode;
++
++			me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
++			me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
++		}
++	},
++	setAAMode: func {
++		if (me.rootMode != 0) {
++			me.rootMode = 0;
++			me.oldMode = me.currentMode;
++
++			me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
++			me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
++		}
++	},
++	showAZ: func {
++		me.currentMode.showAZ();
++	},
++	showAZinHSD: func {
++		me.currentMode.showAZinHSD();
++	},
++};
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++#  ███████        ██  ██████      ███    ███  █████  ██ ███    ██     ███    ███  ██████  ██████  ███████
++#  ██            ███ ██           ████  ████ ██   ██ ██ ████   ██     ████  ████ ██    ██ ██   ██ ██
++#  █████   █████  ██ ███████      ██ ████ ██ ███████ ██ ██ ██  ██     ██ ████ ██ ██    ██ ██   ██ █████
++#  ██             ██ ██    ██     ██  ██  ██ ██   ██ ██ ██  ██ ██     ██  ██  ██ ██    ██ ██   ██ ██
++#  ██             ██  ██████      ██      ██ ██   ██ ██ ██   ████     ██      ██  ██████  ██████  ███████
++#
++#
++var APG68Mode = {
++	minRange: 5, # MLU T1 .. should we make this 10 for block 10/30/YF? TODO
++	maxRange: 160,
++	bars: 4,
++	barPattern:  [ [[-1,0],[1,0]],                    # These are multitudes of [me.az, instantFoVradius]
++	               [[-1,-1],[1,-1],[1,1],[-1,1]],
++	               [[-1,0],[1,0],[1,2],[-1,2],[-1,0],[1,0],[1,-2],[-1,-2]],
++	               [[1,-3],[1,3],[-1,3],[-1,1],[1,1],[1,-1],[-1,-1],[-1,-3]] ],
++	barPatternMin: [0,-1, -2, -3],
++	barPatternMax: [0, 1,  2,  3],
++	rootName: "CRM",
++	shortName: "",
++	longName: "",
++	EXPsupport: 0,#if support zoom
++	EXPsearch: 1,# if zoom should include search targets
++	EXPfixedAim: 0,# If map underneath should move instead of cursor when slewing
++	showAZ: func {
++		return me.az != me.radar.fieldOfRegardMaxAz; # If this return false, then they are also not shown in PPI.
++	},
++	showAZinHSD: func {
++		return 1;
++	},
++	showBars: func {
++		return 1;
++	},
++	showRangeOptions: func {
++		return 1;
++	},
++	setCursorDistance: func (nm) {
++		# Return if the cursor should be distance zeroed.
++		me.cursorNm = nm;
++		if (nm < me.radar.getRange()*0.05) {
++			return me.decreaseRange();
++		} elsif (nm > me.radar.getRange()*0.95) {
++			return me.increaseRange();
++		}
++		return 0;
++	},
++	frameCompleted: func {
++		if (me.lastFrameStart != -1) {
++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
++			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
++		}
++		me.lastFrameStart = me.radar.elapsed;
++	},
++};#                                    END APG-68 Mode base class
++
++
++
++
++
++
++
++
++#  ██████  ██     ██ ███████ 
++#  ██   ██ ██     ██ ██      
++#  ██████  ██  █  ██ ███████ 
++#  ██   ██ ██ ███ ██      ██ 
++#  ██   ██  ███ ███  ███████ 
++#                            
++#
++var F16RWSMode = {
++	radar: nil,
++	shortName: "RWS",
++	longName: "Range While Search",
++	superMode: nil,
++	subMode: nil,
++	maxRange: 160,
++	discSpeed_dps: 65,#authentic for RWS
++	rcsFactor: 0.9,
++	EXPsupport: 1,#if support zoom
++	EXPsearch: 1,# if zoom should include search targets
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16RWSMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		subMode.superMode = mode;
++		subMode.shortName = mode.shortName;
++		return mode;
++	},
++	cycleAZ: func {
++		if (me.az == 10) me.az = 30;
++		elsif (me.az == 30) me.az = 60;
++		elsif (me.az == 60) me.az = 10;
++	},
++	cycleBars: func {
++		me.bars += 1;
++		if (me.bars == 3) me.bars = 4;# 3 is only for TWS
++		elsif (me.bars == 5) me.bars = 1;
++		me.nextPatternNode = 0;
++	},
++	designate: func (designate_contact) {
++		if (designate_contact == nil) return;
++		me.radar.setCurrentMode(me.subMode, designate_contact);
++		me.subMode.radar = me.radar;# find some smarter way of setting it.
++	},
++	undesignate: func {},
++	designatePriority: func (contact) {
++		me.designate(contact);
++	},
++	preStep: func {
++		var dev_tilt_deg = me.cursorAz;
++		me.elevationTilt = me.radar.getTiltKnob();
++		if (me.az == 60) {
++			dev_tilt_deg = 0;
++		}
++		me.azimuthTilt = dev_tilt_deg;
++		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
++		}
++	},
++	increaseRange: func {
++		me._increaseRange();
++	},
++	decreaseRange: func {
++		me._decreaseRange();
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		return [1,0,1,0,0,1];
++	},
++};
++
++
++#  ██      ██████  ███████ 
++#  ██      ██   ██ ██      
++#  ██      ██████  ███████ 
++#  ██      ██   ██      ██ 
++#  ███████ ██   ██ ███████ 
++#                          
++#
++var F16LRSMode = {
++	shortName: "LRS",
++	longName: "Long Range Search",
++	range: 160,
++	discSpeed_dps: 45,
++	rcsFactor: 1,
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16LRSMode, F16RWSMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		subMode.superMode = mode;
++		subMode.shortName = mode.shortName;
++		return mode;
++	},
++};
++
++
++#  ███████ ███████  █████ 
++#  ██      ██      ██   ██ 
++#  ███████ █████   ███████ 
++#       ██ ██      ██   ██ 
++#  ███████ ███████ ██   ██ 
++#                          
++#
++var F16SeaMode = {
++	rootName: "SEA",
++	shortName: "AUTO",
++	longName: "Sea Navigation Mode",
++	discSpeed_dps: 55,# was 55
++	maxRange: 80,
++	range: 20,
++	bars: 1,
++	rcsFactor: 1,
++	detectAIR: 0,
++	detectSURFACE: 0,
++	detectMARINE: 1,
++	pulse: MONO, # MONO or DOPPLER
++	#barPattern:  [ [[-1,-3],[1,-3]], # The SURFACE/SEA pattern is centered so pattern is almost entirely under horizon
++	#               [[-1,-5],[1,-5],[1,-3],[-1,-3]],
++	#               [[-1,-5],[1,-5],[1,-3],[-1,-3],[-1,-5],[1,-5],[1,-7],[-1,-7]],
++	#               [[1,-7],[1,-1],[-1,-1],[-1,-3],[1,-3],[1,-5],[-1,-5],[-1,-7]] ],
++	#barPatternMin: [-3, -5, -7, -7], # about down to -15 degs coverage from horizon with 4 bars
++	#barPatternMax: [-3, -3, -3, -1],
++	EXPsupport: 1,
++	EXPfixedAim: 1,
++	exp: 0,
++	expAz: 0,
++	expDistNm: 10,
++	autoCursor: 1,
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16SeaMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		subMode.superMode = mode;
++		subMode.shortName = mode.shortName;
++		subMode.rootName = mode.rootName;
++		return mode;
++	},
++	toggleAuto: func {
++		me.autoCursor = !me.autoCursor;
++		me.shortName = me.autoCursor?"AUTO":"MAN";
++	},
++	setCursorDistance: func (nm) {
++		# Return if the cursor should be distance zeroed.
++		me.cursorNm = nm;
++		if (me.autoCursor and nm < me.radar.getRange()*0.425) {
++			return me.decreaseRange();
++		} elsif (me.autoCursor and nm > me.radar.getRange()*0.95) {
++			return me.increaseRange();
++		}
++		return 0;
++	},
++	preStep: func {
++		var dev_tilt_deg = me.cursorAz;
++		if (me.az == 60) {
++			dev_tilt_deg = 0;
++		}
++		me.azimuthTilt = dev_tilt_deg;
++		me.elevationTilt = me.radar.getTiltKnob();
++		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
++		}
++		if (me.radar.getTiltKnob() == 0 and steerpoints.getCurrentNumber() != 0) {
++			me.groundPitch = steerpoints.getCurrentGroundPitch();
++			if (me.groundPitch != nil and me.groundPitch > -55 and me.groundPitch < 55) {
++				me.elevationTilt = me.groundPitch;
++			}
++		}
++	},
++	cycleAZ: func {
++		if (me.az == 10) me.az = 30;
++		elsif (me.az == 30) me.az = 60;
++		elsif (me.az == 60) me.az = 10;
++	},
++	cycleBars: func {
++	},
++	showBars: func {
++		return 0;
++	},
++	getEXPsize: func {
++		# return nm of zoom width
++		if (me.getRange() == 10) {
++			return 3.5;
++		} elsif (me.getRange() == 20) {
++			return 7;
++		} elsif (me.getRange() == 40) {
++			return 14;
++		} elsif (me.getRange() == 80) {
++			return 21;
++		}
++	},
++	showAZ: func {
++		return 1;
++	},
++	increaseRange: func {
++		me._increaseRange();
++	},
++	decreaseRange: func {
++		me._decreaseRange();
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		return [1,0,1,0,0,1];
++	},
++	designate: func (designate_contact) {
++		if (designate_contact == nil) return;
++		me.radar.setCurrentMode(me.subMode, designate_contact);
++		me.subMode.radar = me.radar;# find some smarter way of setting it.
++	},
++	undesignate: func {},
++	designatePriority: func (contact) {
++	},
++	enterMode: func {
++		me.radar.purgeAllBleps();
++	},
++};
++
++
++#   ██████  ███    ███ 
++#  ██       ████  ████ 
++#  ██   ███ ██ ████ ██ 
++#  ██    ██ ██  ██  ██ 
++#   ██████  ██      ██ 
++#                      
++#
++var F16GMMode = {
++	rootName: "GM",
++	longName: "Ground Map",
++	discSpeed_dps: 55,
++	detectAIR: 0,
++	detectSURFACE: 1,
++	detectMARINE: 0,
++	mapper: 1,
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16GMMode, F16SeaMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		subMode.superMode = mode;
++		subMode.shortName = mode.shortName;
++		subMode.rootName = mode.rootName;
++		return mode;
++	},
++	frameCompleted: func {
++		#print("frame ",me.radar.elapsed-me.lastFrameStart);
++		if (me.lastFrameStart != -1) {
++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
++			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
++		}
++		me.lastFrameStart = me.radar.elapsed;
++		if (me.radar["gmapper"] != nil) {
++			me.radar.gmapper.frameDone();
++		}
++	},
++	setExp: func (exp) {
++		me.exp = exp;
++		if (me.radar["gmapper"] != nil) me.radar.gmapper.expChanged(exp);
++	},
++	isEXP: func {
++		return me.exp;
++	},
++	setExpPosition: func (azimuth, distance_nm) {
++		me.expAz = azimuth;
++		me.expDistNm = distance_nm;
++	},
++	getEXPBoundary: func {
++		if (me.exp and 0) {
++			me.expWidthNm = me.getEXPsize();
++			me.expCart = [me.expDistNm*math.sin(me.expAz*D2R), me.expDistNm*math.cos(me.expAz*D2R)];
++			me.expCornerCartBegin = [me.expCart[0]-me.expWidthNm*0.5, me.expCart[1]-me.expWidthNm*0.5];
++			me.expCornerCartEnd   = [me.expCart[0]+me.expWidthNm*0.5, me.expCart[1]-me.expWidthNm*0.5];
++			me.expCornerDist1 = math.sqrt(me.expCornerCartBegin[0]*me.expCornerCartBegin[0]+me.expCornerCartBegin[1]*me.expCornerCartBegin[1]);
++			me.expCornerDist2 = math.sqrt(me.expCornerCartEnd[0]*me.expCornerCartEnd[0]+me.expCornerCartEnd[1]*me.expCornerCartEnd[1]);
++			me.azStart = math.asin(math.clamp(me.expCornerCartBegin[0]/me.expCornerDist1,0,1))*R2D;
++			me.azEnd = math.asin(math.clamp(me.expCornerCartEnd[0]/me.expCornerDist2,0,1))*R2D;
++			if (me.expCornerDist1 > me.expCornerDist2) {
++				me.expCornerCartBegin[1] += me.expWidthNm;
++				me.cornerRangeNm = math.sqrt(me.expCornerCartBegin[0]*me.expCornerCartBegin[0]+me.expCornerCartBegin[1]*me.expCornerCartBegin[1]);
++				me.expMinRange = me.expCornerCartEnd[1];
++			} else {
++				me.expCornerCartEnd[1] += me.expWidthNm;
++				me.cornerRangeNm = math.sqrt(me.expCornerCartEnd[0]*me.expCornerCartEnd[0]+me.expCornerCartEnd[1]*me.expCornerCartEnd[1]);
++				me.expMinRange = me.expCornerCartBegin[1];
++			}
++			# deg start/end and min and max range in nm:
++			return [me.azStart, me.azEnd, me.expMinRange, me.cornerRangeNm];
++		} else {
++			return nil;
++		}
++	},
++};
++
++
++#   ██████  ███    ███ ████████ 
++#  ██       ████  ████    ██    
++#  ██   ███ ██ ████ ██    ██ 
++#  ██    ██ ██  ██  ██    ██ 
++#   ██████  ██      ██    ██ 
++#                            
++#
++var F16GMTMode = {
++	rootName: "GMT",
++	longName: "Ground Moving Target",
++	discSpeed_dps: 55,
++	maxRange: 40,
++	bars: 4,
++	detectAIR: 0,
++	detectSURFACE: 1,
++	detectMARINE: 0,
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16GMTMode, F16SeaMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		subMode.superMode = mode;
++		subMode.shortName = mode.shortName;
++		subMode.rootName = mode.rootName;
++		return mode;
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		me.devGMT = contact.getDeviationStored();
++		if (me.devGMT.speed_kt < 10) return nil;# A gain knob decide this. (should it be radial speed instead?)
++		return [1,0,1,1,0,1];
++	},
++};
++
++
++#  ██    ██ ███████
++#  ██    ██ ██     
++#  ██    ██ ███████
++#   ██  ██       ██ 
++#    ████   ███████ 
++#                           
++#
++var F16VSMode = {
++	shortName: "VS",#todo: make vsr also for newer blocks
++	longName: "Velocity Search",
++	range: 160,
++	discSpeed_dps: 45,
++	discSpeed_alert_dps: 45,    # From manual
++	discSpeed_confirm_dps: 100, # From manual
++	maxScanIntervalForVelocity: 12,
++	rcsFactor: 1.15,
++	minClosure: 75, # kt
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16VSMode, F16LRSMode, F16RWSMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		subMode.superMode = mode;
++		subMode.shortName = mode.shortName;
++		return mode;
++	},
++	frameCompleted: func {
++		if (me.lastFrameStart != -1 and me.discSpeed_dps == me.discSpeed_alert_dps) {
++			# Its max around 11.5 secs for alert scan
++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
++			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
++		}
++		me.lastFrameStart = me.radar.elapsed;
++		if (me.discSpeed_dps == me.discSpeed_alert_dps) {
++			me.discSpeed_dps = me.discSpeed_confirm_dps;
++		} elsif (me.discSpeed_dps == me.discSpeed_confirm_dps) {
++			me.discSpeed_dps = me.discSpeed_alert_dps;
++		}
++	},
++	designate: func (designate_contact) {
++		if (designate_contact == nil) return;
++		me.radar.setCurrentMode(me.subMode, designate_contact);
++		me.subMode.radar = me.radar;# find some smarter way of setting it.
++		me.radar.registerBlep(designate_contact, designate_contact.getDeviationStored(), 0);
++	},
++	designatePriority: func {
++		# NOP
++	},
++	undesignate: func {
++		# NOP
++	},
++	preStep: func {
++		me.elevationTilt = me.radar.getTiltKnob();
++		var dev_tilt_deg = me.cursorAz;
++		if (me.az == 60) {
++			dev_tilt_deg = 0;
++		}
++		me.azimuthTilt = dev_tilt_deg;
++		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
++		}
++	},
++	increaseRange: func {
++		#me._increaseRange();
++	},
++	decreaseRange: func {
++		#me._decreaseRange();
++	},
++	showRangeOptions: func {
++		return 0;
++	},
++	setRange: func {# Range is always 160 in VS
++		return 0;
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		#print(me.currentTracked,"   ",(me.radar.elapsed - contact.blepTime));
++		if (((me.radar.elapsed - contact.getLastBlepTime()) < me.maxScanIntervalForVelocity) and contact.getLastClosureRate() > 0) {
++			#print("VELOCITY");
++			return [0,0,1,1,1,0];
++		}
++		#print("  EMPTY");
++		return [0,0,0,0,1,0];
++	},
++	getCursorAltitudeLimits: func {
++		return nil;
++	},
++};
++
++
++
++
++
++
++
++#  ████████ ██     ██ ███████ 
++#     ██    ██     ██ ██      
++#     ██    ██  █  ██ ███████ 
++#     ██    ██ ███ ██      ██ 
++#     ██     ███ ███  ███████ 
++#                             
++#
++var F16TWSMode = {
++	radar: nil,
++	shortName: "TWS",
++	longName: "Track While Scan",
++	superMode: nil,
++	subMode: nil,
++	maxRange: 80,
++	discSpeed_dps: 50, # source: https://www.youtube.com/watch?v=Aq5HXTGUHGI
++	rcsFactor: 0.9,
++	timeToBlinkTracks: 8,# GR1F-16CJ-34-1-1
++	maxScanIntervalForTrack: 6.5,# authentic for TWS
++	priorityTarget: nil,
++	currentTracked: [],
++	maxTracked: 10,
++	az: 25,# slow scan, so default is 25 to get those double taps in there.
++	bars: 3,# default is less due to need 2 scans of target to get groundtrack
++	EXPsupport: 1,#if support zoom
++	EXPsearch: 0,# if zoom should include search targets
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16TWSMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		subMode.superMode = mode;
++		subMode.shortName = mode.shortName;
++		return mode;
++	},
++	cycleAZ: func {
++		if (me.az == 10) {
++			me.az = 25;
++		} elsif (me.az == 25 and me.priorityTarget == nil) {
++			me.az = 60;
++		} elsif (me.az == 25) {
++			me.az = 10;
++		} elsif (me.az == 60) {
++			me.az = 10;
++		}
++	},
++	cycleBars: func {
++		me.bars += 1;
++		if (me.priorityTarget != nil and me.bars > 3) {
++			me.bars = 2;
++		}
++		if (me.bars == 5) me.bars = 2;# bars:1 not available in TWS
++		me.nextPatternNode = 0;
++	},
++	designate: func (designate_contact) {
++		if (designate_contact != nil) {
++			me.radar.setCurrentMode(me.subMode, designate_contact);
++			me.subMode.radar = me.radar;# find some smarter way of setting it.
++		} else {
++			me.priorityTarget = nil;
++		}
++	},
++	designatePriority: func (contact) {
++		me.priorityTarget = contact;
++		if (contact != nil) {
++			# With a target of interest (TOI), AZ is not allowed to be 60
++			# Source MLU Tape 1:
++			me.bars = math.min(3, me.bars);
++			me.az = math.min(25, me.az);
++		}
++	},
++	getPriority: func {
++		return me.priorityTarget;
++	},
++	undesignate: func {
++		me.priorityTarget = nil;
++	},
++	preStep: func {
++	 	me.azimuthTilt = me.cursorAz;
++	 	me.elevationTilt = me.radar.getTiltKnob();
++		if (me.priorityTarget != nil) {
++			if (!size(me.priorityTarget.getBleps()) or me.priorityTarget.getLastRangeDirect() == nil or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget) or me.radar.elapsed - me.priorityTarget.getLastBlepTime() > me.radar.timeToKeepBleps) {
++				me.priorityTarget = nil;
++				me.undesignate();
++				return;
++			}
++			me.prioRange_nm = me.priorityTarget.getLastRangeDirect()*M2NM;
++			me.lastBlep = me.priorityTarget.getLastBlep();
++			if (me.lastBlep != nil) {
++				me.centerTilt = me.lastBlep.getAZDeviation();
++				if (me.centerTilt > me.azimuthTilt+me.az) {
++					me.azimuthTilt = me.centerTilt-me.az;
++				} elsif (me.centerTilt < me.azimuthTilt-me.az) {
++					me.azimuthTilt = me.centerTilt+me.az;
++				}
++				me.elevationTilt = me.lastBlep.getElev();
++			} else {
++				me.priorityTarget = nil;
++				me.undesignate();
++				return;
++			}
++			if (me.prioRange_nm < 0.40 * me.getRange()) {
++				me._decreaseRange();
++			} elsif (me.prioRange_nm > 0.90 * me.getRange()) {
++				me._increaseRange();
++			} elsif (me.prioRange_nm < 3) {
++				# auto go to STT when target is very close
++				me.designate(me.priorityTarget);
++			}
++			# Source MLU Tape 1:
++			me.bars = math.min(3, me.bars);
++			me.az = math.min(25, me.az);
++		} else {
++			me.undesignate();
++		}
++		me.constrainAz();
++	},
++	frameCompleted: func {
++		if (me.lastFrameStart != -1) {
++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
++		}
++		me.lastFrameStart = me.radar.elapsed;
++	},
++	enterMode: func {
++		me.currentTracked = [];
++		foreach(c;me.radar.vector_aicontacts_bleps) {
++			c.ignoreTrackInfo();# Kind of a hack to make it give out false info. Bypasses hadTrackInfo() but not hasTrackInfo().
++		}
++	},
++	leaveMode: func {
++		me.priorityTarget = nil;
++		me.lastFrameStart = -1;
++	},
++	increaseRange: func {
++		if (me.priorityTarget != nil) return 0;
++		me._increaseRange();
++	},
++	decreaseRange: func {
++		if (me.priorityTarget != nil) return 0;
++		me._decreaseRange();
++	},
++	showRangeOptions: func {
++		if (me.priorityTarget != nil) return 0;
++		return 1;
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		#print(me.currentTracked,"   ",(me.radar.elapsed - contact.blepTime));
++		me.scanInterval = (me.radar.elapsed - contact.getLastBlepTime()) < me.maxScanIntervalForTrack;
++		me.isInCurrent = me.radar.containsVectorContact(me.currentTracked, contact);
++		if (size(me.currentTracked) < me.maxTracked and me.scanInterval) {
++			#print("  TWICE    ",me.radar.elapsed);
++			#print(me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, contact),"   ",me.radar.elapsed - contact.blepTime);
++			if (!me.isInCurrent) append(me.currentTracked, contact);
++			return [1,1,1,1,1,1];
++		} elsif (me.isInCurrent and me.scanInterval) {
++			return [1,1,1,1,1,1];
++		} elsif (me.isInCurrent) {
++			me.tmp = [];
++			foreach (me.cc ; me.currentTracked) {
++				if(!me.cc.equals(contact)) {
++					append(me.tmp, me.cc);
++				}
++			}
++			me.currentTracked = me.tmp;
++		}
++		#print("  ONCE    ",me.currentTracked);
++		return [1,0,1,0,0,1];
++	},
++	prunedContact: func (c) {
++		if (c.equals(me.priorityTarget)) {
++			me.priorityTarget = nil;# this might have fixed the nil exception
++		}
++		if (c.hadTrackInfo()) {
++			me.del = me.radar.containsVectorContact(me.currentTracked, c);
++			if (me.del) {
++				me.tmp = [];
++				foreach (me.cc ; me.currentTracked) {
++					if(!me.cc.equals(c)) {
++						append(me.tmp, me.cc);
++					}
++				}
++				me.currentTracked = me.tmp;
++			}
++		}
++	},
++	testContact: func (contact) {
++		#if (me.radar.elapsed - contact.getLastBlepTime() > me.maxScanIntervalForTrack and contact.azi == 1) {
++		#	contact.azi = 0;
++		#	me.currentTracked -= 1;
++		#}
++	},
++	cycleDesignate: func {
++		if (!size(me.radar.vector_aicontacts_bleps)) {
++			me.priorityTarget = nil;
++			return;
++		}
++		if (me.priorityTarget == nil) {
++			me.testIndex = -1;
++		} else {
++			me.testIndex = me.radar.vectorIndex(me.radar.vector_aicontacts_bleps, me.priorityTarget);
++		}
++		for(me.i = me.testIndex+1;me.i<size(me.radar.vector_aicontacts_bleps);me.i+=1) {
++			#if (me.radar.vector_aicontacts_bleps[me.i].hadTrackInfo()) {
++				me.priorityTarget = me.radar.vector_aicontacts_bleps[me.i];
++				return;
++			#}
++		}
++		for(me.i = 0;me.i<=me.testIndex;me.i+=1) {
++			#if (me.radar.vector_aicontacts_bleps[me.i].hadTrackInfo()) {
++				me.priorityTarget = me.radar.vector_aicontacts_bleps[me.i];
++				return;
++			#}
++		}
++	},
++};
++
++
++
++
++#  ██████  ██     ██ ███████       ███████  █████  ███    ███ 
++#  ██   ██ ██     ██ ██            ██      ██   ██ ████  ████ 
++#  ██████  ██  █  ██ ███████ █████ ███████ ███████ ██ ████ ██ 
++#  ██   ██ ██ ███ ██      ██            ██ ██   ██ ██  ██  ██ 
++#  ██   ██  ███ ███  ███████       ███████ ██   ██ ██      ██ 
++#                                                             
++#
++var F16RWSSAMMode = {
++	radar: nil,
++	shortName: "RWS",
++	longName: "Range While Search - Situational Awareness Mode",
++	superMode: nil,
++	discSpeed_dps: 65,
++	rcsFactor: 0.9,
++	maxRange: 160,
++	priorityTarget: nil,
++	bars: 2,
++	azMFD: 60,
++	new: func (subMode = nil, radar = nil) {
++		var mode = {parents: [F16RWSSAMMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		if (subMode != nil) {
++			subMode.superMode = mode;
++			subMode.radar = radar;
++			subMode.shortName = mode.shortName;
++		}
++		return mode;
++	},
++	calcSAMwidth: func {
++		if (me.prioRange_nm<30) return math.min(60,18 + 2.066667*me.prioRange_nm - 0.02222222*me.prioRange_nm*me.prioRange_nm);
++		else return 60;
++	},
++	preStep: func {
++		me.azimuthTilt = me.cursorAz;
++		me.elevationTilt = me.radar.getTiltKnob();
++		if (me.priorityTarget != nil) {
++			# azimuth width is autocalculated in F16 AUTO-SAM:
++			if (!size(me.priorityTarget.getBleps()) or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget)) {
++				me.priorityTarget = nil;
++				me.undesignate();
++				return;
++			}
++			me.prioRange_nm = me.priorityTarget.getRangeDirect()*M2NM;
++			me.az = math.min(me.calcSAMwidth(), me.azMFD);#GR1F-16CJ-34-1-1 page 1-125
++			me.lastBlep = me.priorityTarget.getLastBlep();
++			if (me.lastBlep != nil) {
++				if (math.abs(me.azimuthTilt - (me.lastBlep.getAZDeviation())) > me.az) {
++					me.scanPriorityEveryFrame = 1;
++				} else {
++					me.scanPriorityEveryFrame = 0; # due to the overlap not being perfect, scan the designation extra, just to be safe
++				}
++				me.elevationTilt = me.lastBlep.getElev();
++			} else {
++				me.priorityTarget = nil;
++				me.undesignate();
++				return;
++			}
++			if (me.prioRange_nm < 0.40 * me.getRange()) {
++				me._decreaseRange();
++			} elsif (me.prioRange_nm > 0.90 * me.getRange()) {
++				me._increaseRange();
++			} elsif (me.prioRange_nm < 3) {
++				# auto go to STT when target is very close
++				me.designate(me.priorityTarget);
++			}
++		} else {
++			me.scanPriorityEveryFrame = 0;
++			me.undesignate();
++		}
++		me.constrainAz();
++	},
++	undesignate: func {
++		me.priorityTarget = nil;
++		me.radar.setCurrentMode(me.superMode, nil);
++	},
++	designate: func (designate_contact) {
++		if (designate_contact == nil) return;
++		if (designate_contact.equals(me.priorityTarget)) {
++			me.radar.setCurrentMode(me.subMode, designate_contact);
++			me.subMode.radar = me.radar;# find some smarter way of setting it.
++		} else {
++			me.priorityTarget = designate_contact;
++		}
++	},
++	designatePriority: func (contact) {
++		me.priorityTarget = contact;
++	},
++	cycleBars: func {
++		me.bars += 1;
++		if (me.bars == 3) me.bars = 4;# 3 is only for TWS
++		elsif (me.bars == 5) me.bars = 1;
++		me.nextPatternNode = 0;
++	},
++	cycleAZ: func {
++		if (me.azMFD == 10) me.azMFD = 30;
++		elsif (me.azMFD == 30) me.azMFD = 60;
++		elsif (me.azMFD == 60) me.azMFD = 10;
++	},
++	getAz: func {
++		return me.azMFD;
++	},
++	increaseRange: func {# Range is auto-set in RWS-SAM
++		return 0;
++	},
++	decreaseRange: func {# Range is auto-set in RWS-SAM
++		return 0;
++	},
++	setRange: func {# Range is auto-set in RWS-SAM
++	},
++	leaveMode: func {
++		me.priorityTarget = nil;
++		me.lastFrameStart = -1;
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		if (me.priorityTarget != nil and contact.equals(me.priorityTarget)) {
++			return [1,1,1,1,1,1];
++		}
++		return [1,0,1,0,0,1];
++	},
++	showRangeOptions: func {
++		return 0;
++	},
++	showAZ: func {
++		return 1;
++	},
++};
++
++
++#  ██      ██████  ███████       ███████  █████  ███    ███ 
++#  ██      ██   ██ ██            ██      ██   ██ ████  ████ 
++#  ██      ██████  ███████ █████ ███████ ███████ ██ ████ ██ 
++#  ██      ██   ██      ██            ██ ██   ██ ██  ██  ██ 
++#  ███████ ██   ██ ███████       ███████ ██   ██ ██      ██ 
++#                                                           
++#
++var F16LRSSAMMode = {
++	shortName: "LRS",
++	longName: "Long Range Search - Situational Awareness Mode",
++	discSpeed_dps: 45,
++	rcsFactor: 1,
++	new: func (subMode = nil, radar = nil) {
++		var mode = {parents: [F16LRSSAMMode, F16RWSSAMMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		if (subMode != nil) {
++			subMode.superMode = mode;
++			subMode.radar = radar;
++			subMode.shortName = mode.shortName;
++		}
++		return mode;
++	},
++	showAZ: func {
++		return 1;
++	},
++	calcSAMwidth: func {
++		if (me.prioRange_nm<42) return math.min(60,18 + 1.4*me.prioRange_nm - 0.01*me.prioRange_nm*me.prioRange_nm);
++		else return 60;
++	},
++};
++
++
++
++#   █████   ██████ ███    ███ 
++#  ██   ██ ██      ████  ████ 
++#  ███████ ██      ██ ████ ██ 
++#  ██   ██ ██      ██  ██  ██ 
++#  ██   ██  ██████ ██      ██ 
++#                             
++#
++var F16ACMMode = {#TODO
++	radar: nil,
++	rootName: "ACM",
++	shortName: "STBY",
++	longName: "Air Combat Mode Standby",
++	superMode: nil,
++	subMode: nil,
++	range: 10,
++	maxRange: 10,
++	discSpeed_dps: 84.6,# have reliable source for this.
++	rcsFactor: 0.9,
++	timeToFadeBleps: 1,
++	bars: 1,
++	az: 1,
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16ACMMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		mode.subMode.superMode = mode;
++		mode.subMode.shortName = mode.shortName;
++		return mode;
++	},
++	showBars: func {
++		return 0;
++	},
++	showAZinHSD: func {
++		return 0;
++	},
++	cycleAZ: func {	},
++	cycleBars: func { },
++	designate: func (designate_contact) {
++	},
++	designatePriority: func (contact) {
++
++	},
++	getPriority: func {
++		return nil;
++	},
++	undesignate: func {
++	},
++	preStep: func {
++	},
++	increaseRange: func {
++		return 0;
++	},
++	decreaseRange: func {
++		return 0;
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		return nil;
++	},
++	testContact: func (contact) {
++	},
++	cycleDesignate: func {
++	},
++};
++
++var F16ACM20Mode = {
++	radar: nil,
++	rootName: "ACM",
++	shortName: "20",
++	longName: "Air Combat Mode 30x20",
++	superMode: nil,
++	subMode: nil,
++	range: 10,
++	minRange: 10,
++	maxRange: 10,
++	discSpeed_dps: 84.6,
++	rcsFactor: 0.9,
++	timeToFadeBleps: 1,# TODO
++	bars: 1,
++	barPattern: [ [[1,-7],[1,3],[-1,3],[-1,1],[1,1],[1,-1],[-1,-1],[-1,-3],[1,-3],[1,-5],[-1,-5],[-1,-7]] ],
++	az: 15,
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16ACM20Mode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		mode.subMode.superMode = mode;
++		mode.subMode.shortName = mode.shortName;
++		return mode;
++	},
++	showBars: func {
++		return 0;
++	},
++	showAZinHSD: func {
++		return 0;
++	},
++	cycleAZ: func {	},
++	cycleBars: func { },
++	designate: func (designate_contact) {
++		if (designate_contact == nil) {
++			acmLockSound.setBoolValue(0);
++			return;
++		}
++		acmLockSound.setBoolValue(1);
++		me.radar.setCurrentMode(me.subMode, designate_contact);
++		me.subMode.radar = me.radar;
++	},
++	designatePriority: func (contact) {
++	},
++	getPriority: func {
++		return nil;
++	},
++	undesignate: func {
++	},
++	preStep: func {
++		me.radar.horizonStabilized = 0;
++		me.elevationTilt = -3;
++	},
++	increaseRange: func {
++		return 0;
++	},
++	decreaseRange: func {
++		return 0;
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		me.designate(contact);
++		return [1,1,1,1,1,1];
++	},
++	testContact: func (contact) {
++	},
++	cycleDesignate: func {
++	},
++	getCursorAltitudeLimits: func {
++		return nil;
++	},
++};
++
++var F16ACM60Mode = {
++	radar: nil,
++	rootName: "ACM",
++	shortName: "60",
++	longName: "Air Combat Mode 10x60",
++	superMode: nil,
++	subMode: nil,
++	maxRange: 10,
++	discSpeed_dps: 84.6,
++	rcsFactor: 0.9,
++	bars: 1,
++	barHeight: 1.0/APG68.instantFoVradius,# multiple of instantFoV (in this case 1 deg)
++	az: 5,
++	barPattern:  [ [[-0.6,-5],[0.0,-5],[0.0, 51],[0.6,51],[0.6,-5],[0.0,-5],[0.0,51],[-0.6,51]], ],
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16ACM60Mode, F16ACM20Mode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		mode.subMode.superMode = mode;
++		mode.subMode.shortName = mode.shortName;
++		return mode;
++	},
++	preStep: func {
++		me.radar.horizonStabilized = 0;
++		me.elevationTilt = 0;
++	},
++};
++
++var F16ACMBoreMode = {
++	radar: nil,
++	rootName: "ACM",
++	shortName: "BORE",
++	longName: "Air Combat Mode Bore",
++	bars: 1,
++	barHeight: 1.0,# multiple of instantFoV (in this case 1 deg)
++	az: 0,
++	barPattern:  [ [[0.0,-1]], ],
++	new: func (subMode, radar = nil) {
++		var mode = {parents: [F16ACMBoreMode, F16ACM20Mode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		mode.subMode = subMode;
++		mode.subMode.superMode = mode;
++		mode.subMode.shortName = mode.shortName;
++		return mode;
++	},
++	preStep: func {
++		me.radar.horizonStabilized = 0;
++		me.elevationTilt = -me.radar.instantFoVradius;
++		me.azimuthTilt = 0;
++		if (getprop("payload/armament/hmd-active") == 1) {
++			me.azimuthTilt = math.clamp(getprop("payload/armament/hmd-horiz-deg"),-60,60);
++			me.elevationTilt = math.clamp(getprop("payload/armament/hmd-vert-deg"),-60,60);
++		}
++	},
++	step: func (dt) {
++		me.preStep();
++		me.localDirHMD = vector.Math.pitchYawVector(me.elevationTilt, -me.azimuthTilt, [1,0,0]);
++		me.angleToHMD = vector.Math.angleBetweenVectors(me.radar.positionDirection, me.localDirHMD);
++		me.maxMove = math.min(me.angleToHMD, me.discSpeed_dps*dt);
++		if (me.angleToHMD < 0.1) {
++			me.radar.setAntennae(me.localDirHMD);
++			me.lastFrameDuration = 0;
++			return 0;
++		}
++		# Great circle movement to reach the bore spot
++		me.newPos = vector.Math.rotateVectorTowardsVector(me.radar.positionDirection, me.localDirHMD, me.maxMove);
++		me.radar.setAntennae(me.newPos);
++		return dt-me.maxMove/me.discSpeed_dps;
++	},
++};
++
++
++
++
++#  ███████ ████████ ████████ 
++#  ██         ██       ██    
++#  ███████    ██       ██ 
++#       ██    ██       ██ 
++#  ███████    ██       ██ 
++#                         
++#
++var F16STTMode = {
++	radar: nil,
++	shortName: "STT",
++	longName: "Single Target Track",
++	superMode: nil,
++	discSpeed_dps: 80,
++	rcsFactor: 1,
++	maxRange: 160,
++	priorityTarget: nil,
++	az: APG68.instantFoVradius*0.8,
++	barHeight: 0.90,# multiple of instantFoVradius
++	bars: 2,
++	minimumTimePerReturn: 0.10,
++	timeToFadeBleps: 13, # Need to have time to move disc to the selection from wherever it was before entering STT. Plus already faded bleps from superMode will get pruned if this is to low.
++	debug: 1,
++	painter: 1,
++	debug: 0,
++	new: func (radar = nil) {
++		var mode = {parents: [F16STTMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		return mode;
++	},
++	showAZ: func {
++		return 0;
++	},
++	showAZinHSD: func {
++		return 0;
++	},
++	showBars: func {
++		return me.superMode.showBars();
++	},
++	showRangeOptions: func {
++		return 0;
++	},
++	getBars: func {
++		return me.superMode.getBars();
++	},
++	getAz: func {
++		# We return the parents mode AZ and bars in this class, so they are shown in radar display as B4 A4 etc etc.
++		return me.superMode.getAz();
++	},
++	preStep: func {
++		me.debug = getprop("debug-radar/debug-stt");
++		if (me.priorityTarget != nil and size(me.priorityTarget.getBleps())) {
++			me.lastBlep = me.priorityTarget.getLastBlep();
++			if (me.debug > 0) {
++				setprop("debug-radar/STT-bleps", size(me.priorityTarget.getBleps()));
++			}
++			if (me.lastBlep != nil) {
++				me.azimuthTilt = me.lastBlep.getAZDeviation();
++				me.elevationTilt = me.lastBlep.getElev(); # tilt here is in relation to horizon
++			} else {
++				me.priorityTarget = nil;
++				me.undesignate();
++				return;
++			}
++			if (!size(me.priorityTarget.getBleps()) or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget)) {
++				me.priorityTarget = nil;
++				me.undesignate();
++				return;
++			} elsif (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
++				me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
++			} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
++				me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
++			}
++			if (me.priorityTarget.getRangeDirect()*M2NM < 0.40 * me.getRange()) {
++				me._decreaseRange();
++			}
++			if (me.priorityTarget.getRangeDirect()*M2NM > 0.90 * me.getRange()) {
++				me._increaseRange();
++			}
++			if (me.debug > 0) {
++				setprop("debug-radar/STT-focused", me.priorityTarget.get_Callsign());
++			}
++		} else {
++			if (me.debug > 0) {
++				setprop("debug-radar/STT-focused", "--none--");
++			}
++			if (me.debug > 0) {
++				setprop("debug-radar/STT-bleps", -1);
++			}
++			me.priorityTarget = nil;
++			me.undesignate();
++		}
++	},
++	designatePriority: func (prio) {
++		me.priorityTarget = prio;
++	},
++	undesignate: func {
++		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
++		me.priorityTarget = nil;
++		#var log = caller(1); foreach (l;log) print(l);
++	},
++	designate: func {},
++	cycleBars: func {},
++	cycleAZ: func {},
++	increaseRange: func {# Range is auto-set in STT
++		return 0;
++	},
++	decreaseRange: func {# Range is auto-set in STT
++		return 0;
++	},
++	setRange: func {# Range is auto-set in STT
++	},
++	frameCompleted: func {
++		if (me.lastFrameStart != -1) {
++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
++			#me.timeToFadeBleps = math.max(2, me.radar.targetHistory*me.lastFrameDuration);
++		}
++		me.lastFrameStart = me.radar.elapsed;
++	},
++	leaveMode: func {
++		me.priorityTarget = nil;
++		me.lastFrameStart = -1;
++		me.timeToFadeBleps = 13;# Reset to 5, since getSearchInfo might have lowered it.
++	},
++	getSearchInfo: func (contact) {
++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
++		if (me.priorityTarget != nil and contact.equals(me.priorityTarget)) {
++			me.timeToFadeBleps = 1.5;
++			return [1,1,1,1,1,1];
++		}
++		return nil;
++	},
++	getCursorAltitudeLimits: func {
++		return nil;
++	},
++};
++
++var F16ACMSTTMode = {
++	rootName: "ACM",
++	shortName: "STT",
++	longName: "Air Combat Mode - Single Target Track",
++	new: func (radar = nil) {
++		var mode = {parents: [F16ACMSTTMode, F16STTMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		return mode;
++	},
++	designatePriority: func (prio) {
++		me.priorityTarget = prio;
++		if (prio != nil) acmLockSound.setBoolValue(1);
++	},
++	undesignate: func {
++		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
++		me.priorityTarget = nil;
++		acmLockSound.setBoolValue(0);
++	},
++};
++
++var F16MultiSTTMode = {
++	rootName: "CRM",
++	shortName: "STT",
++	longName: "Multisearch - Single Target Track",
++	new: func (radar = nil) {
++		var mode = {parents: [F16MultiSTTMode, F16STTMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		return mode;
++	},
++	undesignate: func {
++		if (me.priorityTarget != nil and me.priorityTarget.getRangeDirect()*M2NM < 3) {
++			me.priorityTarget = nil;
++		}
++		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
++		me.priorityTarget = nil;
++		#var log = caller(1); foreach (l;log) print(l);
++	},
++};
++
++
++#  ███████ ████████ ████████ 
++#  ██         ██       ██    
++#  █████      ██       ██ 
++#  ██         ██       ██ 
++#  ██         ██       ██ 
++#                         
++#
++var F16SEAFTTMode = {
++	rootName: "",
++	shortName: "FTT",
++	longName: "SEA Mode - Fixed Target Track",
++	maxRange: 80,
++	detectAIR: 0,
++	detectSURFACE: 0,
++	detectMARINE: 1,
++	pulse: MONO,
++	minimumTimePerReturn: 0.20,
++	new: func (radar = nil) {
++		var mode = {parents: [F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		return mode;
++	},
++};
++
++var F16GMFTTMode = {
++	longName: "Ground Map Mode - Fixed Target Track",
++	detectSURFACE: 1,
++	detectMARINE: 0,
++	mapper: 1,
++	new: func (radar = nil) {
++		var mode = {parents: [F16GMFTTMode, F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		return mode;
++	},
++	getPriority: func {
++		if (me.priorityTarget == nil or (rand() > 0.95 and me.priorityTarget.getSpeed() < 11)) {
++			return me.priorityTarget;
++		} else {
++			return me.priorityTarget.getNearbyVirtualContact(60);
++		}
++	},
++};
++
++var F16GMTFTTMode = {
++	longName: "Ground Moving Target - Fixed Target Track",
++	detectSURFACE: 1,
++	detectMARINE: 0,
++	new: func (radar = nil) {
++		var mode = {parents: [F16GMTFTTMode, F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
++		mode.radar = radar;
++		return mode;
++	},
++};
++
++
++
++
++
++
++
++
++
++
++
++
++
++#  ███████        ██  ██████      ██████  ██     ██ ██████ 
++#  ██            ███ ██           ██   ██ ██     ██ ██   ██ 
++#  █████   █████  ██ ███████      ██████  ██  █  ██ ██████  
++#  ██             ██ ██    ██     ██   ██ ██ ███ ██ ██   ██ 
++#  ██             ██  ██████      ██   ██  ███ ███  ██   ██ 
++#                                                           
++#
++
++var noRadarList = {
++	# These have no radar
++	depot:nil, point:nil, struct:nil, rig:nil, truck:nil, hunter:nil,
++	"alphajet":nil, "jaguar":nil, "Jaguar-GR3":nil, "A-10-modelB":nil, "Jaguar-GR1":nil, "A-10-model":nil, "A-10":nil, "G91-R1B":nil, "G91":nil, "g91":nil, "mb339":nil, "mb339pan":nil,
++};
++
++var RWR = {
++	# inherits from Radar
++	# will check radar/transponder and ground occlusion.
++	# will sort according to threat level
++	new: func () {
++		var rr = {parents: [RWR, Radar]};
++
++		rr.vector_aicontacts = [];
++		rr.vector_aicontacts_threats = [];
++		#rr.timer          = maketimer(2, rr, func rr.scan());
++
++		rr.RWRRecipient = emesary.Recipient.new("RWRRecipient");
++		rr.RWRRecipient.radar = rr;
++		rr.RWRRecipient.Receive = func(notification) {
++	        if (notification.NotificationType == "OmniNotification") {
++	        	#printf("RWR recv: %s", notification.NotificationType);
++	            if (me.radar.enabled == 1) {
++	    		    me.radar.vector_aicontacts = notification.vector;
++	    		    me.radar.scan();
++	    	    }
++	            return emesary.Transmitter.ReceiptStatus_OK;
++	        }
++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
++	    };
++		emesary.GlobalTransmitter.Register(rr.RWRRecipient);
++		rr.RWRNotification = VectorNotification.new("RWRNotification");
++		rr.RWRNotification.updateV(rr.vector_aicontacts_threats);
++		#rr.timer.start();
++		return rr;
++	},
++	heatDefense: 0,
++	scan: func {
++		# sort in threat?
++		# run by notification
++		# mock up code, ultra simple threat index, is just here cause rwr have special needs:
++		# 1) It has almost no range restriction
++		# 2) Its omnidirectional
++		# 3) It might have to update fast (like 0.25 secs)
++		# 4) To build a proper threat index it needs at least these properties read:
++		#       model type
++		#       class (AIR/SURFACE/MARINE)
++		#       lock on myself
++		#       missile launch
++		#       transponder on/off
++		#       bearing and heading
++		#       IFF info
++		#       ECM
++		#       radar on/off
++		if (!getprop("instrumentation/rwr/serviceable") or getprop("f16/avionics/power-ufc-warm") != 1 or getprop("f16/ews/ew-rwr-switch") != 1) {
++            setprop("sound/rwr-lck", 0);
++            setprop("ai/submodels/submodel[0]/flare-auto-release-cmd", 0);
++            return;
++        }
++        me.vector_aicontacts_threats = [];
++		me.fct = 10*2.0;
++        me.myCallsign = self.getCallsign();
++        me.myCallsign = size(me.myCallsign) < 8 ? me.myCallsign : left(me.myCallsign,7);
++        me.act_lck = 0;
++        me.autoFlare = 0;
++        me.closestThreat = 0;
++        me.elapsed = elapsedProp.getValue();
++        foreach(me.u ; me.vector_aicontacts) {
++        	# [me.ber,me.head,contact.getCoord(),me.tp,me.radar,contact.getDeviationHeading(),contact.getRangeDirect()*M2NM, contact.getCallsign()]
++        	me.threatDB = me.u.getThreatStored();
++            me.cs = me.threatDB[7];
++            me.rn = me.threatDB[6];
++            if ((me.u["blue"] != nil and me.u.blue == 1 and !me.threatDB[10]) or me.rn > 150) {
++                continue;
++            }
++            me.bearing = me.threatDB[0];
++            me.trAct = me.threatDB[3];
++            me.show = 1;
++            me.heading = me.threatDB[1];
++            me.inv_bearing =  me.bearing+180;#bearing from target to me
++            me.deviation = me.inv_bearing - me.heading;# bearing deviation from target to me
++            me.dev = math.abs(geo.normdeg180(me.deviation));# my degrees from opponents nose
++
++            if (me.show == 1) {
++                if (me.dev < 30 and me.rn < 7 and me.threatDB[8] > 60) {
++                    # he is in position to fire heatseeker at me
++                    me.heatDefenseNow = me.elapsed + me.rn*1.5;
++                    if (me.heatDefenseNow > me.heatDefense) {
++                        me.heatDefense = me.heatDefenseNow;
++                    }
++                }
++                me.threat = 0;
++                if (me.u.getModel() != "missile_frigate" and me.u.getModel() != "S-75" and me.u.getModel() != "SA-6" and me.u.getModel() != "buk-m2" and me.u.getModel() != "MIM104D" and me.u.getModel() != "s-200" and me.u.getModel() != "s-300" and me.u.getModel() != "fleet" and me.u.getModel() != "ZSU-23-4M") {
++                    me.threat += ((180-me.dev)/180)*0.30;# most threat if I am in front of his nose
++                    me.spd = (60-me.threatDB[8])/60;
++                    #me.threat -= me.spd>0?me.spd:0;# if his speed is lower than 60kt then give him minus threat else positive
++                } elsif (me.u.getModel() == "missile_frigate" or me.u.getModel() == "fleet") {
++                    me.threat += 0.30;
++                } else {
++                    me.threat += 0.30;
++                }
++                me.danger = 50;# within this range he is most dangerous
++                if (me.u.getModel() == "missile_frigate" or me.u.getModel() == "fleet" or me.u.getModel() == "s-300") {
++                    me.danger = 80;
++                } elsif (me.u.getModel() == "buk-m2" or me.u.getModel() == "S-75") {
++                    me.danger = 35;
++                } elsif (me.u.getModel() == "SA-6") {
++                    me.danger = 15;
++                } elsif (me.u.getModel() == "s-200") {
++                    me.danger = 150;
++                } elsif (me.u.getModel() == "MIM104D") {
++                    me.danger = 45;
++                } elsif (me.u.getModel() == "ZSU-23-4M") {
++                    me.danger = 7.5;
++                }
++                if (me.threatDB[10]) me.threat += 0.30;# has me locked
++                me.threat += ((me.danger-me.rn)/me.danger)>0?((me.danger-me.rn)/me.danger)*0.60:0;# if inside danger zone then add threat, the closer the more.
++                me.threat += me.threatDB[9]>0?(me.threatDB[9]/500)*0.10:0;# more closing speed means more threat.
++                if (me.u.getModel() == "AI") me.threat = 0.01;
++                if (contains(noRadarList, me.u.getModel())) me.threat = - 1;
++                if (me.threat > me.closestThreat) me.closestThreat = me.threat;
++                #printf("A %s threat:%.2f range:%d dev:%d", me.u.get_Callsign(),me.threat,me.u.get_range(),me.deviation);
++                if (me.threat > 1) me.threat = 1;
++                if (me.threat <= 0) continue;
++                #printf("B %s threat:%.2f range:%d dev:%d", me.u.get_Callsign(),me.threat,me.u.get_range(),me.deviation);
++                append(me.vector_aicontacts_threats,[me.u,me.threat, me.threatDB[5]]);
++            } else {
++#                printf("%s ----", me.u.get_Callsign());
++            }
++        }
++
++        me.launchClose = getprop("payload/armament/MLW-launcher") != "";
++        me.incoming = getprop("payload/armament/MAW-active") or getprop("payload/armament/MAW-semiactive") or me.heatDefense > me.elapsed;
++        me.spike = 0;#getprop("payload/armament/spike")*(getprop("ai/submodels/submodel[0]/count")>15);
++        me.autoFlare = me.spike?math.max(me.closestThreat*0.25,0.05):0;
++
++        if (0 and getprop("f16/ews/ew-mode-knob") == 2)
++        	print("wow: ", getprop("/fdm/jsbsim/gear/unit[0]/WOW"),"  spiked: ",me.spike,"  incoming: ",me.incoming, "  launch: ",me.launchClose,"  spikeResult:", me.autoFlare,"  aggresive:",me.launchClose * 0.85 + me.incoming * 0.85,"  total:",me.launchClose * 0.85 + me.incoming * 0.85+me.autoFlare);
++
++        me.autoFlare += me.launchClose * 0.85 + me.incoming * 0.85;
++
++        me.autoFlare *= 0.1 * 2.5 * !getprop("/fdm/jsbsim/gear/unit[0]/WOW");#0.1 being the update rate for flare dropping code.
++
++        setprop("ai/submodels/submodel[0]/flare-auto-release-cmd", me.autoFlare * (getprop("ai/submodels/submodel[0]/count")>0));
++        if (me.autoFlare > 0.80 and rand()>0.99 and getprop("ai/submodels/submodel[0]/count") < 1) {
++            setprop("ai/submodels/submodel[0]/flare-release-out-snd", 1);
++        }
++        emesary.GlobalTransmitter.NotifyAll(me.RWRNotification.updateV(me.vector_aicontacts_threats));
++	},
++	del: func {
++        emesary.GlobalTransmitter.DeRegister(me.RWRRecipient);
++    },
++};
++
++
++
++var radiation_list = {
++	"buk-m2": "11",
++    "s-300": "20",
++    "s-200": "5",
++    "S-75": "2",
++    "missile_frigate": "SH",
++    "fleet": "SH",
++    "SA-6": "6",
++    "MIM104D": "P",
++    "ZSU-23-4M": "AAA",
++    "gci": "S",
++    "A-50": "S",
++    "EC-137R": "S",
++    "E-3": "S",
++    "E-3R": "S",
++};
++
++var RadSensor = {
++	# inherits from Radar
++	new: func () {
++		var rs = {parents: [RadSensor, Radar]};
++
++		rs.vector_aicontacts = [];
++		rs.vector_aicontacts_seen = [];
++
++		rs.RadSensorRecipient = emesary.Recipient.new("RadSensorRecipient");
++		rs.RadSensorRecipient.radar = rs;
++		rs.RadSensorRecipient.Receive = func(notification) {
++	        if (notification.NotificationType == "OmniNotification") {
++	        	#printf("RadSensor recv: %s", notification.NotificationType);
++	            if (me.radar.enabled == 1) {
++	    		    me.radar.vector_aicontacts = notification.vector;
++	    	    }
++	            return emesary.Transmitter.ReceiptStatus_OK;
++	        }
++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
++	    };
++		emesary.GlobalTransmitter.Register(rs.RadSensorRecipient);
++		rs.timer          = maketimer(0.05, rs, func rs.scan());
++		rs.timer.singleShot = 1;
++		rs.enabled = 0;
++		return rs;
++	},
++	range: 40,
++	area: 10,
++	maxArea: 20,
++	maxDura: 90,
++	dura: 60,
++	searchTime: 0,
++	searchStart: 0,
++	index: -1,
++	timing: 0.05,
++	table: [],
++    tables: [["2","11","20","P","S"],["6","5"],["AAA","SH"]],
++	currtable: 0,
++	handoffTarget: nil,
++	handoffTime: 0,
++	searchCounter: 0,
++	x: [-40, 40],
++	y: [-40, 10],
++	fov: 0,
++	fov_desired: 0,
++	setEnabled: func (e) {
++		me.enabled = e;
++		if (e and !me.timer.isRunning) {
++			me.calcDura();
++        	me.timing = 0.05;
++        	me.timer.restart(me.timing);
++			me.timer.start();
++			me.searchStart = elapsedProp.getValue();
++
++			#print("setEnabled again");
++		} elsif (!e) {
++			me.timer.stop();
++			me.reset();
++		}
++	},
++	reset: func {
++		me.searchTime = 0;
++		me.searchStart = elapsedProp.getValue();
++		foreach(me.seen;me.vector_aicontacts_seen) {
++    		me.seen.discover = 0;
++    		me.seen.discoverSCT = -2;
++    	}
++		me.vector_aicontacts_seen = [];
++		me.calcDura();
++    	me.timing = 0.05;
++	},
++	calcDura: func {
++		me.dura = me.maxDura * me.area/me.maxArea * size(me.table)/5;
++	},
++	scan: func {
++		if (!me.enabled) {
++			foreach(me.seen;me.vector_aicontacts_seen) {
++        		me.seen.discover = 0;
++        		me.seen.discoverSCT = -2;
++        	}
++            me.vector_aicontacts_seen = [];
++            return;
++        }
++        me.elapsed = elapsedProp.getValue();
++
++        me.searchTime = me.elapsed-me.searchStart;
++        if (me.searchTime > me.dura) {
++        	me.index = -1;
++        	me.searchStart = me.elapsed;
++        	me.searchCounter += 1;
++        	me.searchTime = 0;
++        	#print("finished search");
++        }
++
++        if (me.index >= size(me.vector_aicontacts)-1) {
++        	me.index = -1;
++        }
++        if (!size(me.vector_aicontacts)) {
++        	foreach(me.seen;me.vector_aicontacts_seen) {
++        		me.seen.discover = 0;
++        		me.seen.discoverSCT = -2;
++        	}
++        	me.vector_aicontacts_seen = [];
++        	me.timer.restart(me.timing);
++	        if (!me.timer.isRunning) {
++	        	me.timer.start();
++	        }
++        	return;
++        }
++        me.index += 1;
++
++        me.candidate = me.vector_aicontacts[me.index];
++        #print(size(me.vector_aicontacts)," me.candidate.rd is nil: ",me.candidate["isRadiating"]==nil);
++        me.candidateModel = me.candidate.getModel();
++        if (contains(radiation_list, me.candidateModel)) {
++	        me.ownCoord = self.getCoord();
++	        me.myHeading = radar_system.self.getHeading();
++	        me.ok = 0;
++	        if (me.candidate.isRadiating(me.ownCoord)) {
++	        	me.testBearing = me.candidate.getBearing();
++	            me.testElevation = me.candidate.getElevation();
++	            me.testDev = geo.normdeg180(me.testBearing-me.myHeading);
++	            if (me.testDev > me.x[0] and me.testDev < me.x[1] and me.candidate.get_range() < me.range) {
++		            if (me.testElevation < me.y[1] and me.testElevation > me.y[0]) {
++	    	            me.candidate.radiSpike = me.candidate.isSpikingMe()?"T":"A";
++	    	            me.candidate.pos = [me.testDev, me.testElevation];
++	    	            me.candidate.mdl = radiation_list[me.candidateModel];
++
++	                    for (me.i = 0; me.i < size(me.table);me.i+=1) {
++	                        me.tableitem = me.table[me.i];
++	                        if (me.candidate.mdl == me.tableitem) {
++	                            me.ok = 1;
++	                            me.candidate.tblIdx = me.i;
++	                            if (me.candidate["discoverSCT"] != me.searchCounter) {# If we have seen this contact before in this cycle we don't recalc its discover time
++	                            	me.candidate.discover = me.dura*rand();
++	                            	me.candidate.discoverSCT = me.searchCounter;
++	                            }
++	                            break;
++	                        }
++	                    }
++	                    if (me.ok) {
++	                    	if (!me.containsVector(me.vector_aicontacts_seen, me.candidate)) {
++	                    		append(me.vector_aicontacts_seen, me.candidate);
++	                    		#print("Sensor: seen ",me.candidate.mdl,", planning reveal at ",int(me.dura-me.candidate.discover));
++	                    	}
++	                    }
++	    	        }
++	            }
++	        }
++	        if (!me.ok and me.containsVector(me.vector_aicontacts_seen, me.candidate)) {
++	        	#print("Sensor: unseen ",me.candidate.mdl);
++	        	me.temp = [];
++	        	foreach(me.seen;me.vector_aicontacts_seen) {
++	        		if (me.seen == me.candidate) continue;
++	        		append(me.temp,me.seen);
++	        	}
++	        	me.vector_aicontacts_seen = me.temp;
++	        }
++	    }
++        me.calcDura();
++        me.timing = 2/size(me.vector_aicontacts);# Expect there to be 1 to 100 contacts. The last ones in the vector should also be able to show up in the first seconds.
++        me.timing = math.clamp(me.timing, 0.01, 0.15);
++        #printf("dura %.3f  size %d  sleep %.3f",me.dura,size(me.vector_aicontacts),0.95*me.dura/size(me.vector_aicontacts));
++        me.timer.restart(me.timing);
++        if (!me.timer.isRunning) {
++        	me.timer.start();
++        }
++	},
++	containsVector: func (vec, item) {
++		foreach(test; vec) {
++			if (test == item) {
++				return 1;
++			}
++		}
++		return 0;
++	},
++	del: func {
++        emesary.GlobalTransmitter.DeRegister(me.RadSensorRecipient);
++    },
++};
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++#   ██████  ██████   ██████  ██    ██ ███    ██ ██████      ███    ███  █████  ██████  ██████  ███████ ██████
++#  ██       ██   ██ ██    ██ ██    ██ ████   ██ ██   ██     ████  ████ ██   ██ ██   ██ ██   ██ ██      ██   ██
++#  ██   ███ ██████  ██    ██ ██    ██ ██ ██  ██ ██   ██     ██ ████ ██ ███████ ██████  ██████  █████   ██████
++#  ██    ██ ██   ██ ██    ██ ██    ██ ██  ██ ██ ██   ██     ██  ██  ██ ██   ██ ██      ██      ██      ██   ██
++#   ██████  ██   ██  ██████   ██████  ██   ████ ██████      ██      ██ ██   ██ ██      ██      ███████ ██   ██
++#
++#
++var TerrainMapper = {
++	new: func (radar, rate) {
++		var tm = {parents: [TerrainMapper, Radar]};
++		tm.radar = radar;
++		tm.timer = maketimer(rate, tm, func tm.loop());
++		tm.timer.start();
++		radar.installMapper(tm);
++		tm.lowestElev = 0;
++		tm.highestElev = 5000;
++		tm.minElev = 35000;
++		tm.maxElev = 0;
++		tm.cleaned = 0;
++		tm.exp = 0;
++		tm.debug = 0;
++		tm.t_geo = 0;
++		tm.t_pix = 0;
++		return tm;
++	},
++	##################################################################################################
++	##################################################################################################
++	#
++	# TODO:
++	#   Remove image painting from this class
++	#   EXP mode
++	#   Optimize
++	#   Find reason for failing Coord._lat
++	#   Pixel rounding error review (fills too few x)
++	#
++	azData: {
++				radius: nil,
++				az: 0,
++				fromDist: nil,
++				toDist: nil,
++				domainNm: nil,
++				domainFwdNm: nil,
++				rangeFwdNm: nil,
++				returns: nil,
++			},
++	scanGM: func (eulerX, eulerY, verticalInstantFoV, horizontalInstantFoV, bottomBar, topBar) {
++		# GM test code
++
++		if (me.radar.currentMode.mapper and me.enabled and me.radar.horizonStabilized and me["gmPic"] != nil and !me.exp) {
++			if (me.debug > 3) {
++				me.t0 = systime();
++			}
++			me.debug = getprop("debug-radar/debug-mapper");
++			me.mapperHeading = eulerX+self.getHeading();
++			me.discDirforGMTop = vector.Math.pitchYawVector(eulerY+verticalInstantFoV,-me.mapperHeading,[1,0,0]);
++			me.discDirforGMBot = vector.Math.pitchYawVector(eulerY-verticalInstantFoV,-me.mapperHeading,[1,0,0]);
++			if (me.debug) {
++				setprop("debug-radar/mapper-pitch-high", eulerY+verticalInstantFoV);
++				setprop("debug-radar/mapper-pitch", eulerY);
++				setprop("debug-radar/mapper-pitch-low", eulerY-verticalInstantFoV);
++			}
++
++			me.selfCoord = self.getCoord();
++
++			me.radarBeamGeoVectorTop = vector.Math.vectorToGeoVector(me.discDirforGMTop, me.selfCoord);
++			me.radarBeamGeoVectorBot = vector.Math.vectorToGeoVector(me.discDirforGMBot, me.selfCoord);
++
++			me.xyzSelf = {"x":me.selfCoord.x(), "y":me.selfCoord.y(), "z":me.selfCoord.z()};
++
++            # Check for terrain at top and bottom of radar instant FoV
++            me.terrainGeodTop = get_cart_ground_intersection(me.xyzSelf, me.radarBeamGeoVectorTop);
++            me.terrainGeodBot = get_cart_ground_intersection(me.xyzSelf, me.radarBeamGeoVectorBot);
++            #if (me.debug) {
++			#	setprop("debug-radar/mapper-last-deg", math.abs(eulerX-me.azData.az));
++			#}
++            me.azData.az = eulerX;
++            me.azData.radius = horizontalInstantFoV;
++            me.azData.returns = [];
++            if (me.terrainGeodBot != nil) {
++            	me.terrainCoordBot = geo.Coord.new().set_latlon(me.terrainGeodBot.lat, me.terrainGeodBot.lon, me.terrainGeodBot.elevation);
++            	me.azData.fromDist = me.selfCoord.distance_to(me.terrainCoordBot)*M2NM;
++            	if (!me.testRange(me.azData.fromDist, me.radar.getRange(), me.azData.az)) return;
++            	if (me.terrainGeodTop != nil) {
++            		me.terrainCoordTop = geo.Coord.new().set_latlon(me.terrainGeodTop.lat, me.terrainGeodTop.lon, me.terrainGeodTop.elevation);
++            		if (me.debug) {
++						setprop("debug-radar/mapper-domain-lost-nm", "works");
++					}
++            	} else {
++            		# The upper part of this instantFoV does not hit terrain here. So we manually add a little bit.
++            		me.terrainCoordTop = geo.Coord.new(me.terrainCoordBot);
++            		if (me.azData.domainNm != nil) {
++            			me.topRange = me.azData.domainNm;
++            		} else {
++            			me.topRange = me.radar.getRange() * 1.25 - me.azData.fromDist;
++            		}
++            		me.topRange = math.max(me.topRange, 15);
++            		if (me.debug) {
++						setprop("debug-radar/mapper-domain-lost-nm", me.topRange);
++					}
++            		me.terrainCoordTop.apply_course_distance(me.mapperHeading, me.topRange*NM2M);
++            	}
++            	me.azData.toDist = me.selfCoord.distance_to(me.terrainCoordTop)*M2NM;
++            	me.azData.domainNm = me.azData.toDist-me.azData.fromDist;
++            	me.azCos = math.cos(me.azData.az*D2R);
++            	me.azData.rangeFwdNm = me.azData.fromDist*me.azCos;
++            	me.azData.domainFwdNm = me.azData.domainNm*me.azCos;
++            	me.pixelsBetweenTopAndBot = math.ceil(me.gmPicSize*me.azData.domainFwdNm/me.radar.getRange());
++				me.maskAlt  = 0;
++				me.maskStep = -1;
++
++				# Amount each step changes in altitude meters for center of beam.
++				# Curvature of earth is negliable.
++				# Each steps has different angle in reality, but its minute.
++				me.maskAltPerStep = math.tan(eulerY*D2R)*NM2M*me.azData.domainNm/me.pixelsBetweenTopAndBot;
++
++            	for (var i = 0; i <= me.pixelsBetweenTopAndBot; i += 1) {
++            		me.testCoord = me.interpolateCoords(me.terrainCoordBot, me.terrainCoordTop, i/me.pixelsBetweenTopAndBot);
++            		me.gm_geod = geodinfo(me.testCoord.lat(), me.testCoord.lon(), 10000);
++            		if (debug.isnan(me.testCoord._lat)) {
++            			#print("self ",me.selfCoord._lat);
++            			print("test ",me.testCoord._lat," , ",me.testCoord.lat()," , ",me.testCoord.alt());
++            			#print("bot  ",me.terrainCoordBot._x," , ",me.terrainCoordBot._y," , ",me.terrainCoordBot._z,"  ,  ",me.terrainGeodBot.elevation*M2FT);
++            			#print(i);
++            			append(me.azData.returns, 0);
++            			continue;
++            		}
++            		me.gmReturn = 0;
++            		if (me.gm_geod != nil) {
++            			if (me.gm_geod[0] > me.maskAlt+(i - me.maskStep)*me.maskAltPerStep) {
++            				# Terrain not masked by previous terrain
++            				me.maskAlt = me.gm_geod[0];
++            				me.maskStep = i;
++            				me.gmReturn = me.backScatter(me.gm_geod);
++            			} else {
++            				me.gmReturn = -1;
++            			}
++            		} else {
++            			me.gmReturn = -2;
++            		}
++            		append(me.azData.returns, me.gmReturn);
++            	}
++            	#me.debugOutput();
++            	if (me.debug > 3) {
++            		me.t1 = systime();
++            	}
++            	me.paintImage(me.azData, bottomBar, topBar);
++            	if (me.debug > 3) {
++	            	me.t2 = systime();
++	            	me.t_geo += me.t1-me.t0;
++	            	me.t_pix += me.t2-me.t1;
++	            }
++            }
++            if (me.dirty) {
++            	me.gmPic.dirtyPixels();
++            	me.dirty = 0;
++            }
++		}
++	},
++	setImage: func (image, origin_x, origin_y, dimension, monochrome, gainNode) {
++		if (me["gmPic"] == nil) {
++			#me.canvas = canvas.Window.new([512,512],"dialog").set('title',"GM").getCanvas(1);
++			#me.canvas_root = me.canvas.createGroup();
++			#me.canvas.setColorBackground(0,0,0,1);
++			me.gainNode = gainNode;
++			me.gmPic = image;
++            me.dirty = 0;
++            me.gmPicSize  = dimension;
++            me.mono = monochrome;
++            me.gm_x_origin = origin_x;
++            me.gm_y_origin = origin_y;
++            #me.gmPic.setPixel(me.gm_x_origin, me.gm_y_origin, [0,0,1,1]);#blue pixel at ownship
++            return 1;
++		} else {
++			return 0;
++		}
++	},
++	paintImage: func (azData, bottomBar, topBar) {
++
++		me.iStart = math.floor(me.gmPicSize*azData.rangeFwdNm/me.radar.getRange());
++
++		if (me.debug) {
++			setprop("debug-radar/mapper-steps", size(azData.returns));
++			setprop("debug-radar/mapper-domain-fwd-nm", azData.domainFwdNm);
++		}
++
++		# If top or bottom or only 1 bar, pad ahead/behind with nil. This will clear old returns on screen.
++		if (bottomBar and me.iStart > 0) {
++			azData.returns = setsize([], me.iStart) ~ azData.returns;
++			me.iStart = 0;
++		}
++		me.behindPad = (int)((1-me.azData.rangeFwdNm/me.radar.getRange())*me.gmPicSize*1.3);
++		if (topBar and me.behindPad > 0) {
++			azData.returns = azData.returns ~ setsize([], me.behindPad);
++		}
++
++		me.jStart = math.tan((azData.az-azData.radius)*D2R);
++		me.jMid   = math.tan(azData.az*D2R);
++		me.jEnd   = math.tan((azData.az+azData.radius)*D2R);
++		me.jFactor = me.jEnd-me.jStart;
++
++		#me.firstY = 0;
++		#me.firstX = 0;
++
++		for (var i = 0; i < size(azData.returns); i+=1 ) {
++			me.debugColor = nil;
++			if (me.debug > 2) {
++				if (azData.returns[i] == nil) {
++					me.debugColor = [0,0,1,1];# Blue for not hit by FoV
++				} elsif (azData.returns[i] == -1) {
++					me.debugColor = [1,1,0,1];# Yellow for terrain masked
++				} elsif (azData.returns[i] == -2) {
++					me.debugColor = [1,0,0,1];# Red for terrasunk
++				} else {
++					me.gmColor = math.pow(math.clamp(azData.returns[i],0,1), me.gainNode.getValue());
++				}
++			} else {
++				me.gmColor = azData.returns[i]==nil?0:math.pow(math.clamp(azData.returns[i],0,1), me.gainNode.getValue());
++			}
++
++			me.gmY  = me.gm_y_origin+me.iStart+i;
++			me.gmX  = math.floor(me.gm_x_origin+me.jMid*(i+me.iStart));
++			me.gmX0 = me.gm_x_origin+me.jStart*(i+me.iStart);
++			me.gmXj = math.round(me.gmX0+(i+me.iStart)*me.jFactor-0.5);
++			me.gmX0 = math.min(me.gmX, math.round(me.gmX0));
++			#if (me.firstY == 0) {
++			#	me.firstY = math.max(me.gmY, 0)-me.gm_y_origin;
++			#	me.firstX = me.gmXj;
++			#}
++			for (var j = me.gmX0; j <= me.gmXj; j += 1) {
++				if (j >= 0 and j <= me.gmPicSize-1 and me.gmY <= me.gmPicSize-1) {
++					me.gmPic.setPixel(j, math.max(me.gmY, 0), me.debugColor==nil?[me.gmColor*me.mono,me.gmColor,me.gmColor*me.mono,1]:me.debugColor);
++					me.dirty = 1;
++				}
++			}
++		}
++		#if (bottomBar and me.firstY != 0) {
++		#	# Clear the field below the bottom bar as we might have risen in alitude so its old data shown closer to ownship that can confuse pilot.
++		#	for (var y = me.firstY-1; y >= 0; y-=1 ) {
++		#		#var x = math.clamp(me.gm_x_origin + (y/me.firstY) * me.firstX, 0, 63);
++		#		if (me.firstX > 31)    {me.gmPic.setPixel(me.firstX,   y, [0,0,0,1]);me.gmPic.setPixel(me.firstX-1, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX-2, y, [0,0,0,1]);}
++		#		elsif (me.firstX < 31) {me.gmPic.setPixel(me.firstX+1, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX+2, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX+3, y, [0,0,0,1]);}
++		#		else                    me.gmPic.setPixel(me.firstX,   y, [0,0,0,1]);
++		#	}
++		#}
++	},
++	expChanged: func (exp) {
++		if (me["gmPic"] == nil or exp == me.exp) return;
++		me.exp = exp;
++		if (me.exp) {
++			me.gmPic.fillRect([0,0,me.gmPicSize,me.gmPicSize], [0.0*me.mono,0.0,0.0*me.mono,0]);# why does it allow 64??
++			me.gmPic.dirtyPixels();
++			me.dirty = 0;
++		} else {
++			me.cleanImage();
++		}
++	},
++	cleanImage: func {
++		if (me["gmPic"] == nil) return;
++		me.gmPic.fillRect([0,0,me.gmPicSize,me.gmPicSize], [0,0,0,0]);# why does it allow 64??
++		#me.gmPic.setPixel(me.gm_x_origin, me.gm_y_origin, [0,0,1,1]);#blue pixel at ownship
++		me.dirty = 1;
++	},
++	loop: func {
++		if (me.enabled and me.radar.currentMode.mapper and me["gmPic"] != nil and me.dirty) {
++			me.gmPic.dirtyPixels();
++		}
++		if (!me.radar.enabled and !me.cleaned) {
++			me.cleanImage();
++			me.cleaned = 1;
++		} else {
++			me.cleaned = 0;
++		}
++		if (me.debug > 3) {
++			printf("geo=%8.6f pix=%8.6f",me.t_geo, me.t_pix);
++			me.t_geo = 0;
++			me.t_pix = 0;
++		}
++	},
++	clear: func {
++		#me.lowestElev = 0;
++		#me.highestElev = 1000*math.ceil(getprop("position/ground-elev-ft")*0.001);
++		#me.minElev = 35000;
++		#me.maxElev = 0;
++		me.cleanImage();
++	},
++	testRange: func (range, maxRange, az) {
++		if (range > maxRange) {
++			return 0;
++		}
++		az = math.abs(az)*D2R;
++		if (math.sin(az)*range > maxRange*0.5) {
++			return 0;
++		}
++		return 1;
++	},
++	debugOutput: func {
++		if (me.radar.currentMode.bars == 4 and me.radar.currentMode["nextPatternNode"] != nil) {
++        	if (me.radar.currentMode.nextPatternNode == 0) {
++        		me.barCount = "4th";
++        	} elsif (me.radar.currentMode.nextPatternNode == 1) {
++        		me.barCount = "   ";return;
++        	} elsif (me.radar.currentMode.nextPatternNode == 2) {
++        		me.barCount = "1st";
++        	} elsif (me.radar.currentMode.nextPatternNode == 3) {
++        		me.barCount = "   ";return;
++        	} elsif (me.radar.currentMode.nextPatternNode == 4) {
++        		me.barCount = "2nd";
++        	} elsif (me.radar.currentMode.nextPatternNode == 5) {
++        		me.barCount = "   ";return;
++        	} elsif (me.radar.currentMode.nextPatternNode == 6) {
++        		me.barCount = "3rd";
++        	} elsif (me.radar.currentMode.nextPatternNode == 7) {
++        		me.barCount = "   ";return;
++        	} else {
++        		me.barCount = "Unk";return;
++        	}
++        	printf("AGL %5dft. Bar %s. Distance to bottom %.1fnm. Bottom to top %6.2fnm. Pitch %5.2f to %5.2f degs",getprop("position/altitude-agl-ft"), me.barCount, me.selfCoord.direct_distance_to(me.terrainCoordBot)*M2NM, me.terrainCoordBot.direct_distance_to(me.terrainCoordTop)*M2NM,me.eulerY-me.radar.instantFoVradius,me.radar.eulerY+me.radar.instantFoVradius);
++        }
++	},
++	backScatter: func (gm_geod) {
++		if (gm_geod == nil) {
++			me.reflection = 0;
++		} else {
++			if (gm_geod[1] == nil) {
++				me.reflection = 1;
++			} elsif (!gm_geod[1].solid) {
++				me.reflection = 0.05;
++				if (me.gm_geod[0] != nil) {
++					me.testElev = me.gm_geod[0]*M2FT;
++					if (me.testElev < me.minElev) {
++						me.minElev = me.testElev;
++					}
++				}
++			} else {
++				me.retur = me.howReflective(gm_geod[1]);
++				if (me.retur == 0) {
++					me.retur = gm_geod[1].bumpiness;
++				}
++				me.testElev = me.gm_geod[0]*M2FT;
++				if (me.testElev < me.minElev) {
++					me.minElev = me.testElev;
++				}
++				if (me.testElev > me.maxElev) {
++					me.maxElev = me.testElev;
++				}
++				me.reflection = math.min(1, me.extrapolate(me.testElev, me.lowestElev, me.highestElev, 0.15, 0.6)+me.retur*0.4);
++			}
++		}
++		return me.reflection;
++	},
++	frameDone: func {
++		if (me.minElev != 35000 or me.maxElev != 0) {
++			me.highestElev = (me.highestElev*1.5+me.maxElev)/2.5;# a simple lowpass filter to prevent it from changing too abrupt.
++			me.lowestElev = (me.lowestElev*1.5+math.max(0, math.min(me.maxElev-1000, me.minElev)))/2.5;# prevent somewhat flat terrain to show as very undulated.
++		}
++		if (me.debug) setprop("debug-radar/mapper-elevation-min", me.lowestElev);
++		if (me.debug) setprop("debug-radar/mapper-elevation-max", me.highestElev);
++
++		me.minElev = 35000;
++		me.maxElev = 0;
++	},
++	howReflective: func(info) {
++		# from AJS-37
++	    foreach (var name; info.names) {
++	        if (contains(me.urban_names, name)) return 1;
++	    }
++	    foreach (var name; info.names) {
++	        if (contains(me.natural_names, name)) return me.natural_names[name];
++	    }
++    	return 0;
++    },
++    urban_names: {
++		# from AJS-37
++	    "Urban": 1,
++	    "BuiltUpCover": 1,
++	    "Construction": 1,
++	    "Industrial": 1,
++	    "Port": 1,
++	    "Town": 1,
++	    "SubUrban": 1,
++	},
++	natural_names: {
++		# TODO: find more real data on this. Best source so far: AP3456 – 11-x - Radar
++	    "Cliffs": 0.8,  # tend to be steep, hence greater return
++	    "Asphalt": 0.7, # very granular hence good backscatter
++	    "Airport": 0.5, #
++	    "Rock": 0.6,    # tend to be somewhat steep, hence some solid backscatter
++	    "RainForest": 0.35,
++	    "MixedForest": 0.35,# wood does very little backscatter, but trees are upright, so good opportunity for specular return
++	    "AgroForest": 0.25,
++	    "SnowCover": 0.2,   # snow is very diffuse, hence very little backscatter
++	    "PolarIce": 0.4,
++	    "PackIce": 0.25,    # very smooth like the water it formed on, hence little return
++	    "Glacier": 0.5,
++	},
++	interpolateCoords: func (start, end, fraction) {
++		if (fraction == 0) {
++			return geo.Coord.new(start);
++		}
++		if (fraction == 1) return geo.Coord.new(end);
++		me.xx = (start.x()*(1-fraction)+end.x()*fraction);
++		me.yy = (start.y()*(1-fraction)+end.y()*fraction);
++		me.zz = (start.z()*(1-fraction)+end.z()*fraction);
++
++		me.cc = geo.Coord.new();
++		me.cc.set_xyz(me.xx,me.yy,me.zz);
++
++		return me.cc;
++	},
++	extrapolate: func (x, x1, x2, y1, y2) {
++    	return y1 + ((x - x1) / (x2 - x1)) * (y2 - y1);
++	},
++	##################################################################################################
++	##################################################################################################
++	##################################################################################################
++	##################################################################################################
++};
++
++
++
++
++
++
++
++
++
++
++#  ████████  ██████  ██████      ██████   ██████  ██ ███    ██ ████████
++#     ██    ██       ██   ██     ██   ██ ██    ██ ██ ████   ██    ██
++#     ██    ██   ███ ██████      ██████  ██    ██ ██ ██ ██  ██    ██
++#     ██    ██    ██ ██          ██      ██    ██ ██ ██  ██ ██    ██
++#     ██     ██████  ██          ██       ██████  ██ ██   ████    ██
++#
++#
++var ContactTGP = {
++	new: func(callsign, coord, laser = 1) {
++		var obj             = { parents : [ContactTGP, Contact]};# in real OO class this should inherit from Contact, but in nasal it does not need to
++		obj.coord           = geo.Coord.new(coord);
++		#obj.coord.set_alt(coord.alt()+1);#avoid z fighting
++		obj.callsign        = callsign;
++		obj.unique          = rand();
++
++		obj.tacobj = {parents: [tacview.tacobj]};
++		obj.tacobj.tacviewID = right((obj.unique~""),5);
++		obj.tacobj.valid = 1;
++
++		obj.laser = laser;
++		return obj;
++	},
++
++	isValid: func () {
++		return 1;
++	},
++
++	isVirtual: func () {
++		return 1;
++	},
++
++	getVirtualType: func {
++		# Used to debug issue #532
++		return "tgp-ground";
++	},
++
++	isPainted: func () {
++		return 0;
++	},
++
++	isLaserPainted: func{
++		return getprop("controls/armament/laser-arm-dmd") and me.laser;
++	},
++
++	isRadiating: func (c) {
++		return 0;
++	},
++
++	getUnique: func () {
++		return me.unique;
++	},
++
++	getElevation: func() {
++		#var e = 0;
++		var selfPos = geo.aircraft_position();
++		#var angleInv = ja37.clamp(self.distance_to(me.coord)/self.direct_distance_to(me.coord), -1, 1);
++		#e = (self.alt()>me.coord.alt()?-1:1)*math.acos(angleInv)*R2D;
++		return vector.Math.getPitch(selfPos, me.coord);
++	},
++
++	getFlareNode: func () {
++		return nil;
++	},
++
++	getChaffNode: func () {
++		return nil;
++	},
++
++	get_Coord: func() {
++		return me.coord;
++	},
++
++	getCoord: func {
++		return me.get_Coord();
++	},
++
++	getETA: func {
++		return nil;
++	},
++
++	getHitChance: func {
++		return nil;
++	},
++
++	get_Callsign: func(){
++		return me.callsign;
++	},
++
++	getModel: func(){
++		return "TGP spot";
++	},
++
++	get_Speed: func(){
++		# return true airspeed
++		return 0;
++	},
++
++	get_uBody: func {
++		return 0;
++	},
++	get_vBody: func {
++		return 0;
++	},
++	get_wBody: func {
++		return 0;
++	},
++
++	get_Longitude: func(){
++		var n = me.coord.lon();
++		return n;
++	},
++
++	get_Latitude: func(){
++		var n = me.coord.lat();
++		return n;
++	},
++
++	get_Pitch: func(){
++		return 0;
++	},
++
++	get_Roll: func(){
++		return 0;
++	},
++
++	get_heading : func(){
++		return 0;
++	},
++
++	get_bearing: func(){
++		var n = me.get_bearing_from_Coord(geo.aircraft_position());
++		return n;
++	},
++
++	get_relative_bearing : func() {
++		return geo.normdeg180(me.get_bearing()-getprop("orientation/heading-deg"));
++	},
++
++	getLastAZDeviation : func() {
++		return me.get_relative_bearing();
++	},
++
++	get_altitude: func(){
++		#Return Alt in feet
++		return me.coord.alt()*M2FT;
++	},
++
++	get_Longitude: func {
++		return me.coord.lon()*M2FT;
++	},
++	get_Latitude: func {
++		return me.coord.lat();
++	},
++
++	get_range: func() {
++		var r = me.coord.direct_distance_to(geo.aircraft_position()) * M2NM;
++		return r;
++	},
++
++	get_type: func () {
++		return armament.POINT;
++	},
++
++	get_bearing_from_Coord: func(MyAircraftCoord){
++		var myBearing = 0;
++		if(me.coord.is_defined()) {
++			myBearing = MyAircraftCoord.course_to(me.coord);
++		}
++		return myBearing;
++	},
++};
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++var scanInterval = 0.05;# 20hz for main radar
++
++
++laserOn = props.globals.getNode("controls/armament/laser-arm-dmd",1);#don't put 'var' keyword in front of this.
++var datalink_power = props.globals.getNode("instrumentation/datalink/power",0);
++enable_tacobject = 1;
++var antennae_knob_prop = props.globals.getNode("controls/radar/antennae-knob",0);
++var wndprop = props.globals.getNode("environment/wind-speed-kt",0);
++
++
++# start generic radar system
++var baser = AIToNasal.new();
++var partitioner = NoseRadar.new();
++var omni = OmniRadar.new(1.0, 150, -1);
++var terrain = TerrainChecker.new(0.05, 1, 30);# 0.05 or 0.10 is fine here
++var callsignToContact = CallsignToContact.new();
++var dlnkRadar = DatalinkRadar.new(0.03, 110, 225);# 3 seconds because cannot be too slow for DLINK targets
++var ecm = ECMChecker.new(0.05, 6);
++
++# start specific radar system
++var rwsMode = F16RWSMode.new(F16RWSSAMMode.new(F16MultiSTTMode.new()));
++var twsMode = F16TWSMode.new(F16MultiSTTMode.new());
++var lrsMode = F16LRSMode.new(F16LRSSAMMode.new(F16MultiSTTMode.new()));
++var vsMode = F16VSMode.new(F16STTMode.new());
++var acm20Mode = F16ACM20Mode.new(F16ACMSTTMode.new());
++var acm60Mode = F16ACM60Mode.new(F16ACMSTTMode.new());
++var acmBoreMode = F16ACMBoreMode.new(F16ACMSTTMode.new());
++var seaMode = F16SeaMode.new(F16SEAFTTMode.new());
++var gmMode = F16GMMode.new(F16GMFTTMode.new());
++var gmtMode = F16GMTMode.new(F16GMTFTTMode.new());
++var apg68Radar = AirborneRadar.newAirborne([[rwsMode,twsMode,lrsMode,vsMode],[acm20Mode,acm60Mode,acmBoreMode],[seaMode],[gmMode],[gmtMode]], APG68);
++var f16_rwr = RWR.new();
++var f16_radSensor = RadSensor.new();
++var acmLockSound = props.globals.getNode("f16/sound/acm-lock");
++var mapper = TerrainMapper.new(apg68Radar, 0.50);
++
++
++
++
++var getCompleteList = func {
++	return baser.vector_aicontacts_last;
++}
++
++
++
++
++
++# BUGS:
++#   HSD radar arc CW vs. CCW
++#
++# TODO:
++#   VS switch speed at each bar instead of each frame
++#
+diff --git a/Nasal/Radar/radar-system.nas b/Nasal/Radar/radar-system.nas
+index 69d91c8..e304976 100644
+--- a/Nasal/Radar/radar-system.nas
++++ b/Nasal/Radar/radar-system.nas
+@@ -111,12 +111,12 @@ var RequestFullNotification = {
+ };
+ 
+ 
+-#  ███    ███  ██████  ██████  ███████ ██          ██████   █████  ██████  ███████ ███████ ██████ 
+-#  ████  ████ ██    ██ ██   ██ ██      ██          ██   ██ ██   ██ ██   ██ ██      ██      ██   ██ 
+-#  ██ ████ ██ ██    ██ ██   ██ █████   ██          ██████  ███████ ██████  ███████ █████   ██████  
+-#  ██  ██  ██ ██    ██ ██   ██ ██      ██          ██      ██   ██ ██   ██      ██ ██      ██   ██ 
+-#  ██      ██  ██████  ██████  ███████ ███████     ██      ██   ██ ██   ██ ███████ ███████ ██   ██ 
+-#                                                                                                  
++#  ███    ███  ██████  ██████  ███████ ██          ██████   █████  ██████  ███████ ███████ ██████ 
++#  ████  ████ ██    ██ ██   ██ ██      ██          ██   ██ ██   ██ ██   ██ ██      ██      ██   ██ 
++#  ██ ████ ██ ██    ██ ██   ██ █████   ██          ██████  ███████ ██████  ███████ █████   ██████  
++#  ██  ██  ██ ██    ██ ██   ██ ██      ██          ██      ██   ██ ██   ██      ██ ██      ██   ██ 
++#  ██      ██  ██████  ██████  ███████ ███████     ██      ██   ██ ██   ██ ███████ ███████ ██   ██ 
++#                                                                                                  
+ #
+ var AIToNasal = {
+ 	# convert AI property tree to Nasal vector
+@@ -453,12 +453,12 @@ var CallsignToContact = {
+ };
+ 
+ 
+-#   ██████  ██     ██ ███    ██ ███████ ██   ██ ██ ██████ 
+-#  ██    ██ ██     ██ ████   ██ ██      ██   ██ ██ ██   ██ 
+-#  ██    ██ ██  █  ██ ██ ██  ██ ███████ ███████ ██ ██████  
+-#  ██    ██ ██ ███ ██ ██  ██ ██      ██ ██   ██ ██ ██     
+-#   ██████   ███ ███  ██   ████ ███████ ██   ██ ██ ██ 
+-#                                                     
++#   ██████  ██     ██ ███    ██ ███████ ██   ██ ██ ██████ 
++#  ██    ██ ██     ██ ████   ██ ██      ██   ██ ██ ██   ██ 
++#  ██    ██ ██  █  ██ ██ ██  ██ ███████ ███████ ██ ██████  
++#  ██    ██ ██ ███ ██ ██  ██ ██      ██ ██   ██ ██ ██     
++#   ██████   ███ ███  ██   ████ ███████ ██   ██ ██ ██ 
++#                                                     
+ #
+ var SelfContact = {
+ 	#
+@@ -727,12 +727,12 @@ var Blep = {
+ };
+ 
+ 
+-#   ██████  ██████  ███    ██ ████████  █████   ██████ ████████ 
+-#  ██      ██    ██ ████   ██    ██    ██   ██ ██         ██    
+-#  ██      ██    ██ ██ ██  ██    ██    ███████ ██         ██ 
+-#  ██      ██    ██ ██  ██ ██    ██    ██   ██ ██         ██ 
+-#   ██████  ██████  ██   ████    ██    ██   ██  ██████    ██ 
+-#                                                            
++#   ██████  ██████  ███    ██ ████████  █████   ██████ ████████ 
++#  ██      ██    ██ ████   ██    ██    ██   ██ ██         ██    
++#  ██      ██    ██ ██ ██  ██    ██    ███████ ██         ██ 
++#  ██      ██    ██ ██  ██ ██    ██    ██   ██ ██         ██ 
++#   ██████  ██████  ██   ████    ██    ██   ██  ██████    ██ 
++#                                                            
+ #
+ var AIContact = {
+ # Attributes:
+@@ -853,7 +853,7 @@ var AIContact = {
+ 	    #
+         if (prop_name == "carrier") {
+         	return MARINE;
+-        } elsif (prop_name == "aircraft" or prop_name == "Mig-28") {
++        } elsif (prop_name == "aircraft" or prop_name == "swift" or prop_name == "Mig-28") {
+         	return AIR;
+         } elsif (ordnance != nil) {
+         	return ORDNANCE;
+@@ -1370,12 +1370,12 @@ var AIContact = {
+ 	},
+ 
+ 
+-#  ██     ██ ███████  █████  ██████   ██████  ███    ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████ 
+-#  ██     ██ ██      ██   ██ ██   ██ ██    ██ ████   ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██      
+-#  ██  █  ██ █████   ███████ ██████  ██    ██ ██ ██  ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████ 
+-#  ██ ███ ██ ██      ██   ██ ██      ██    ██ ██  ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██ 
+-#   ███ ███  ███████ ██   ██ ██       ██████  ██   ████     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████ 
+-#                                                                                                                        
++#  ██     ██ ███████  █████  ██████   ██████  ███    ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████ 
++#  ██     ██ ██      ██   ██ ██   ██ ██    ██ ████   ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██      
++#  ██  █  ██ █████   ███████ ██████  ██    ██ ██ ██  ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████ 
++#  ██ ███ ██ ██      ██   ██ ██      ██    ██ ██  ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██ 
++#   ███ ███  ███████ ██   ██ ██       ██████  ██   ████     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████ 
++#                                                                                                                        
+ #
+ 
+ 	get_type: func {
+@@ -1540,12 +1540,12 @@ var Radar = {
+ };
+ 
+ 
+-#  ██████   █████  ██████  ████████ ██ ████████ ██  ██████  ███    ██ 
+-#  ██   ██ ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ████   ██ 
+-#  ██████  ███████ ██████     ██    ██    ██    ██ ██    ██ ██ ██  ██ 
+-#  ██      ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ██  ██ ██ 
+-#  ██      ██   ██ ██   ██    ██    ██    ██    ██  ██████  ██   ████ 
+-#                                                                     
++#  ██████   █████  ██████  ████████ ██ ████████ ██  ██████  ███    ██ 
++#  ██   ██ ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ████   ██ 
++#  ██████  ███████ ██████     ██    ██    ██    ██ ██    ██ ██ ██  ██ 
++#  ██      ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ██  ██ ██ 
++#  ██      ██   ██ ██   ██    ██    ██    ██    ██  ██████  ██   ████ 
++#                                                                     
+ #
+ var NoseRadar = {
+ 	# I partition the sky into the field of regard and preserve the contacts in that field for it to be scanned by ActiveDiscRadar or similar
+@@ -2011,12 +2011,12 @@ var FullRadar = {
+ 
+ 
+ 
+-#   ██████  ███    ███ ███    ██ ██ 
+-#  ██    ██ ████  ████ ████   ██ ██ 
+-#  ██    ██ ██ ████ ██ ██ ██  ██ ██ 
+-#  ██    ██ ██  ██  ██ ██  ██ ██ ██ 
+-#   ██████  ██      ██ ██   ████ ██ 
+-#                                   
++#   ██████  ███    ███ ███    ██ ██ 
++#  ██    ██ ████  ████ ████   ██ ██ 
++#  ██    ██ ██ ████ ██ ██ ██  ██ ██ 
++#  ██    ██ ██  ██  ██ ██  ██ ██ ██ 
++#   ██████  ██      ██ ██   ████ ██ 
++#                                   
+ #
+ var OmniRadar = {
+ 	# I check the sky 360 deg for anything potentially detectable by a passive radar system.
+@@ -2057,6 +2057,9 @@ var OmniRadar = {
+ 				# This is not expensive as terrain manager set this in a loop.
+ 				continue;
+ 			}
++			if (contact.getType() == ORDNANCE) {
++				continue;
++			}
+ 			me.rangeDirectNM = contact.getRangeDirect()*M2NM;
+ 			if (me.rangeDirectNM > me.max_dist_nm) {
+ 				continue;
+@@ -2104,12 +2107,12 @@ var OmniRadar = {
+ 
+ 
+ 
+-#  ████████ ███████ ██████  ██████   █████  ██ ███    ██ 
+-#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ████   ██ 
+-#     ██    █████   ██████  ██████  ███████ ██ ██ ██  ██ 
+-#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ██  ██ ██ 
+-#     ██    ███████ ██   ██ ██   ██ ██   ██ ██ ██   ████ 
+-#                                                        
++#  ████████ ███████ ██████  ██████   █████  ██ ███    ██ 
++#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ████   ██ 
++#     ██    █████   ██████  ██████  ███████ ██ ██ ██  ██ 
++#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ██  ██ ██ 
++#     ██    ███████ ██   ██ ██   ██ ██   ██ ██ ██   ████ 
++#                                                        
+ #
+ var TerrainChecker = {
+ 	#
+@@ -2349,12 +2352,12 @@ var ECMChecker = {
+ 
+ 
+ 
+-#  ███████ ██ ██   ██ ███████ ██████      ██████  ███████  █████  ███    ███ 
+-#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ████  ████ 
+-#  █████   ██   ███   █████   ██   ██     ██████  █████   ███████ ██ ████ ██ 
+-#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ██  ██  ██ 
+-#  ██      ██ ██   ██ ███████ ██████      ██████  ███████ ██   ██ ██      ██ 
+-#                                                                            
++#  ███████ ██ ██   ██ ███████ ██████      ██████  ███████  █████  ███    ███ 
++#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ████  ████ 
++#  █████   ██   ███   █████   ██   ██     ██████  █████   ███████ ██ ████ ██ 
++#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ██  ██  ██ 
++#  ██      ██ ██   ██ ███████ ██████      ██████  ███████ ██   ██ ██      ██ 
++#                                                                            
+ #
+ var FixedBeamRadar = {
+ 
+@@ -2401,12 +2404,12 @@ var FixedBeamRadar = {
+ 
+ 
+ 
+-#   ██████  ██    ██ ███████ ██████  ██ ██████  ███████ ███████ 
+-#  ██    ██ ██    ██ ██      ██   ██ ██ ██   ██ ██      ██      
+-#  ██    ██ ██    ██ █████   ██████  ██ ██   ██ █████   ███████ 
+-#  ██    ██  ██  ██  ██      ██   ██ ██ ██   ██ ██           ██ 
+-#   ██████    ████   ███████ ██   ██ ██ ██████  ███████ ███████ 
+-#                                                               
++#   ██████  ██    ██ ███████ ██████  ██ ██████  ███████ ███████ 
++#  ██    ██ ██    ██ ██      ██   ██ ██ ██   ██ ██      ██      
++#  ██    ██ ██    ██ █████   ██████  ██ ██   ██ █████   ███████ 
++#  ██    ██  ██  ██  ██      ██   ██ ██ ██   ██ ██           ██ 
++#   ██████    ████   ███████ ██   ██ ██ ██████  ███████ ███████ 
++#                                                               
+ #
+ var flareProp = "rotors/main/blade[3]/flap-deg";
+ var chaffProp = "rotors/main/blade[3]/position-deg";
+@@ -2424,7 +2427,7 @@ var isOmniRadiating = func (model) {
+ 
+ var getRadarFieldRadius = func (model) {
+ 	# Override this method in your aircraft to do this in another way
+-	if (model == "A-50" or model == "EC-137R" or model == "E-3") {
++	if (model == "A-50" or model == "EC-137R" or model == "E-3R" or model == "E-3") {
+ 		return 180;
+ 	}
+ 	if (model == "S-75" or model == "s-200") {
+@@ -2442,6 +2445,9 @@ var getRadarFieldRadius = func (model) {
+ 	if (model == "fleet" or model == "missile-frigate") {
+ 		return 180;
+ 	}
++	if (knownSurface[model] == 0) {
++		return 0;
++	}
+ 	return 60;
+ }
+ 
+@@ -2481,6 +2487,7 @@ var knownCarriers = {
+ var knownAwacs = {
+ 	"A-50": nil,
+ 	"EC-137R": nil,
++	"E-3R": nil,
+ 	"E-3": nil,
+ };
+ 
+@@ -2495,17 +2502,18 @@ var knownShips = {
+ };
+ 
+ var knownSurface = {
++	# 0 = has no radar
+     "S-75":       nil,
+     "buk-m2":       nil,
+     "SA-6":       nil,
+     "s-300":       nil,
+     "s-200":       nil,
+-    "depot":       nil,
+-    "struct":       nil,
+-    "point":       nil,
+-    "rig":       nil,
++    "depot":       0,
++    "struct":       0,
++    "point":       0,
++    "rig":       0,
+     "gci":       nil,
+-    "truck":     nil,
++    "truck":     0,
+     "tower":     nil,
+     "MIM104D":       nil,
+     "ZSU-23-4M":       nil,
+diff --git a/Nasal/b1b.nas b/Nasal/b1b.nas
+index d7fdfc3..c57fe7f 100644
+--- a/Nasal/b1b.nas
++++ b/Nasal/b1b.nas
+@@ -908,3 +908,21 @@ var nuc = func {
+   screen.log.write(ltext);
+   }
+ }
++
++
++var vector_aicontacts_links = [];
++var DLRecipient = emesary.Recipient.new("DLRecipient");
++var startDLListener = func {
++    DLRecipient.radar = radar_system.dlnkRadar;
++    DLRecipient.Receive = func(notification) {
++        if (notification.NotificationType == "DatalinkNotification") {
++            #printf("DL recv: %s", notification.NotificationType);
++            if (me.radar.enabled == 1) {
++                vector_aicontacts_links = notification.vector;
++            }
++            return emesary.Transmitter.ReceiptStatus_OK;
++        }
++        return emesary.Transmitter.ReceiptStatus_NotProcessed;
++    };
++    emesary.GlobalTransmitter.Register(DLRecipient);
++}
+diff --git a/Nasal/data.nas b/Nasal/data.nas
+index ffbeade..9e7a6ee 100644
+--- a/Nasal/data.nas
++++ b/Nasal/data.nas
+@@ -64,6 +64,7 @@ var loadSTPTs = func (path) {
+ }
+ 
+ var syncData = func {
++    return;
+     for ( var bay = 0; bay < 3; bay = bay + 1 ) {
+         for ( var rack = 0; rack < 8; rack = rack + 1 ) {
+             weapons.wpn_info[bay][rack].lat = getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-latitude-deg");
+@@ -78,4 +79,30 @@ var syncData = func {
+     }
+ }
+ 
++var select = func (bay, rack) {
++    var t_lat = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-latitude-deg", bay, rack));
++    var t_lon = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-longitude-deg", bay, rack));
++    # t_alt = geo.elevation(t_lat, t_lon);
++    var t_alt = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-altitude", bay, rack));
++    if (t_lat < 90 and t_lat > -90 and t_lon < 180 and t_lon > -180 and pylons.fcs != nil) {
++        pylons.fcs.selectPylon(bay, rack);
++        var wp = pylons.fcs.getSelectedWeapon();
++        if (wp != nil and wp.parents[0] == armament.AIM and wp.target_pnt == 1 and (wp.guidance=="gps" or wp.guidance=="gps-altitude")) {
++            var coord = geo.Coord.new();
++            coord.set_latlon(t_lat,t_lon,t_alt);
++            var spot = radar_system.ContactTGP.new("GPS-Spot",coord,0);
++            armament.contactPoint = spot;
++            if (getprop("f16/stores/tgp-mounted") and 0) {
++                tgp.flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
++                callsign = armament.contactPoint.getUnique();
++                setprop("/aircraft/flir/target/auto-track", 1);
++                flir_updater.offsetP = 0;
++                flir_updater.offsetH = 0;
++                setprop("f16/avionics/tgp-lock", 1);
++            }
++            wp.setContacts([spot]);
++        }
++    }
++}
++
+ setprop("sim/fg-home-export", getprop("sim/fg-home")~"/Export");
+diff --git a/Nasal/datalink.nas b/Nasal/datalink.nas
+index e8ca836..7b88482 100644
+--- a/Nasal/datalink.nas
++++ b/Nasal/datalink.nas
+@@ -21,6 +21,15 @@
+ # * Optional
+ #   /instrumentation/datalink/receive_period = 1        receiving loop update rate
+ #
++# Optional: Re-define the function
++#   datalink.can_transmit(callsign, mp_prop, mp_index)
++#
++# This function should return 'true' when the given aircraft is able to transmit over datalink to us.
++# For instance, it can be used to check line of sight and maximum range.
++# The default implementation always returns true (always able to transmit).
++# Arguments are callsign, property node /ai/models/multiplayer[i], index of the former node.
++#
++#
+ # API:
+ # - get_data(callsign)
+ #     Returns all datalink information about 'callsign' as an object, or nil if there is none.
+@@ -35,9 +44,15 @@
+ # - get_connected_callsigns() / get_connected_indices()
+ #     Returns a vector containing all callsigns, resp. indices
+ #     in /ai/models/multiplayer[i], of aircrafts connected on datalink.
+-#     Both vectors use the same indices, i.e. get_connected_callsigns()[i]
++#     Both vectors use the same order, i.e. get_connected_callsigns()[i]
+ #     and get_connected_indices()[i] correspond to the same aircraft.
+-# 
++#     Furthermore this order is stable (the relative order of two aircrafts
++#     does not change as long as neither disconnects from multiplayer).
++#
++# - get_all_callsigns()
++#     Returns a vector containing all callsigns of aircraft with any associated data.
++#     There is no guarantee on the order of callsigns.
++#
+ # - send_data(data, timeout=nil)
+ #     Send data on the datalink. 'data' is a hash of the form
+ #       {
+@@ -75,6 +90,11 @@
+ #       tracked_by():       The callsign of the transmitting aircraft ("A"), or nil if tracked() is false.
+ #       tracked_by_index(): The index of the transmitting aircraft, or nil if tracked() is false.
+ #                           The index refers to property nodes /ai/models/multiplayer[i].
++#       is_known():         Equivalent to (on_link() or tracked()).
++#                           Indicates if the position of this aircraft is supposed to be known
++#                           (i.e. whether or not it should be displayed on a HSD or whatever).
++#       is_friendly():      Equivalent to (on_link() or iff() == IFF_FRIENDLY).
++#       is_hostile():       Equivalent to (!on_link() and iff() == IFF_HOSTILE).
+ #
+ ## Sending data
+ # usage: send_data({ contacts: <contacts>, ...}, ...)
+@@ -93,7 +113,7 @@
+ #
+ ## Sending data
+ # Set the identifier with send_data({"identifier": <identifier>, ...});
+-# The identifier must be a string.
++# The identifier must be a string. It must not contain '!'.
+ 
+ ### Coordinate transmission (extension name: "point")
+ #
+@@ -110,7 +130,7 @@
+ #### Protocol:
+ #
+ # Data is transmitted on MP generic string[7], with the following format:
+-#   <channel>(|<data>)+
++#   <channel>(!<data>)+
+ #
+ # <channel> is a hash of the datalink channel. See hash_channel() and check_channel_hash().
+ # Each <data> block corresponds to data sent by an extension.
+@@ -120,8 +140,9 @@
+ # Remark: '!' as separator is specifically chosen to allow encoding with emesary.Transfer<type>.
+ #
+ # The current extension prefixes are the following:
+-#   contacts: C
++#   contacts:   C
+ #   identifier: I
++#   point:      P
+ 
+ #### Extensions API
+ #
+@@ -135,7 +156,7 @@
+ #
+ # encode(data)              extension encoding function.
+ #   Must return the encoding of the extension data (i.e. <data> when calling
+-#   send_data({name: <data>})) into a string, which may use any character except '|'.
++#   send_data({name: <data>})) into a string, which may use any character except '!'.
+ #   The extension prefix must not be part of the encoded string.
+ #
+ # decode(aircrafts_data, callsign, index, string)      extension decoding function.
+@@ -158,6 +179,27 @@
+ #     unless an entry for 'callsign' already exists. Returns the modified hash.
+ 
+ 
++
++#### Version and changelog
++# current: v1.1.0, minimum compatible: v1.0.0
++#
++## v1.1.0:
++# Allow external transmission restrictions
++# Make transmitting contact IFF optional
++# Ensure personal identifier has no '!'
++# '\n' is redundant for printf()
++# Fix separator character in documentation
++# Fix error when sending unknown extension
++#
++## v1.0.1:
++# Add is_known(), is_friendly(), is_hostile() helpers to extension "contacts".
++#
++## v1.0.0: Initial version
++# - Core protocol for datalink channel.
++# - Extensions "contacts", "identifier", and "point".
++
++
++
+ ### Parameters
+ #
+ # Remark: most parameters need to be the same on all aircrafts.
+@@ -171,6 +213,11 @@ var channel_hash_period = 600;
+ 
+ var receive_period = getprop("/instrumentation/datalink/receive_period") or 1;
+ 
++# Should be overwitten to add transmission restrictions.
++var can_transmit = func(contact, mp_prop, mp_index) {
++    return 1;
++}
++
+ ### Properties
+ 
+ var input = {
+@@ -197,8 +244,7 @@ foreach (var name; keys(input)) {
+ # Channel is hashed with current time (rounded to 10min) and own callsign.
+ 
+ var clean_callsign = func(callsign) {
+-    if (size(callsign) > 7) return left(callsign, 7);
+-    else return callsign;
++    return damage.processCallsign(callsign);
+ }
+ 
+ var my_callsign = func {
+@@ -283,11 +329,11 @@ var contact_parents = [Contact];
+ 
+ var register_extension = func(name, prefix, class, encode, decode) {
+     if (contains(extensions, name)) {
+-        printf("Datalink: double registration of extension '%s'. Skipping.\n", name);
++        printf("Datalink: double registration of extension '%s'. Skipping.", name);
+         return -1;
+     }
+     if (contains(extension_prefixes, prefix)) {
+-        printf("Datalink: double registration of extension prefix '%s'. Skipping.\n", name);
++        printf("Datalink: double registration of extension prefix '%s'. Skipping.", name);
+         return -1;
+     }
+     extensions[name] = { prefix: prefix, encode: encode, decode: decode, };
+@@ -330,7 +376,8 @@ var send_data = func(data, timeout=nil) {
+     foreach(var ext; keys(data)) {
+         # Skip missing extensions with a warning
+         if (!contains(extensions, ext)) {
+-            printf("Warning: unknown datalink extension %s in send_data().\n", ext);
++            printf("Warning: unknown datalink extension %s in send_data().", ext);
++            continue;
+         }
+         str = str ~ data_separator ~ extensions[ext].prefix ~ extensions[ext].encode(data[ext]);
+     }
+@@ -380,6 +427,10 @@ var get_connected_indices = func {
+     return connected_indices;
+ }
+ 
++var get_all_callsigns = func {
++    return keys(aircrafts_data);
++}
++
+ # Helper for modifying aircrafts_data.
+ var add_if_missing = func(aircrafts_data, callsign) {
+     if (!contains(aircrafts_data, callsign)) {
+@@ -413,6 +464,10 @@ var receive_loop = func {
+         # Check channel
+         if (!check_channel(tokens[0], callsign, my_channel)) continue;
+ 
++        # We check this _after_ the channel. Checking the channel is quite cheap,
++        # and we don't know how slow this function is, it might have a get_cart_ground_intersection()
++        if (!can_transmit(callsign, mp, idx)) continue;
++
+         # Add to list of connected aircrafts.
+         append(connected_callsigns, callsign);
+         append(connected_indices, idx);
+@@ -482,7 +537,14 @@ var ContactIdentifier = {
+ 
+ var encode_identifier = func(ident) {
+     # Force string conversion
+-    return ""~ident;
++    ident = ""~ident;
++
++    if (find("!", ident) >= 0) {
++        printf("Datalink: Identifier is not allowed to contain '!': %s.", ident);
++        return "";
++    } else {
++        return ident;
++    }
+ }
+ 
+ var decode_identifier = func(aircrafts_data, callsign, str) {
+@@ -528,6 +590,15 @@ var ContactTracked = {
+     iff: func {
+         return me._iff;
+     },
++    is_known: func {
++        return me.on_link() or me.tracked();
++    },
++    is_friendly: func {
++        return me.on_link() or me.iff() == IFF_FRIENDLY;
++    },
++    is_hostile: func {
++        return !me.on_link() and me.iff() == IFF_HOSTILE;
++    },
+ };
+ 
+ # Contact encoding: callsign + bits
+@@ -539,7 +610,7 @@ var ContactTracked = {
+ 
+ var encode_contact = func(contact) {
+     # Encode bitfield
+-    var bits = contact.iff != nil ? contact.iff : IFF_UNKNOWN;
++    var bits = contact["iff"] != nil ? contact.iff : IFF_UNKNOWN;
+ 
+     return emesary.TransferString.encode(clean_callsign(contact.callsign))
+         ~ emesary.TransferByte.encode(bits);
+@@ -607,4 +678,4 @@ var decode_point = func(aircrafts_data, callsign, str) {
+     return aircrafts_data;
+ }
+ 
+-register_extension("point", "P", ContactPoint, encode_point, decode_point);
++register_extension("point", "P", ContactPoint, encode_point, decode_point);
+\ No newline at end of file
+diff --git a/Nasal/fire-control.nas b/Nasal/fire-control.nas
+index f426aab..bb08984 100644
+--- a/Nasal/fire-control.nas
++++ b/Nasal/fire-control.nas
+@@ -38,9 +38,18 @@ var FireControl = {
+ 		#setlistener("controls/armament/master-arm",func{fc.updateCurrent()},nil,0);
+ 		setlistener(masterArmSwitch,func{fc.masterArmSwitch()},nil,0);
+ 		setlistener("controls/armament/dual",func{fc.updateDual()},nil,0);
++		setlistener("sim/signals/reinit",func{fc.updateMass()},nil,0);
+ 		return fc;
+ 	},
+ 
++	updateMass: func {
++		# JSBSim seems to reset all properties under fdm/jsbsim/inertia at reinit, so we need to repopulate them.
++		foreach (var p;me.pylons) {
++			p.calculateMass();
++			p.calculateFDM();
++		}
++	},
++
+ 	cage: func (cageIt) {
+ 		foreach (var p;me.pylons) {
+ 			var ws = p.getWeapons();
+@@ -139,21 +148,21 @@ var FireControl = {
+ 		}
+ 		if (x != 0) me.setXfov(x==-1?1:0);
+ 	},
+-	
++
+ 	getDropMode: func {
+ 		#0=ccrp, 1 = ccip
+ 		me.dropMode;
+ 	},
+-	
++
+ 	setDropMode: func (mode) {
+ 		#0=ccrp, 1 = ccip
+ 		me.dropMode = mode;
+ 	},
+-	
++
+ 	getRippleMode: func {
+ 		me.ripple;
+ 	},
+-	
++
+ 	setRippleMode: func (ripple) {
+ 		if (ripple >= 1) {
+ 			me.ripple = int(ripple);
+@@ -167,11 +176,11 @@ var FireControl = {
+ 			me.rippleInterval = type;
+ 		}
+ 	},
+-	
++
+ 	getRippleDist: func {
+ 		me.rippleDist;
+ 	},
+-	
++
+ 	setRippleDist: func (rippleDist) {
+ 		if (rippleDist >= 0) {
+ 			me.rippleDist = rippleDist;
+@@ -181,17 +190,30 @@ var FireControl = {
+ 	getRippleDelay: func {
+ 		me.rippleDelay;
+ 	},
+-	
++
+ 	setRippleDelay: func (rippleDelay) {
+ 		if (rippleDelay >= 0) {
+ 			me.rippleDelay = rippleDelay;
+ 		}
+ 	},
+-	
++
+ 	getSelectedType: func {
+ 		return me.selectedType;
+ 	},
+ 
++	togglePowerOn: func () {
++		me.myType = me.getSelectedType();
++		if (me.myType == nil) return;
++		me.myWeaps = me.getAllOfType(me.myType);
++		me.currPow = 0;
++		if (me.myWeaps != nil and size(me.myWeaps) and me.myWeaps[0].parents[0] == armament.AIM) {
++			me.currPow = me.myWeaps[0].isPowerOn();
++			foreach (me.myWeap ; me.myWeaps) {
++				me.myWeap.setPowerOn(!me.currPow);
++			}
++		}
++	},
++
+ 	getCategory: func {
+ 		# get loadout CAT (not to be confused with FBW CAT setting)
+ 		me.cat = 1;
+@@ -265,7 +287,7 @@ var FireControl = {
+ 			me.selType = me.selectedType;
+ 			printfDebug(" Now selecting %s",me.selType);
+ 			me.wp = me.nextWeapon(me.selType);
+-			if (me.wp != nil) {			
++			if (me.wp != nil) {
+ 				printfDebug("FC: Selected next weapon type: %s on pylon %d position %d",me.selectedType,me.selected[0],me.selected[1]);
+ 			} else {
+ 				printfDebug("FC: Selected next weapon type: %s, but none is loaded.", me.selectedType);
+@@ -297,13 +319,13 @@ var FireControl = {
+ 			me.selType = me.selectedType;
+ 			printfDebug(" Now selecting %s",me.selType);
+ 			me.wp = me.nextWeapon(me.selType);
+-			if (me.wp != nil) {			
++			if (me.wp != nil) {
+ 				printfDebug("FC: Selected next weapon type: %s on pylon %d position %d",me.selectedType,me.selected[0],me.selected[1]);
+ 				screen.log.write("Selected "~me.selectedType, 0.5, 0.5, 1);
+ 				return;
+ 			}
+ 			me.selTypeIndex += 1;
+-		}		
++		}
+ 		me.selected = nil;
+ 		me.selectedAdd = nil;
+ 		me.selectedType = nil;
+@@ -368,7 +390,7 @@ var FireControl = {
+ 				if (!me.hasSeen) {
+ 					if (me.typeTest == me.selectedType) {
+ 						me.hasSeen = 1;
+-					} 
++					}
+ 					continue;
+ 				}
+ 				me.class = getprop("payload/armament/"~string.lc(me.typeTest)~"/class");
+@@ -427,10 +449,10 @@ var FireControl = {
+ 		if (me.selectedType != nil) {
+ 			me.stopCurrent();
+ 		}
+-		
++
+ 		me.selectedType = defaultCannon;
+ 		me.nextWeapon(me.selectedType);
+-		
++
+ 		me.selectedAdd = nil;
+ 		me.updateDual();
+ 	},
+@@ -473,7 +495,7 @@ var FireControl = {
+ 				if (!me.hasSeen) {
+ 					if (me.typeTest == me.selectedType) {
+ 						me.hasSeen = 1;
+-					} 
++					}
+ 					continue;
+ 				}
+ 				me.class = getprop("payload/armament/"~string.lc(me.typeTest)~"/class");
+@@ -530,10 +552,10 @@ var FireControl = {
+ 		if (me.selectedType != nil) {
+ 			me.stopCurrent();
+ 		}
+-		
++
+ 		me.selectedType = defaultCannon;
+ 		me.nextWeapon(me.selectedType);
+-		
++
+ 		me.selectedAdd = nil;
+ 		if (me.changeListener != nil) me.changeListener();
+ 	},
+@@ -569,7 +591,7 @@ var FireControl = {
+ 		}
+ 		return me.getSelectedPylon().getAmmo() > 0;
+ 	},
+-	
++
+ 	_getSpecificWeapon: func (p, w) {
+ 		# return specific weapon or nil
+ 		if (w < 0 or w > size(me.pylons[p].getWeapons())-1) {
+@@ -577,7 +599,7 @@ var FireControl = {
+ 		}
+ 		return me.pylons[p].getWeapons()[w];
+ 	},
+-	
++
+ 	getSelectedWeapons: func {
+ 		# return selected weapons or nil
+ 		if (me.selected == nil) {
+@@ -602,7 +624,7 @@ var FireControl = {
+ 		}
+ 		return me.sw;
+ 	},
+-	
++
+ 	getSelectedDualWeapons: func {
+ 		# return selected dual weapons or nil
+ 		if (me.selected == nil) {
+@@ -693,7 +715,7 @@ var FireControl = {
+ 		}
+ 		if (me.changeListener != nil) me.changeListener();
+ 	},
+-	
++
+ 	jettisonSpecificPylons: func (list, also_heat) {
+ 		# jettison commanded pylons
+ 		foreach (pyl;me.pylons) {
+@@ -710,11 +732,11 @@ var FireControl = {
+ 					continue;
+ 				}
+ 				pyl.jettisonAll();
+-			}			
++			}
+ 		}
+ 		if (me.changeListener != nil) me.changeListener();
+ 	},
+-	
++
+ 	jettisonAllButHeat: func (exclude = nil) {
+ 		# jettison all but heat seekers.
+ 		foreach (pyl;me.pylons) {
+@@ -754,21 +776,21 @@ var FireControl = {
+ 		}
+ 		return me.selected[0];
+ 	},
+-	
++
+ 	selectWeapon: func (w) {
+ 		me.stopCurrent();
+ 		me.selectedType = w;
+ 		var nw = me.nextWeapon(w);
+ 		return nw;
+ 	},
+-	
++
+ 	selectNothing: func {
+ 		me.stopCurrent();
+ 		me.selectedType = nil;
+ 		me.selected = nil;
+ 		if (me.changeListener != nil) me.changeListener();
+ 	},
+-	
++
+ 	selectPylon: func (p, w=nil) {
+ 		# select a specified pylon
+ 		# will stop previous weapon, will start next.
+@@ -823,7 +845,7 @@ var FireControl = {
+ 					}
+ 				}
+ 				me.nextWeapon(me.selectedType);
+-				
++
+ 				# start ripple if set
+ 				me.idx = me.vectorIndex(dualWeapons,me.selectedType);
+ 				if (me.idx != -1) {
+@@ -838,7 +860,7 @@ var FireControl = {
+ 						setprop("payload/armament/gravity-dropping", 0);
+ 					}
+ 				}
+-				
++
+ 				me.triggerTime = 0;
+ 			} elsif (me.aim != nil and me.aim.parents[0] == armament.AIM and me.aim.loal) {
+ 				me.triggerTime = getprop("sim/time/elapsed-sec");
+@@ -847,7 +869,7 @@ var FireControl = {
+ 				if (getprop("sim/time/elapsed-sec")>me.gunTriggerTime+10 or me.aim.alternate) {
+ 					# only say guns guns every 10 seconds.
+ 					#armament.AIM.sendMessage(me.aim.brevity);
+-					
++
+ 					me.gunTriggerTime = getprop("sim/time/elapsed-sec");
+ 				}
+ 				damage.damageLog.push(me.aim.type~" fired");
+@@ -865,7 +887,7 @@ var FireControl = {
+ 			}
+ 		}
+ 	},
+-	
++
+ 	fireAIM: func (p,w,g) {
+ 		# fire a weapon (that is a missile-code instance)
+ 		me.aim = me._getSpecificWeapon(p,w);
+@@ -883,7 +905,7 @@ var FireControl = {
+ 		if (me.changeListener != nil) me.changeListener();
+ 		return me.aim;
+ 	},
+-	
++
+ 	rippleFireStart: func {
+ 		# First has been fired, now start system to fire the ripple ones.
+ 		if (me.getSelectedWeapon() != nil) {
+@@ -893,7 +915,7 @@ var FireControl = {
+ 			me.rippleTest();
+ 		}
+ 	},
+-	
++
+ 	rippleTest: func {
+ 		# test for distance if we should fire ripple bombs. And do so if distance is great enough.
+ 		me.rippleCount += 1;
+@@ -980,10 +1002,10 @@ var FireControl = {
+ 			return;
+ 		}
+ 		printDebug("FC: Masterarm "~getprop("controls/armament/master-arm-switch"));
+-		
++
+ 		me.pylons[me.selected[0]].calculateMass();#kind of a hack to get cannon ammo changed.
+ 	},
+-	
++
+ 	updateDual: func (type = nil) {
+ 		# will stop all current weapons, and select single and pair weapons and start em all.
+ 		me.duality = getprop("controls/armament/dual");
+@@ -1005,7 +1027,7 @@ var FireControl = {
+ 			return;
+ 		}
+ 	},
+-	
++
+ 	selectDualWeapons: func (type, duality) {
+ 		# will select additional weapon of same type if dual is supported for the type and dual is greater than 'single'
+ 		# will NOT start them
+@@ -1147,7 +1169,7 @@ var FireControl = {
+ 		}
+ 		return me.count;
+ 	},
+-	
++
+ 	getAllAmmo: func (type = nil) {
+         # return ammo count of all pylons in a vector
+         me.ammoVector = [];
+@@ -1156,7 +1178,7 @@ var FireControl = {
+         }
+         return me.ammoVector;
+     },
+-	
++
+ 	getActiveAmmo: func {
+ 		# return ammo count of currently selected type that are on active pylons
+ 		me.count = 0;
+@@ -1217,11 +1239,11 @@ var FireControl = {
+ 			}
+ 		}
+ 	},
+-	
++
+ 	getAllOfType: func (typ) {
+ 		# return vector with all weapons of certain type
+ 		me.typVec = [];
+-		
++
+ 		foreach(pyl;me.pylons) {
+ 			foreach(me.pylweap ; pyl.getWeapons()) {
+ 				if (me.pylweap != nil and me.pylweap.type == typ) {
+@@ -1231,6 +1253,30 @@ var FireControl = {
+ 		}
+ 		return me.typVec;
+ 	},
++
++	getStationIndecesForSelectedType: func (typeOnly = nil) {
++		# return vector with all weapons of certain type
++		if (typeOnly == nil) typeOnly = me.selectedType;
++		me.same = typeOnly == me.selectedType;
++		me.indices = [];
++		for (var i = 0; i < size(me.pylons);i +=1) {
++			me.pylo = me.pylons[i];
++			me.value = -1;
++			if (me.selected != nil and i == me.selected[0] and me.same) {
++				me.value = 1;
++			} elsif (typeOnly != nil and me.same) {
++				foreach(me.pylweap ; me.pylo.getWeapons()) {
++					if (me.pylweap != nil and me.pylweap.type == typeOnly) {
++						me.value = 0;
++						break;
++					}
++				}
++			}
++			append(me.indices, me.value);
++		}
++
++		return me.indices;
++	},
+ };
+ 
+ var debug = 0;
+diff --git a/Nasal/missile-code.nas b/Nasal/missile-code.nas
+index 2cad43f..547146f 100644
+--- a/Nasal/missile-code.nas
++++ b/Nasal/missile-code.nas
+@@ -134,16 +134,16 @@ var PATTERN_ROSETTE = 1;
+ var PATTERN_DOUBLE_D = 2;
+ 
+ # set these to print stuff to console:
+-var DEBUG_STATS            = 0;#most basic stuff
++var DEBUG_STATS            = 1;#most basic stuff
+ var DEBUG_FLIGHT           = 0;#for creating missiles sometimes good to have this on to see how it flies.
+ 
+ # set these to debug the code:
+-var DEBUG_STATS_DETAILS    = 0;
+-var DEBUG_GUIDANCE         = 0;
+-var DEBUG_GUIDANCE_DETAILS = 0;
++var DEBUG_STATS_DETAILS    = 1;
++var DEBUG_GUIDANCE         = 1;
++var DEBUG_GUIDANCE_DETAILS = 1;
+ var DEBUG_FLIGHT_DETAILS   = 0;
+-var DEBUG_SEARCH           = 0;
+-var DEBUG_CODE             = 0;
++var DEBUG_SEARCH           = 1;
++var DEBUG_CODE             = 1;
+ 
+ var g_fps        = 9.80665 * M2FT;
+ var SLUGS2LBM = 32.1740485564;
+diff --git a/Nasal/steerpoints.nas b/Nasal/steerpoints.nas
+new file mode 100644
+index 0000000..50a8626
+--- /dev/null
++++ b/Nasal/steerpoints.nas
+@@ -0,0 +1,1071 @@
++ #
++# F-16 Steerpoint/route/mark/bulls-eye system.
++#
++var lines = [nil,nil, nil, nil];
++
++var desired_tos = {};
++
++var number_of_threat_circles  = 15;
++var number_of_generic         = 10;
++var number_of_markpoints_own  = 5;
++var number_of_markpoints_dlnk = 5;
++
++var index_of_threat_circles   = 300;
++var index_of_generic          = 350;
++var index_of_markpoints_own   = 400;
++var index_of_markpoints_dlnk  = 450;
++var index_of_weapon_gps       = 500;
++var index_of_bullseye         = 555;
++var index_of_lines_1          = 100;
++var index_of_lines_2          = 200;
++var index_of_lines_3          = 600;
++var index_of_lines_4          = 700;
++
++var stpt300 = setsize([],number_of_threat_circles);#Threat circles
++var stpt350 = setsize([],10);#Generic
++var stpt400 = setsize([],5);#Markpoints Own
++var stpt450 = setsize([],5);#Markpoints DL
++var stpt500 = setsize([],1);#Weapon
++var stpt555 = setsize([],1);#Bullseye
++var current = nil;#Current STPT number, nil for route/nothing.
++
++var colorRed = 0;
++var colorYellow = 1;
++var colorGreen = 2;
++
++var autoMode = 1;# if change this then also change f16/ded/stpt-auto
++
++var STPT = {
++	# stored in the above vectors for non-route steerpoints
++	lon: 0,
++	lat: 0,
++	alt: 0,
++	type: "   ",
++	radius: 10,
++	color: colorYellow,
++
++	new: func {
++		var n = {parents: [STPT]};
++		return n;
++	},
++
++	copy: func {
++		var cp = STPT.new();
++		cp.lat = me.lat;
++		cp.lon = me.lon;
++		cp.alt = me.alt;
++		cp.type = me.type;
++		cp.radius = me.radius;
++		cp.color = me.color;
++		return cp;
++	},
++};
++
++
++
++var getCurrentNumber = func {
++	# Get current steerpoint. The first is #1. Return 0 for no current steerpoint.
++	if (current != nil) {
++		return current;
++	} elsif (isRouteActive()) {
++		var fp = flightplan();
++		return fp.current + 1;
++	}
++	return 0;
++}
++
++var getLastNumber = func {
++	# Get the steerpoint # for the final steerpoint in current route or for non-route get the current.
++	if (current != nil) {
++		return current;
++	} elsif (isRouteActive()) {
++		var fp = flightplan();
++		return fp.getPlanSize();
++	}
++	return 0;
++}
++
++var getNumber = func (number) {
++	# Return a specific steerpoint, nil if none
++	if (!_isOccupiedNumber(number)) {
++		return nil;
++	}
++	if (number >= 700 and lines[3] != nil) {
++		var fp = lines[3];
++		var leg = fp.getWP(number-700);
++		var new = STPT.new();
++		new.lat = leg.lat;
++		new.lon = leg.lon;
++		if (leg.alt_cstr != nil) {
++			new.alt = leg.alt_cstr;
++		}
++		return new;
++	}
++	if (number >= 600 and lines[2] != nil) {
++		var fp = lines[2];
++		var leg = fp.getWP(number-600);
++		var new = STPT.new();
++		new.lat = leg.lat;
++		new.lon = leg.lon;
++		if (leg.alt_cstr != nil) {
++			new.alt = leg.alt_cstr;
++		}
++		return new;
++	}
++	if (number == 555) {
++		return stpt555[0];
++	}
++	if (number == 500) {
++		return stpt500[0];
++	}
++	if (number >= 450) {
++		return stpt450[number-450];
++	}
++	if (number >= 400) {
++		return stpt400[number-400];
++	}
++	if (number >= 350) {
++		return stpt350[number-350];
++	}
++	if (number >= 300) {
++		return stpt300[number-300];
++	}
++	if (number >= 200 and lines[1] != nil) {
++		var fp = lines[1];
++		var leg = fp.getWP(number-200);
++		var new = STPT.new();
++		new.lat = leg.lat;
++		new.lon = leg.lon;
++		if (leg.alt_cstr != nil) {
++			new.alt = leg.alt_cstr;
++		}
++		return new;
++	}
++	if (number >= 100 and lines[0] != nil) {
++		var fp = lines[0];
++		var leg = fp.getWP(number-100);
++		var new = STPT.new();
++		new.lat = leg.lat;
++		new.lon = leg.lon;
++		if (leg.alt_cstr != nil) {
++			new.alt = leg.alt_cstr;
++		}
++		return new;
++	}
++	if (number < 100 and isRouteActive()) {
++		var fp = flightplan();
++		var leg = fp.getWP(number-1);
++		var new = STPT.new();
++		new.lat = leg.lat;
++		new.lon = leg.lon;
++		if (leg.alt_cstr != nil) {
++			new.alt = leg.alt_cstr;
++		}
++		return new;
++	}
++	return nil;
++}
++
++var setNumber = func (number, stpt) {
++	# Store a non-route steerpoint in memory
++	if (!_isValidNumber(number)) {
++		return 0;
++	}
++	if (number == 555) {
++		stpt555[0] = stpt;
++		return 1;
++	}
++	if (number == 500) {
++		stpt500[0] = stpt;
++		return 1;
++	}
++	if (number >= 450) {
++		stpt450[number-450] = stpt;
++		return 1;
++	}
++	if (number >= 400) {
++		stpt400[number-400] = stpt;
++		return 1;
++	}
++	if (number >= 350) {
++		stpt350[number-350] = stpt;
++		return 1;
++	}
++	if (number >= 300) {
++		stpt300[number-300] = stpt;
++		return 1;
++	}
++	if (number < 300) {
++		return 0;
++	}
++	return 0;
++}
++
++var getCurrentDirection = func {
++	# Get directions to current steerpoint or [nil,nil] for none.
++	if (getCurrentNumber() != 0) {
++		var cc = getCurrentCoord();
++		return [geo.aircraft_position().course_to(cc), vector.Math.getPitch(geo.aircraft_position(), cc)];
++	} else {
++		return [nil, nil];
++	}
++}
++
++var getCurrentDirectionForHUD = func {
++	# Get directions to current steerpoint or [nil,nil] for none.
++	if (getCurrentNumber() != 0) {
++		var cc = getCurrentCoordForHUD();
++		return [geo.aircraft_position().course_to(cc), vector.Math.getPitch(geo.aircraft_position(), cc)];
++	} else {
++		return [nil, nil];
++	}
++}
++
++var getCurrentRange = func {
++	# Return range in nm to current steerpoint.
++	if (getCurrentNumber() == 0) return nil;
++	var s = getCurrentCoord();
++	return s.distance_to(geo.aircraft_position())*M2NM;
++}
++
++var getCurrentGroundPitch = func {
++	#if (getCurrentNumber() != 0) {
++		var gCoord = getCurrentGroundCoord();
++		if (gCoord != nil) {
++			return vector.Math.getPitch(geo.aircraft_position(), gCoord);
++		}
++	#}
++	return nil;
++}
++
++var getCurrentSlantRange = func {
++	# Return slant range in nm to current steerpoint.
++	if (getCurrentNumber() == 0) return nil;
++	var s = getCurrentCoord();
++	return s.direct_distance_to(geo.aircraft_position())*M2NM;
++}
++
++var getCurrentETA = func {
++	# Return seconds till current steerpoint.
++	if (getCurrentNumber() == 0) return nil;
++	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
++	if (gs == 0) return nil;
++	if (current == nil) {
++		return getprop("autopilot/route-manager/wp/eta-seconds");
++	}
++	var range = getCurrentRange()*NM2M;
++	return range/gs;
++}
++
++var getCurrentCoord = func {
++	# returns current steerpoint as geo.Coord
++	var s = getNumber(getCurrentNumber());
++	if (s == nil) return nil;
++	return stpt2coord(s);
++}
++
++var getCurrentCoordForHUD = func {
++	# returns current steerpoint as geo.Coord
++	var s = getNumber(getCurrentNumber());
++	return stpt2coordGrounded(s);
++}
++
++var getCurrentGroundCoord = func {
++	# returns current steerpoint as geo.Coord
++	var s = getNumber(getCurrentNumber());
++	if (s == nil) return nil;
++	var elev = geo.elevation(s.lat, s.lon);
++	if (elev == nil) {
++		if (s.alt != nil) {
++			elev = s.alt * FT2M;
++		} else {
++			return nil;
++		}
++	}
++	var p = geo.Coord.new();
++    p.set_latlon(s.lat, s.lon, elev);
++
++	return p;
++}
++
++var setCurrentNumber = func (number) {
++	# Set current steerpoint number.
++	if (number < 100 and isRouteActive() and number > 0) {
++		var fp = flightplan();
++		if (fp.getPlanSize() >= number) {
++			fp.current = number - 1;
++			current = nil;
++			print("Switching active steerpoint to #"~number);
++			return 1;
++		}
++	} elsif (_isOccupiedNumber(number)) {
++		current = number;
++		print("Switching active steerpoint to #"~number);
++		return 1;
++	}
++	return 0;
++}
++
++var getCurrent = func {
++	# return current steerpoint or nil
++	return getNumber(getCurrentNumber());
++}
++
++var getLastRange = func {
++	# Get nm range to final steerpoint in current route or to current steerpoint for non-route.
++	if (getCurrentNumber() == 0) return nil;
++	if (current == nil) {
++		var fp = flightplan();
++		var dist_nm = steerpoints.getCurrentRange();
++		var stnum = getCurrentNumber();
++		for (var index = stnum; index < fp.getPlanSize(); index+=1) {
++			dist_nm += fp.getWP(index).leg_distance;
++		}
++		return dist_nm;
++	} else {
++		return steerpoints.getCurrentRange();
++	}
++}
++
++var getNumberRange = func (number) {
++	# Get range to specific steerpoint
++	if (getCurrentNumber() == 0) return nil;
++	if (current == nil and number >= getCurrentNumber()) {
++		var dist_nm = steerpoints.getCurrentRange();
++		var stnum = getCurrentNumber();
++		for (var index = stnum; index < number-1; index+=1) {
++			dist_nm += flightplan().getWP(index).leg_distance;
++		}
++		return dist_nm;
++	} elsif (number == getCurrentNumber()) {
++		return steerpoints.getCurrentRange();
++	}
++	return nil;
++}
++
++var getLast = func {
++	# Return final steerpoint
++	if (getCurrentNumber() == 0) return nil;
++	return getNumber(getLastNumber());
++}
++
++var getRequiredSpeed = func (number) {
++    # Get required groundspeed in kts for TOS on specific steerpoint
++    if (getCurrentNumber() == 0) return nil;
++    var range = getNumberRange(number)*NM2M;
++    var des_tos = _getNumberDesiredTOS(number);
++    #var des_tos = getprop("f16/ded/crus-des-tos");
++    if (des_tos == nil) {
++       des_tos = 0;
++    }
++    # Subtract current time from TOS to get relative time
++    #if (des_tos > addSeconds(0, getprop("sim/time/utc/hour"),getprop("sim/time/utc/minute"),getprop("sim/time/utc/second"))) {
++        # Desired TOS is in the past, this shouldn't really matter, since we have a min of 70kts
++    #}
++    var cur_sec = (((getprop("sim/time/utc/hour")*60)+getprop("sim/time/utc/minute"))*60)+getprop("sim/time/utc/second")+math.fmod(getprop("sim/time/steady-clock-sec"), 1);
++    #var tos_sec = addSeconds(des_tos, -getprop("sim/time/utc/hour"),-getprop("sim/time/utc/minute"),-getprop("sim/time/utc/second"));
++    #tos_sec = (((tos_sec[1]*60)+tos_sec[2])*60)+tos_sec[3];
++
++    # MLU M1: if STPT not reached in time, airspeed caret remains at max
++    if (cur_sec > des_tos) {
++        return 1700;
++    }
++    var tos_sec = des_tos - cur_sec;
++    var req_spd = range / tos_sec / KT2MPS;
++    # As per MLU M1, the speed is limited between 70kts and 1700kts
++    return math.max(math.min(req_spd, 1700), 70);
++}
++
++var getLastETA = func {
++	# Get time in seconds till final steerpoint
++	if (getCurrentNumber() == 0) return nil;
++	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
++	if (gs == 0) return nil;
++	var range = getLastRange()*NM2M;
++	return range/gs;
++}
++
++var getNumberETA = func (number) {
++	# Get time in seconds till specific steerpoint
++	if (getCurrentNumber() == 0) return nil;
++	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
++	if (gs == 0) return nil;
++	var range = getNumberRange(number)*NM2M;
++	return range/gs;
++}
++
++var setNumberDesiredTOS = func (number, tos) {
++    if (tos == -1) {
++        tos = nil;
++    }
++    desired_tos[number] = tos;
++    return;
++}
++
++var _getNumberDesiredTOS = func (number) {
++    if (getCurrentNumber() == 0) return nil;
++    return desired_tos[number];
++}
++
++var serializeTOS = func (number) {
++    var result = _getNumberDesiredTOS(number);
++    if (result == nil) {
++        result = -1;
++    }
++    return result;
++}
++
++var getNumberDesiredTOS = func (number) {
++    # Get string with desired time over steerpoint for specific steerpoint
++    var val = _getNumberDesiredTOS(number);
++	return _getTOS(val);
++}
++
++var getNumberTOS = func (number) {
++	# Get string with time on station for specific steerpoint
++	if (getCurrentNumber() == 0) return nil;
++	var eta = getNumberETA(number);
++	return _getTOS(eta);
++}
++
++var _getCurrentDesiredTOS = func {
++    return _getNumberDesiredTOS(getCurrentNumber());
++}
++
++var getCurrentDesiredTOS = func {
++	# Get string with desired time over steerpoint for current steerpoint
++	return getNumberDesiredTOS(getCurrentNumber());
++}
++
++var setCurrentDesiredTOS = func (tos) {
++	# Get string with desired time over steerpoint for current steerpoint
++	return setNumberDesiredTOS(getCurrentNumber(), tos);
++}
++
++var getCurrentRequiredSpeed = func {
++    return getRequiredSpeed(getCurrentNumber());
++}
++
++var getAbsoluteTOS = func (eta) {
++    return _getTOS(eta, 1);
++}
++
++var getCurrentTOS = func {
++	# Get string with time on station for current steerpoint
++	var eta = getCurrentETA();
++	return _getTOS(eta);
++}
++
++var getLastTOS = func {
++	# Get string with time on station for final steerpoint
++	var eta = getLastETA();
++	return _getTOS(eta);
++}
++
++var formatTime = func(time, absolute = 1) {
++    var result = "--:--:--";
++    if (time == nil or time>3600*24 or time < 0) {
++		return result;
++	} else {
++	    if (!absolute) {
++            var hour   = getprop("sim/time/utc/hour");
++            var minute = getprop("sim/time/utc/minute");
++            var second = getprop("sim/time/utc/second");
++        } else {
++            var hour   = 0;
++            var minute = 0;
++            var second = 0;
++        }
++        var final = addSeconds(time,second,minute,hour);
++
++		result = sprintf("%02d:%02d:%02d",final[1],final[2],final[3]);
++	}
++	return result;
++}
++
++var _getTOS = func (eta, absolute = 0) {
++	# Get string with time on station for a specific time in seconds
++	# eta is allowed to be nil
++	# if absolute the eta is assumed to be an exact time, otherwise eta is assumed to be relative to current time
++	var TOS = "--:--:--";
++	if (getCurrentNumber() == 0) return TOS;
++
++	return formatTime(eta, !absolute);
++}
++
++var addSeconds = func (add_secs, secs, mins, hours) {
++	# Add some seconds to 24 hr clock
++
++	# the baseline:
++	var d = 0;
++	var h = hours;
++	var m = mins;
++	var s = secs;
++
++	# the added:
++	var H = int(add_secs/3600);
++    var S = add_secs-H*3600;
++    var M = int(S/60);
++    S = S-M*60;
++
++    s += S;
++    var addOver = 0;
++	while (s > 59) {
++		addOver += 1;
++		s -= 60;
++	}
++
++	m += M+addOver;
++	addOver = 0;
++	while (m > 59) {
++		addOver += 1;
++		m -= 60;
++	}
++
++	h += H+addOver;
++	while (h > 23) {
++		addOver += 1;
++		h -= 24;
++	}
++
++	d = addOver;
++
++    return [d,h,m,s];
++}
++
++var next = func {
++	# Advance steerpoint
++	if (current != nil) return;
++	var active = isRouteActive();
++    var wp = getprop("autopilot/route-manager/current-wp");
++    var max = getprop("autopilot/route-manager/route/num");
++
++    if (active) {
++		wp += 1;
++		if (wp>max-1) {
++			wp = 0;
++		}
++		setprop("autopilot/route-manager/current-wp", wp);
++	}
++}
++
++var prev = func {
++	# Decrease steerpoint
++	if (current != nil) return;
++	var active = isRouteActive();
++    var wp = getprop("autopilot/route-manager/current-wp");
++    var max = getprop("autopilot/route-manager/route/num");
++
++    if (active) {
++		wp -= 1;
++		if (wp<0) {
++			wp = max-1;
++		}
++		setprop("autopilot/route-manager/current-wp", wp);
++    }
++}
++
++var copy = func (from, to) {
++	# Copy steerpoint. Cannot copy TO route or lines steerpoints.
++	var fStpt = getNumber(from);
++	if (fStpt != nil and _isValidNumber(to)) {
++		var tStpt = fStpt.copy();
++		setNumber(to, tStpt);
++		print("Copying steerpoint #"~from~" to #"~to);
++	} else {
++		print("STPT copy unsuccesful.");
++	}
++}
++
++var sendCurrent = func {
++	# Send current steerpoint over DLNK
++	return send(getCurrentNumber());
++}
++
++var stpt2coord = func (stpt) {
++	# Convert steerpoint to geo.Coord
++	var p = geo.Coord.new();
++    p.set_latlon(stpt.lat, stpt.lon, stpt.alt*FT2M);
++    return p;
++}
++
++var stpt2coordGrounded = func (stpt) {
++	# Convert steerpoint to geo.Coord but not lower than ground
++	var p = geo.Coord.new();
++	var elev = stpt.alt*FT2M;
++	if (elev <= 0) {
++		elev = geo.elevation(stpt.lat, stpt.lon);
++		if (elev == nil) {
++			elev = 0;
++		}
++	}
++    p.set_latlon(stpt.lat, stpt.lon, elev);
++    return p;
++}
++
++var send = func (number) {
++	# Send specific steerpoint over DLNK
++	var s = getNumber(number);
++	if (s != nil and sending == nil) {
++		var p = stpt2coord(s);
++	    sending = p;
++	    datalink.send_data({"point": sending});
++	    settimer(func {sending = nil;},7);
++	    print("Sending steerpoint to #"~number~" to DLNK.");
++	    return 1;
++	}
++	return 0;
++}
++
++var markOFLY = func {
++	# Create an OLFY markpoint
++	var mark = STPT.new();
++	mark.lat = getprop("/position/latitude-deg");
++	mark.lon = getprop("/position/longitude-deg");
++	mark.alt = getprop("/position/altitude-ft");
++	mark.type = "OFLY";
++	addOwnMark(mark);
++}
++
++var markTGP = func (coord) {
++	# Create a TGP markpoint
++	var mark = STPT.new();
++	mark.lat = coord.lat();
++	mark.lon = coord.lon();
++	mark.alt = coord.alt()*M2FT;
++	mark.type = "TGP";
++	return addOwnMark(mark);
++}
++
++var markHUD = func (coord) {
++	# Create a HUD markpoint
++	var mark = STPT.new();
++	mark.lat = coord.lat();
++	mark.lon = coord.lon();
++	mark.alt = coord.alt()*M2FT;
++	mark.type = "HUD";
++	return addOwnMark(mark);
++}
++
++var ownMarkIndex = 4;
++
++var addOwnMark = func (mark) {
++	# Store a mark
++	ownMarkIndex += 1;
++	if (ownMarkIndex > 4) ownMarkIndex = 0;
++	stpt400[ownMarkIndex] = mark;
++	return ownMarkIndex+400;
++}
++
++var dlMarkIndex = 4;
++
++var addDLMark = func (mark) {
++	# STore a DLNK mark
++	dlMarkIndex += 1;
++	if (dlMarkIndex > 4) dlMarkIndex = 0;
++	stpt450[dlMarkIndex] = mark;
++	return dlMarkIndex+450;
++}
++
++var applyToWPN = func {
++	# Apply WPN steerpoint to current weapon
++	var lat = getprop("f16/avionics/gps-lat");
++	var lon = getprop("f16/avionics/gps-lon");
++	var alt = getprop("f16/avionics/gps-alt")*FT2M;
++	if (lat < 90 and lat > -90 and lon < 180 and lon > -180 and pylons.fcs != nil) {
++		var wp = pylons.fcs.getSelectedWeapon();
++		if (wp != nil and wp.parents[0] == armament.AIM and wp.target_pnt == 1 and wp.guidance=="gps") {
++			var coord = geo.Coord.new();
++			coord.set_latlon(lat,lon,alt);
++			var spot = radar_system.ContactTGP.new("GPS-Spot",coord,0);
++			armament.contactPoint = spot;
++			tgp.gps = 1;
++			if (getprop("f16/stores/tgp-mounted") and 0) {
++				tgp.flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
++				callsign = armament.contactPoint.getUnique();
++                setprop("/aircraft/flir/target/auto-track", 1);
++                flir_updater.offsetP = 0;
++                flir_updater.offsetH = 0;
++				setprop("f16/avionics/tgp-lock", 1);
++			}
++			wp.setContacts([spot]);
++		}
++	}
++}
++
++var _isValidNumber = func (number) {
++	# Is the number a valid possible steerpoint number?
++	if (number >= 300 and number < 300+number_of_threat_circles) {
++		return 1;
++	} elsif (number >= 350 and number <= 359) {
++		return 1;
++	} elsif (number >= 400 and number <= 404) {
++		return 1;
++	} elsif (number >= 450 and number <= 454) {
++		return 1;
++	} elsif (number == 500) {
++		return 1;
++	} elsif (number == 555) {
++		return 1;
++	} elsif (number >= 1 and number < 300) {
++		return 1;
++	} elsif (number >= 600 and number < 700) {
++		return 1;
++	} elsif (number >= 700 and number < 800) {
++		return 1;
++	}
++	return 0;
++}
++
++var _isOccupiedNumber = func (number) {
++	# Is a steerpoint stored at this memory address?
++	if (!_isValidNumber(number)) {
++		return 0;
++	}
++	if (number < 800 and number >= 700) {
++		if (lines[3] != nil) {
++			var fp = lines[3];
++			return fp.getPlanSize() > number-700;
++		}
++		return 0;
++	}
++	if (number < 700 and number >= 600) {
++		if (lines[2] != nil) {
++			var fp = lines[2];
++			return fp.getPlanSize() > number-600;
++		}
++		return 0;
++	}
++	if (number == 555) {
++		return stpt555[0] != nil;
++	}
++	if (number == 500) {
++		return stpt500[0] != nil;
++	}
++	if (number >= 450) {
++		return stpt450[number-450] != nil;
++	}
++	if (number >= 400) {
++		return stpt400[number-400] != nil;
++	}
++	if (number >= 350) {
++		return stpt350[number-350] != nil;
++	}
++	if (number >= 300) {
++		return stpt300[number-300] != nil;
++	}
++	if (number < 300 and number >= 200 and lines[1] != nil) {
++		var fp = lines[1];
++		return fp.getPlanSize() > number-200;
++	}
++	if (number < 200 and number >= 100 and lines[0] != nil) {
++		var fp = lines[0];
++		return fp.getPlanSize() > number-100;
++	}
++	if (number < 100 and number > 0 and isRouteActive()) {
++		var fp = flightplan();
++		return fp.getPlanSize() > number-1;
++	}
++	return 0;
++}
++
++
++
++var isRouteActive = func {
++	return getprop("autopilot/route-manager/active") and getprop("f16/avionics/power-mmc") and getprop("autopilot/route-manager/current-wp") != nil and getprop("autopilot/route-manager/current-wp") > -1 and getprop("autopilot/route-manager/route/num") != nil and getprop("autopilot/route-manager/current-wp") < getprop("autopilot/route-manager/route/num");
++}
++
++
++var data = nil;
++var sending = nil;
++var dlink_loop = func {
++  if (getprop("instrumentation/datalink/data") != 0) return;
++  foreach(contact; b1b.vector_aicontacts_links) {
++    if (contact.isVisible()) {
++      data = datalink.get_data(contact.get_Callsign());
++      if (data != nil  and data.on_link()) {
++        var p = data.point();
++        if (p != nil) {
++          sending = nil;
++          var mrk = STPT.new();
++          mrk.lat = p.lat();
++          mrk.lon = p.lon();
++          mrk.alt = p.alt()*M2FT;
++          var no = addDLMark(mrk);
++
++          setprop("instrumentation/datalink/data",no);
++
++          settimer(func {setprop("instrumentation/datalink/data",0);}, 10);
++          return;
++        }
++      }
++    }
++  }
++}
++
++var dlnk_timer = maketimer(3.5, dlink_loop);
++dlnk_timer.start();
++
++
++
++
++var loadLine = func  (no,path) {
++    printf("Attempting to load route %s to act as lines %d in HSD.", path, no);
++
++    call(func {lines[no] = createFlightplan(path);}, nil, var err = []);
++    if (size(err) or lines[no] == nil) {
++        print(err[0]);
++        setprop("f16/preplanning-status", err[0]);
++        gui.showDialog("loadfail");
++    } else {
++    	setprop("f16/preplanning-status", "HSD lines loaded");
++    }
++};
++
++var EMPTY_ALT = -99999;
++
++var serialize = func() {
++	var ret = "";
++	var iter = 0;
++	if (lines[0] != nil) {
++		for (var s = 0; s < lines[0].getPlanSize() and s < 100; s+=1) {
++			var key = lines[0].getWP(s);
++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+100,key.lat,key.lon);
++	  	}
++	}
++	if (lines[1] != nil) {
++		for (var s = 0; s < lines[1].getPlanSize() and s < 100; s+=1) {
++			var key = lines[1].getWP(s);
++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+200,key.lat,key.lon);
++	  	}
++	}
++	if (lines[2] != nil) {
++		for (var s = 0; s < lines[2].getPlanSize() and s < 100; s+=1) {
++			var key = lines[2].getWP(s);
++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+600,key.lat,key.lon);
++	  	}
++	}
++	if (lines[3] != nil) {
++		for (var s = 0; s < lines[3].getPlanSize() and s < 100; s+=1) {
++			var key = lines[3].getWP(s);
++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+700,key.lat,key.lon);
++	  	}
++	}
++	if (flightplan() != nil) {
++		var plan = flightplan();
++		for (var s = 0; s < plan.getPlanSize(); s+=1) {
++			var key = plan.getWP(s);
++		  	ret = ret~sprintf("PLAN,%d,%.6f,%.6f,%d,%d|",s+0,key.lat,key.lon,(key.alt_cstr_type!=nil and key.alt_cstr != nil)?key.alt_cstr:EMPTY_ALT,serializeTOS(s+1));
++	  	}
++	}
++  foreach(key;stpt300) {
++  	if (key == nil) {
++		ret = ret~sprintf("STPT,%d,nil|",iter+300);
++  	} else {
++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+300,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+300));
++    }
++    iter += 1;
++  }
++  iter = 0;
++  foreach(key;stpt350) {
++  	if (key == nil) {
++  		ret = ret~sprintf("STPT,%d,nil|",iter+350);
++  	} else {
++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+350,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+350));
++    }
++    iter += 1;
++  }
++  iter = 0;
++  foreach(key;stpt400) {
++  	if (key == nil) {
++  		ret = ret~sprintf("STPT,%d,nil|",iter+400);
++  	} else {
++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+400,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+400));
++    }
++    iter += 1;
++  }
++  iter = 0;
++  foreach(key;stpt450) {
++  	if (key == nil) {
++  		ret = ret~sprintf("STPT,%d,nil|",iter+450);
++  	} else {
++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+450,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+450));
++    }
++    iter += 1;
++  }
++  iter = 0;
++  foreach(key;stpt500) {
++  	if (key == nil) {
++  		ret = ret~sprintf("STPT,%d,nil|",iter+500);
++  	} else {
++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+500,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+500));
++    }
++    iter += 1;
++  }
++  iter = 0;
++  foreach(key;stpt555) {
++  	if (key == nil) {
++  		ret = ret~sprintf("STPT,%d,nil|",iter+555);
++  	} else {
++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+555,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+555));
++    }
++    iter += 1;
++  }
++  ret = ret~sprintf("IFF,%d|",getprop("instrumentation/iff/channel-selection"));
++  ret = ret~sprintf("DATALINK,%d|",getprop("instrumentation/datalink/channel"));
++  ret = ret~sprintf("COM1,%.2f|",getprop("instrumentation/comm[0]/frequencies/selected-mhz"));
++  ret = ret~sprintf("COM1S,%.2f|",getprop("instrumentation/comm[0]/frequencies/standby-mhz"));
++  ret = ret~sprintf("COM2,%.2f|",getprop("instrumentation/comm[1]/frequencies/selected-mhz"));
++  ret = ret~sprintf("COM2S,%.2f|",getprop("instrumentation/comm[1]/frequencies/standby-mhz"));
++  ret = ret~sprintf("ALOW,%d|",getprop("f16/settings/cara-alow"));
++  ret = ret~sprintf("BINGO,%d|",getprop("f16/settings/bingo"));
++  ret = ret~sprintf("SQUAWK,%04d|",getprop("instrumentation/transponder/id-code"));
++  return ret;
++}
++
++var unserialize = func(m) {
++  var stpts = split("|",m);
++  var planned = nil;
++
++  # clear memory:
++  lines = [nil,nil,nil,nil];
++  stpt300 = setsize([],number_of_threat_circles);#Threat circles
++  stpt350 = setsize([],10);#Generic
++  stpt400 = setsize([],5);#Markpoints Own
++  stpt450 = setsize([],5);#Markpoints DL
++  stpt500 = setsize([],1);#Weapon
++  stpt555 = setsize([],1);#Bullseye
++  ded.dataEntryDisplay.page = ded.pCNI;
++  current = nil;
++
++  foreach(item;stpts) {
++    #if (size(item)>4) {#why is this chekc even here???!
++      var items = split(",", item);
++      var key = items[0];
++
++      if (key == "PLAN") {
++      	var number = num(items[1]);
++      	if (planned == nil) planned = createFlightplan();
++      	var plan = planned;
++      	var wp = createWP(num(items[2]), num(items[3]), sprintf("STPT-%02d",number+1));
++		plan.insertWP(wp, number);
++		if (num(items[4]) != EMPTY_ALT) {
++			var leg = plan.getWP(plan.getPlanSize()-1);
++			leg.setAltitude(num(items[4]), "at");
++		}
++		if (size(items) > 5) { # TOS is supported
++            setNumberDesiredTOS(number+1, num(items[5]));
++        }
++      } elsif (key == "LINE") {
++      	var number = num(items[1]);
++      	var no = number >= 200;
++      	if (number >= 700) {
++      		no = 3;
++      	} elsif (number >= 600) {
++      		no = 2;
++      	}
++      	if (lines[no] == nil) {
++      		lines[no] = createFlightplan();
++      	}
++      	var wp = createWP(num(items[2]), num(items[3]), ""~number);
++      	number = no==1?number-200:(no==0?number-100:(no==2?number-600:number-700));
++		lines[no].insertWP(wp, number);
++      } elsif (key == "STPT") {
++      	var newST = nil;
++      	if (items[2]!="nil") {
++      		newST = STPT.new();
++      		newST.lat    = num(items[2]);
++      		newST.lon    = num(items[3]);
++      		newST.alt    = num(items[4]);
++      		newST.radius = num(items[5]);
++      		newST.color  = num(items[6]);
++      		newST.type   =     items[7];
++      	}
++      	var number = num(items[1]);
++      	if (number >= 555) {
++      		stpt555[number-555] = newST;
++
++      	} elsif (number >= 500) {
++      		stpt500[number-500] = newST;
++
++      	} elsif (number >= 450) {
++      		stpt450[number-450] = newST;
++      		dlMarkIndex = number-450;
++      	} elsif (number >= 400) {
++      		stpt400[number-400] = newST;
++      		ownMarkIndex = number-400;
++      	} elsif (number >= 350) {
++      		stpt350[number-350] = newST;
++
++      	} elsif (number >= 300) {
++      		stpt300[number-300] = newST;
++      	}
++      	if (size(items) > 8) { # TOS is supported
++            setNumberDesiredTOS(number, num(items[8]));
++        }
++
++      } elsif (key == "IFF") {
++      	setprop("instrumentation/iff/channel-selection", num(items[1]));
++      } elsif (key == "DATALINK") {
++      	setprop("instrumentation/datalink/channel", num(items[1]));
++      } elsif (key == "COM1") {
++      	setprop("instrumentation/comm[0]/frequencies/selected-mhz", num(items[1]));
++      } elsif (key == "COM1S") {
++      	setprop("instrumentation/comm[0]/frequencies/standby-mhz", num(items[1]));
++      } elsif (key == "COM2") {
++      	setprop("instrumentation/comm[1]/frequencies/selected-mhz", num(items[1]));
++      } elsif (key == "COM2S") {
++      	setprop("instrumentation/comm[1]/frequencies/standby-mhz", num(items[1]));
++      } elsif (key == "ALOW") {
++      	setprop("f16/settings/cara-alow", num(items[1]));
++      } elsif (key == "BINGO") {
++      	setprop("f16/settings/bingo", num(items[1]));
++      } elsif (key == "SQUAWK") {
++      	setprop("instrumentation/transponder/id-code", num(items[1]));
++      }
++    #}
++  }
++  if (planned != nil) {
++  	fgcommand("activate-flightplan", props.Node.new({"activate": 0}));
++  	planned.activate();
++  	fgcommand("activate-flightplan", props.Node.new({"activate": 1}));
++  }
++}
++
++var saveSTPTs = func (path) {
++    var text = serialize();
++    var opn = nil;
++    call(func{opn = io.open(path,"w");},nil, var err = []);
++    if (size(err) or opn == nil) {
++      print("error open file for writing STPTs");
++      gui.showDialog("savefail");
++      return 0;
++    }
++    call(func{var text = io.write(opn,text);},nil, var err = []);
++    if (size(err)) {
++      print("error writing file with STPTs");
++      setprop("f16/preplanning-status", err[0]);
++      io.close(opn);
++      gui.showDialog("savefail");
++      return 0;
++    } else {
++      io.close(opn);
++      setprop("f16/preplanning-status", "DTC data saved");
++      return 1;
++    }
++}
++
++var loadSTPTs = func (path) {
++    var text = nil;
++    call(func{text=io.readfile(path);},nil, var err = []);
++    if (size(err)) {
++      print("Loading STPTs failed.");
++      setprop("f16/preplanning-status", err[0]);
++      gui.showDialog("loadfail");
++    } elsif (text != nil) {
++      unserialize(text);
++      setprop("f16/preplanning-status", "DTC data loaded");
++    }
++}
++
++setprop("sim/fg-home-export", getprop("sim/fg-home")~"/Export");
+\ No newline at end of file
+diff --git a/Nasal/tacview.nas b/Nasal/tacview.nas
+new file mode 100644
+index 0000000..3090bf9
+--- /dev/null
++++ b/Nasal/tacview.nas
+@@ -0,0 +1,437 @@
++# Copyright by Justin Nicholson (aka Pinto)
++# Released under the GNU General Public License version 2.0
++#
++# Authors: Pinto, Nikolai V. Chr., Colin Geniet
++
++# Short installation instructions:
++# - Add and load this file in the 'tacview' namespace.
++# - Adjust the four parameters just below.
++# - Set property /payload/d-config/tacview_supported=1
++# - Ensure the radar code sets 'tacobj' fields properly.
++#   In Nikolai/Richard generic 'radar-system.nas',
++#   this simply requires setting 'enable_tacobject=1'.
++# - Add some way to start/stop recording.
++
++### Parameters to adjust (example values from the F-16)
++
++# Aircraft type string for tacview
++var tacview_ac_type = "F-16A";
++# Aircraft type as inserted in the output file name
++var filename_ac_type = "f16";
++
++# Function returning an array of "contact" objects, containing all aicrafts tacview is to show.
++# A contact object must
++# - implement the API specified by missile-code.nas
++# - have a getModel() method, which will be used as aircraft type designator in tacview.
++# - contain a field 'tacobj', which must be an instance of the 'tacobj' class below,
++#   and have the 'tacviewID' and 'valid' fields set appropriately.
++#
++var get_contacts_list = func {
++    return radar_system.getCompleteList();
++}
++
++# Function returning the focused/locked aircraft, as a "contact" object (or nil).
++var get_primary_contact = func {
++    return radar_system.apg68Radar.getPriorityTarget();
++}
++
++# Radar range. May return nil if n/a
++var get_radar_range_nm = func {
++    return radar_system.apg68Radar.getRange();
++}
++
++### End of parameters
++
++
++var main_update_rate = 0.3;
++var write_rate = 10;
++
++var outstr = "";
++
++var timestamp = "";
++var output_file = "";
++var f = "";
++var myplaneID = int(rand()*10000);
++var starttime = 0;
++var writetime = 0;
++
++var seen_ids = [];
++
++var tacobj = {
++    tacviewID: 0,
++    lat: 0,
++    lon: 0,
++    alt: 0,
++    roll: 0,
++    pitch: 0,
++    heading: 0,
++    speed: -1,
++    valid: 0,
++};
++
++var lat = 0;
++var lon = 0;
++var alt = 0;
++var roll = 0;
++var pitch = 0;
++var heading = 0;
++var speed = 0;
++var mutexWrite = thread.newlock();
++
++var input = {
++    mp_host:    "sim/multiplay/txhost",
++    radar:      "sim/multiplay/generic/int[2]",
++    fuel:       "consumables/fuel/total-fuel-lbs",
++    gear:       "gear/gear[0]/position-norm",
++    lat:        "position/latitude-deg",
++    lon:        "position/longitude-deg",
++    alt:        "position/altitude-ft",
++    roll:       "orientation/roll-deg",
++    pitch:      "orientation/pitch-deg",
++    heading:    "orientation/heading-deg",
++    tas:        "fdm/jsbsim/velocities/vtrue-kts",
++    cas:        "velocities/airspeed-kt",
++    mach:       "velocities/mach",
++    aoa:        "orientation/alpha-deg",
++    gforce:     "accelerations/pilot-g",
++};
++
++foreach (var name; keys(input)) {
++    input[name] = props.globals.getNode(input[name], 1);
++}
++
++
++var startwrite = func() {
++    if (starttime)
++        return;
++
++    timestamp = getprop("/sim/time/utc/year") ~ "-" ~ getprop("/sim/time/utc/month") ~ "-" ~ getprop("/sim/time/utc/day") ~ "T";
++    timestamp = timestamp ~ getprop("/sim/time/utc/hour") ~ ":" ~ getprop("/sim/time/utc/minute") ~ ":" ~ getprop("/sim/time/utc/second") ~ "Z";
++    var filetimestamp = string.replace(timestamp,":","-");
++    output_file = getprop("/sim/fg-home") ~ "/Export/tacview-" ~ filename_ac_type ~ "-" ~ filetimestamp ~ ".acmi";
++    # create the file
++    f = io.open(output_file, "w");
++    io.close(f);
++    var color = ",Color=Blue";
++    if (left(getprop("sim/multiplay/callsign"),5)=="OPFOR") {
++        color=",Color=Red";
++    }
++    var meta = sprintf(",DataSource=FlightGear %s,DataRecorder=%s v%s", getprop("sim/version/flightgear"), getprop("sim/description"), getprop("sim/aircraft-version"));
++    thread.lock(mutexWrite);
++    write("FileType=text/acmi/tacview\nFileVersion=2.1\n");
++    write("0,ReferenceTime=" ~ timestamp ~ meta ~ "\n#0\n");
++    write(myplaneID ~ ",T=" ~ getLon() ~ "|" ~ getLat() ~ "|" ~ getAlt() ~ "|" ~ getRoll() ~ "|" ~ getPitch() ~ "|" ~ getHeading() ~ ",Name="~tacview_ac_type~",CallSign="~getprop("/sim/multiplay/callsign")~color~"\n"); #
++    thread.unlock(mutexWrite);
++    starttime = systime();
++    setprop("/sim/screen/black","Starting Tacview recording");
++    main_timer.start();
++}
++
++var stopwrite = func() {
++    main_timer.stop();
++    setprop("/sim/screen/black","Stopping Tacview recording");
++    writetofile();
++    starttime = 0;
++    seen_ids = [];
++    explo_arr = [];
++    explosion_timeout_loop(1);
++}
++
++var mainloop = func() {
++    if (!starttime) {
++        main_timer.stop();
++        return;
++    }
++    if (systime() - writetime > write_rate) {
++        writetofile();
++    }
++    thread.lock(mutexWrite);
++    write("#" ~ (systime() - starttime)~"\n");
++    thread.unlock(mutexWrite);
++    writeMyPlanePos();
++    writeMyPlaneAttributes();
++    foreach (var cx; get_contacts_list()) {
++        if(cx.get_type() == armament.ORDNANCE) {
++            continue;
++        }
++        if (cx["prop"] != nil and cx.prop.getName() == "multiplayer" and input.mp_host.getValue() == "mpserver.opredflag.com") {
++            continue;
++        }
++        var color = ",Color=Blue";
++        if (left(cx.get_Callsign(),5)=="OPFOR" or left(cx.get_Callsign(),4)=="OPFR") {
++            color=",Color=Red";
++        }
++        thread.lock(mutexWrite);
++        if (find_in_array(seen_ids, cx.tacobj.tacviewID) == -1) {
++            append(seen_ids, cx.tacobj.tacviewID);
++            var model_is = cx.getModel();
++            if (model_is=="Mig-28") {
++                model_is = tacview_ac_type;
++                color=",Color=Red";
++            }
++            write(cx.tacobj.tacviewID ~ ",Name="~ model_is~ ",CallSign=" ~ cx.get_Callsign() ~color~"\n")
++        }
++        if (cx.tacobj.valid) {
++            var cxC = cx.getCoord();
++            lon = cxC.lon();
++            lat = cxC.lat();
++            alt = cxC.alt();
++            roll = cx.get_Roll();
++            pitch = cx.get_Pitch();
++            heading = cx.get_heading();
++            speed = cx.get_Speed()*KT2MPS;
++
++            write(cx.tacobj.tacviewID ~ ",T=");
++            if (lon != cx.tacobj.lon) {
++                write(sprintf("%.6f",lon));
++                cx.tacobj.lon = lon;
++            }
++            write("|");
++            if (lat != cx.tacobj.lat) {
++                write(sprintf("%.6f",lat));
++                cx.tacobj.lat = lat;
++            }
++            write("|");
++            if (alt != cx.tacobj.alt) {
++                write(sprintf("%.1f",alt));
++                cx.tacobj.alt = alt;
++            }
++            write("|");
++            if (roll != cx.tacobj.roll) {
++                write(sprintf("%.1f",roll));
++                cx.tacobj.roll = roll;
++            }
++            write("|");
++            if (pitch != cx.tacobj.pitch) {
++                write(sprintf("%.1f",pitch));
++                cx.tacobj.pitch = pitch;
++            }
++            write("|");
++            if (heading != cx.tacobj.heading) {
++                write(sprintf("%.1f",heading));
++                cx.tacobj.heading = heading;
++            }
++            if (speed != cx.tacobj.speed) {
++                write(sprintf(",TAS=%.1f",speed));
++                cx.tacobj.speed = speed;
++            }
++            write("\n");
++        }
++        thread.unlock(mutexWrite);
++    }
++    explosion_timeout_loop();
++}
++
++var main_timer = maketimer(main_update_rate, mainloop);
++
++
++var writeMyPlanePos = func() {
++    thread.lock(mutexWrite);
++    write(myplaneID ~ ",T=" ~ getLon() ~ "|" ~ getLat() ~ "|" ~ getAlt() ~ "|" ~ getRoll() ~ "|" ~ getPitch() ~ "|" ~ getHeading() ~ "\n");
++    thread.unlock(mutexWrite);
++}
++
++var writeMyPlaneAttributes = func() {
++    var tgt = "";
++    var contact = get_primary_contact();
++    if (contact != nil) {
++        tgt= ",FocusedTarget="~contact.tacobj.tacviewID;
++    }
++    var rmode = ",RadarMode=1";
++    if (input.radar.getBoolValue()) {
++        rmode = ",RadarMode=0";
++    }
++    var rrange = get_radar_range_nm();
++    if (rrange != nil) {
++        rrange = sprintf(",RadarRange=%.0f", get_radar_range_nm()*NM2M);
++    } else {
++        rrange = "";
++    }
++    var fuel = sprintf(",FuelWeight=%.0f", input.fuel.getValue());
++    var gear = sprintf(",LandingGear=%.2f", input.gear.getValue());
++    var tas = getTas();
++    if (tas != nil) {
++        tas = ",TAS="~tas;
++    } else {
++        tas = "";
++    }
++    var str = myplaneID ~ fuel~rmode~rrange~gear~tas~",CAS="~getCas()~",Mach="~getMach()~",AOA="~getAoA()~",HDG="~getHeading()~tgt~",VerticalGForce="~getG()~"\n";#",Throttle="~getThrottle()~",Afterburner="~getAfterburner()~
++    thread.lock(mutexWrite);
++    write(str);
++    thread.unlock(mutexWrite);
++}
++
++var explo = {
++    tacviewID: 0,
++    time: 0,
++};
++
++var explo_arr = [];
++
++# needs threadlocked before calling
++var writeExplosion = func(lat,lon,altm,rad) {
++    var e = {parents:[explo]};
++    e.tacviewID = 21000 + int(math.floor(rand()*20000));
++    e.time = systime();
++    append(explo_arr, e);
++    write("#" ~ (systime() - starttime)~"\n");
++    write(e.tacviewID ~",T="~lon~"|"~lat~"|"~altm~",Radius="~rad~",Type=Explosion\n");
++}
++
++var explosion_timeout_loop = func(all = 0) {
++    foreach(var e; explo_arr) {
++        if (e.time) {
++            if (systime() - e.time > 15 or all) {
++                thread.lock(mutexWrite);
++                write("#" ~ (systime() - starttime)~"\n");
++                write("-"~e.tacviewID);
++                thread.unlock(mutexWrite);
++                e.time = 0;
++            }
++        }
++    }
++}
++
++var write = func(str) {
++    outstr = outstr ~ str;
++}
++
++var writetofile = func() {
++    if (outstr == "") {
++        return;
++    }
++    writetime = systime();
++    f = io.open(output_file, "a");
++    io.write(f, outstr);
++    io.close(f);
++    outstr = "";
++}
++
++var getLat = func() {
++    return input.lat.getValue();
++}
++
++var getLon = func() {
++    return input.lon.getValue();
++}
++
++var getAlt = func() {
++    return sprintf("%.2f", input.alt.getValue() * FT2M);
++}
++
++var getRoll = func() {
++    return sprintf("%.2f", input.roll.getValue());
++}
++
++var getPitch = func() {
++    return sprintf("%.2f", input.pitch.getValue());
++}
++
++var getHeading = func() {
++    return sprintf("%.2f", input.heading.getValue());
++}
++
++var getTas = func() {
++    var tas = input.tas.getValue();
++    if (tas != nil)
++        return sprintf("%.1f", tas * KT2MPS);
++    else
++        return nil;
++}
++
++var getCas = func() {
++    return sprintf("%.1f", input.cas.getValue() * KT2MPS);
++}
++
++var getMach = func() {
++    return sprintf("%.3f", input.mach.getValue());
++}
++
++var getAoA = func() {
++    return sprintf("%.2f", input.aoa.getValue());
++}
++
++var getG = func() {
++    return sprintf("%.2f", input.gforce.getValue());
++}
++
++#var getThrottle = func() {
++#    return sprintf("%.2f", getprop("velocities/thrust");
++#}
++
++#var getAfterburner = func() {
++#    return getprop("velocities/thrust")>0.61*0.61;
++#}
++
++var find_in_array = func(arr,val) {
++    forindex(var i; arr) {
++        if ( arr[i] == val ) {
++            return i;
++        }
++    }
++    return -1;
++}
++
++#setlistener("/controls/armament/pickle", func() {
++#    if (!starttime) {
++#        return;
++#    }
++#    thread.lock(mutexWrite);
++#    write("#" ~ (systime() - starttime)~"\n");
++#    write("0,Event=Message|"~ myplaneID ~ "|Pickle, selection at " ~ (getprop("controls/armament/pylon-knob") + 1) ~ "\n");
++#    thread.unlock(mutexWrite);
++#},0,0);
++
++setlistener("/controls/armament/trigger", func(p) {
++    if (!starttime) {
++        return;
++    }
++    thread.lock(mutexWrite);
++    if (p.getValue()) {
++        write("#" ~ (systime() - starttime)~"\n");
++        write("0,Event=Message|"~ myplaneID ~ "|Trigger pressed.\n");
++    } else {
++        write("#" ~ (systime() - starttime)~"\n");
++        write("0,Event=Message|"~ myplaneID ~ "|Trigger released.\n");
++    }
++    thread.unlock(mutexWrite);
++},0,0);
++
++setlistener("/sim/multiplay/chat-history", func(p) {
++    if (!starttime) {
++        return;
++    }
++    var hist_vector = split("\n",p.getValue());
++    if (size(hist_vector) > 0) {
++        var last = hist_vector[size(hist_vector)-1];
++        last = string.replace(last,",",chr(92)~chr(44));#"\x5C"~"\x2C"
++        thread.lock(mutexWrite);
++        write("#" ~ (systime() - tacview.starttime)~"\n");
++        write("0,Event=Message|Chat ["~last~"]\n");
++        thread.unlock(mutexWrite);
++    }
++},0,0);
++
++
++var msg = func (txt) {
++    if (!starttime) {
++        return;
++    }
++    thread.lock(mutexWrite);
++    write("#" ~ (systime() - tacview.starttime)~"\n");
++    write("0,Event=Message|"~myplaneID~"|AI ["~txt~"]\n");
++    thread.unlock(mutexWrite);
++}
++
++setlistener("damage/sounds/explode-on", func(p) {
++    if (!starttime) {
++        return;
++    }
++
++    if (p.getValue()) {
++        thread.lock(mutexWrite);
++        write("#" ~ (systime() - tacview.starttime)~"\n");
++        write("0,Event=Destroyed|"~myplaneID~"\n");
++        thread.unlock(mutexWrite);
++    }
++},0,0);
+diff --git a/Nasal/tgp.nas b/Nasal/tgp.nas
+new file mode 100644
+index 0000000..36a168e
+--- /dev/null
++++ b/Nasal/tgp.nas
+@@ -0,0 +1,977 @@
++# Copyright (C) 2016  onox
++#
++# This program is free software: you can redistribute it and/or modify
++# it under the terms of the GNU General Public License as published by
++# the Free Software Foundation; either version 2 of the License, or
++# (at your option) any later version.
++#
++# This program is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++# GNU General Public License for more details.
++#
++# You should have received a copy of the GNU General Public License
++# along with this program.  If not, see <http://www.gnu.org/licenses/>.
++#
++# Lines below FLIRCameraUpdater has been modified/added by Nikolai V. Chr.
++#
++# Position of the FLIR camera ([z (back), x (right), y (up)])
++var coords_cam = [
++    getprop("/sim/view[105]/config/z-offset-m"),
++    getprop("/sim/view[105]/config/x-offset-m"),
++    getprop("/sim/view[105]/config/y-offset-m")
++];
++io.include("Aircraft/Generic/updateloop.nas");
++#io.load_nasal(getprop("/sim/fg-root") ~ "/Aircraft/c172p/Nasal/generic/math_ext2.nas","math_ext2");
++var FLIRCameraUpdater = {
++
++    new: func {
++        var m = {
++            parents: [FLIRCameraUpdater, Updatable]
++        };
++        m.loop = UpdateLoop.new(components: [m], update_period: 0.0);
++
++        # Create a function to update the position of the FLIR camera
++        m.update_cam = me._get_flir_auto_updater(180.0);
++
++        # Create a function to update the position using an input device
++        m.manual_update_cam = me._get_flir_updater(180.0, m.update_cam);
++
++        m.click_coord_cam = nil;
++
++        m.listeners = std.Vector.new();
++
++        m.offsetP = 0;
++        m.offsetH = 0;
++
++        return m;
++    },
++
++    enable: func {
++        #me.loop.reset();
++        me.loop.enable();
++    },
++
++    disable: func {
++        #me.remove_listeners();
++        me.loop.disable();
++    },
++
++    enable_or_disable: func (enable) {
++        if (enable) {
++            me.enable();
++        }
++        else {
++            me.disable();
++        }
++    },
++
++    remove_listeners: func {
++        foreach (var listener; me.listeners.vector) {
++            removelistener(listener);
++        }
++        me.listeners.clear();
++    },
++
++    reset: func {
++        #print("reset called?!?!");
++        return;
++        me.remove_listeners();
++        me.listeners.append(setlistener("/sim/signals/click", func {
++            var lat = getprop("/sim/input/click/latitude-deg");
++            var lon = getprop("/sim/input/click/longitude-deg");
++            var elev = getprop("/sim/input/click/elevation-m");
++
++            var click_position = geo.Coord.new().set_latlon(lat, lon, elev);
++
++            var origin_position = geo.aircraft_position();
++            var distance_m = origin_position.direct_distance_to(click_position);
++
++            if (getprop("/aircraft/flir/locks/auto-track")) {
++                me.click_coord_cam = click_position;
++                setprop("/aircraft/flir/target/auto-track", 1);
++                logger.screen.white(sprintf("New tracking position at %d meter distance", distance_m));
++            }
++            else {
++                setprop("/aircraft/flir/target/auto-track", 0);
++                me.click_coord_cam = nil;
++                logger.screen.red("Press F6 to enable automatic tracking by FLIR camera");
++            }
++        }));
++
++        me.listeners.append(setlistener("/aircraft/flir/locks/auto-track", func (n) {
++            setprop("/aircraft/flir/target/auto-track", 0);
++            me.click_coord_cam = nil;
++            if (n.getBoolValue()) {
++                logger.screen.green("Automatic tracking by FLIR camera enabled. Click on the terrain to start tracking.");
++            }
++            else {
++                logger.screen.red("Automatic tracking by FLIR camera disabled");
++            }
++        }));
++    },
++
++    update: func (dt) {
++        var roll_deg  = getprop("/orientation/roll-deg");
++        var pitch_deg = getprop("/orientation/pitch-deg");
++        var heading   = getprop("/orientation/heading-deg");
++
++        var computer = me._get_flir_computer(roll_deg, pitch_deg, heading);
++
++        if (getprop("/aircraft/flir/target/auto-track") and me.click_coord_cam != nil) {
++
++            var (yaw, pitch, distance) = computer(coords_cam, me.click_coord_cam);
++            #printf("C %.5f,%.5f,%.5f",me.click_coord_cam.lat(),me.click_coord_cam.lon(),me.click_coord_cam.alt());
++            if (lock_tgp) {
++                #print("L");
++                me.update_cam(roll_deg, pitch_deg, yaw, pitch);
++            } else {
++                #print("NO      LLLLLLLLLLL");
++                me.update_cam(roll_deg, pitch_deg, yaw+me.offsetH, pitch+me.offsetP);
++            }
++        }
++#        else {
++#            me.manual_update_cam(roll_deg, pitch_deg);
++#        }
++    },
++
++    aim: func () {
++        var roll_deg  = getprop("/orientation/roll-deg");
++        var pitch_deg = getprop("/orientation/pitch-deg");
++        var heading   = getprop("/orientation/heading-deg");
++
++        var computer = me._get_flir_computer(roll_deg, pitch_deg, heading);
++
++        if (getprop("/sim/current-view/name") == "TGP" and me.click_coord_cam != nil) {
++            #printf("B %.5f,%.5f,%.5f",me.click_coord_cam.lat(),me.click_coord_cam.lon(),me.click_coord_cam.alt());
++            me.click_coord_cam.lat();
++            var (yaw, pitch, distance) = computer(coords_cam, me.click_coord_cam);
++            me.update_cam(roll_deg, pitch_deg, yaw, pitch);
++        }
++    },
++
++    ######################################################################
++    # Gyro stabilization                                                 #
++    ######################################################################
++
++    _get_flir_updater: func (offset, updater) {
++        return func (roll_deg, pitch_deg) {
++            var yaw   = getprop("/aircraft/flir/input/yaw-deg") + (180.0 - offset);
++            var pitch = getprop("/aircraft/flir/input/pitch-deg");
++
++            updater(roll_deg, pitch_deg, yaw, pitch);
++        };
++    },
++
++    ######################################################################
++    # Automatic tracking computation                                     #
++    ######################################################################
++
++    _get_flir_auto_updater: func (offset) {
++        return func (roll_deg, pitch_deg, yaw, pitch) {
++            (yaw, pitch) = math_ext2.get_yaw_pitch_body(roll_deg, pitch_deg, yaw, pitch, offset);
++
++            setprop("/aircraft/flir/target/yaw-deg", yaw);
++            setprop("/aircraft/flir/target/pitch-deg", pitch);
++            if (getprop("/sim/current-view/name") == "TGP") {
++                setprop("/sim/current-view/goal-heading-offset-deg", -yaw);
++                setprop("/sim/current-view/goal-pitch-offset-deg", pitch);
++            }
++            setprop("sim/view[105]/heading-offset-deg", yaw);
++            setprop("sim/view[105]/pitch-offset-deg", pitch);
++        };
++    },
++
++    _get_flir_computer: func (roll_deg, pitch_deg, heading) {
++        return func (coords, target) {
++            var (position_2d, position) = math_ext2.get_point(coords[0], coords[1], coords[2], roll_deg, pitch_deg, heading);
++            return get_yaw_pitch_distance_inert(position_2d, position, target, heading);
++        }
++    }
++
++};
++
++get_yaw_pitch_distance_inert = func (position_2d, position, target_position, heading, f=nil) {
++    # Does the same as Onox's version, except takes curvature of Earth into account.
++    #printf("A %.5f,%.5f,%.5f",target_position.lat(),target_position.lon(),target_position.alt());
++    target_position.lat();
++    var heading_deg = positioned.courseAndDistance(position_2d, target_position)[0] - heading;
++    var pitch_deg   = vector.Math.getPitch(position, target_position);
++    var distance_m  = position.direct_distance_to(target_position);
++    return [heading_deg, pitch_deg, distance_m];
++}
++
++var flir_updater = FLIRCameraUpdater.new();
++
++setlistener("/sim/signals/fdm-initialized", func {
++    setlistener("/aircraft/flir/target/view-enabled", func (node) {
++        flir_updater.enable_or_disable(node.getBoolValue());
++    }, 1, 0);
++});
++
++var steerlock = 0;
++var enable = 1;
++var camera_movement_speed_lock = 75;#Higher number means slower
++var camera_movement_speed_free =  5;
++
++var list = func (node) {
++    var button = getprop("controls/MFD[2]/button-pressed");
++
++    if (button == 20) {#BACK
++        view.setViewByIndex(0);
++        #setprop("/aircraft/flir/target/auto-track", 0);
++        #lock.hide();
++        #setprop("f16/avionics/lock-flir",0.05);
++        return;
++    } elsif (button == 3) {#STBY/A-G/A-A
++        if (getprop("f16/avionics/power-mfd") and getprop("f16/avionics/power-ufc-warm")==1 and getprop("f16/avionics/power-right-hdpt") == 1 and getprop("fdm/jsbsim/elec/bus/ess-dc") > 20) {
++            masterMode = !masterMode;
++        }
++    }
++    if (!enable) return;
++
++    if (button == 0 and node.getName() == "button-pressed") {
++        setprop("controls/displays/cursor-slew-x", 0);
++        setprop("controls/displays/cursor-slew-y", 0);
++    }
++
++    if (button == 1 or (getprop("controls/displays/cursor-click") and getprop("/sim/current-view/name") == "TGP")) {#LOCK
++        gps = 0;
++        if (lock_tgp) {
++            lock_tgp = 0;
++            armament.contactPoint = nil;print("Second click with TGP lock unlocks!");
++            return;
++        }
++        var x = -2.5856;
++        var y =  0.8536;
++        var z = -1.4121;
++        var pos = aircraftToCart({x:-x, y:y, z: -z});
++        var coordA = geo.Coord.new();
++        coordA.set_xyz(pos.x, pos.y, pos.z);
++        coordA.alt();# TODO: once fixed in FG this line is no longer needed.
++        var matrixMath = 0;
++        if (matrixMath) {
++            var dirCoord = geo.Coord.new(coordA);
++            var vHead = getprop("sim/current-view/heading-offset-deg");
++            var vPitch = getprop("sim/current-view/pitch-offset-deg");
++
++            var vectorF = vector.Math.eulerToCartesian3X(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
++            var vectorL = vector.Math.eulerToCartesian3Y(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
++            var vectorU = vector.Math.eulerToCartesian3Z(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
++            var viewM   = vector.Math.viewMatrix(vectorF,vectorL,vectorU);
++            var pitchM = vector.Math.pitchMatrix(vPitch);
++            var yawM   = vector.Math.yawMatrix(-vHead);
++            var rotation = vector.Math.multiplyMatrices(pitchM, yawM);#heading, pitch
++            var viewGlobal = vector.Math.multiplyMatrices4(viewM, vector.Math.to4x4(rotation));#order?
++            #viewGlobal = vector.Math.multiplyMatrices4(viewGlobal,vector.Math.mirrorMatrix);
++            #var vectorA = [viewGlobal[2],viewGlobal[6],viewGlobal[10]];
++            var vectorA = vector.Math.normalize(vector.Math.xFromView(viewGlobal));
++            #vectorA = vector.Math.multiplyMatrixWithVector(rotation, vectorF);
++            print(vector.Math.format(vectorA));
++            var set = vector.Math.cartesianToEuler(vectorA);
++
++            #if (set[0] == nil) {print("0 heading");return;}
++            #printf("%d heading %d pitch",set[0],set[1]);
++            dirCoord.apply_course_distance(set[0],50);
++            var up = math.tan(set[1]*D2R)*50;
++            dirCoord.set_alt(coordA.alt()+up);
++        }
++
++        # get quaternion for view rotation:
++        var q = [getprop("sim/current-view/debug/orientation-w"),getprop("sim/current-view/debug/orientation-x"),getprop("sim/current-view/debug/orientation-y"),getprop("sim/current-view/debug/orientation-z")];
++
++        var V = [2 * (q[1] * q[3] - q[0] * q[2]), 2 * (q[2] * q[3] + q[0] * q[1]),1 - 2 * (q[1] * q[1] + q[2] * q[2])];
++        var w= q[0];
++        var x= q[1];
++        var y= q[2];
++        var z= q[3];
++
++        #rotate from x axis using the quaternion:
++        V = [1 - 2 * (y*y + z*z),2 * (x*y + w*z),2 * (x*z - w*y)];
++
++        var xyz          = {"x":coordA.x(),                "y":coordA.y(),               "z":coordA.z()};
++        #var directionLOS = {"x":dirCoord.x()-coordA.x(),   "y":dirCoord.y()-coordA.y(),  "z":dirCoord.z()-coordA.z()};
++        var directionLOS = {"x":V[0],   "y":V[1],  "z":V[2]};
++
++        # Check for terrain between own weapon and target:
++        var terrainGeod = get_cart_ground_intersection(xyz, directionLOS);
++        if (terrainGeod == nil) {
++            #print("0 terrain");
++            return;
++        } else {
++            var terrain = geo.Coord.new();
++            terrain.set_latlon(terrainGeod.lat, terrainGeod.lon, terrainGeod.elevation);
++            var ut = nil;
++            foreach (u ; radar_system.getCompleteList()) {
++                if (terrain.direct_distance_to(u.get_Coord())<45) {
++                    ut = u;
++                    break;
++                }
++            }
++            if (ut!=nil) {
++                var contact = ut.getNearbyVirtualTGPContact();
++                armament.contactPoint = contact;
++                #var tc = contact.getCoord();
++                #print("contactPoint "~tc.lat()~", "~tc.lon()~" at "~(tc.alt()*M2FT)~" ft");
++            } else {
++                armament.contactPoint = radar_system.ContactTGP.new("TGP-Spot",terrain,1);
++            }
++            #flir_updater.click_coord_cam = terrain;
++            #setprop("/aircraft/flir/target/auto-track", 1);
++            #interpolate("f16/avionics/lock-flir",1,1.5);
++            #flir_updater.offsetP = 0;
++            #flir_updater.offsetH = 0;# commented so we get back to where we were when unlocking
++            lock_tgp = 1;
++        }
++    } elsif (button == 6) {#TV/IR
++        ir = !ir;
++    } elsif (button == 9) {#CZ
++        if (lock_tgp) return;
++        gps = 0;
++        if (getprop("/aircraft/flir/target/auto-track")) {
++            flir_updater.offsetP = 0;
++            flir_updater.offsetH = 0;
++        } else {
++            interpolate("sim/current-view/pitch-offset-deg", -30, 2.5);
++            interpolate("sim/current-view/heading-offset-deg", 0, 2.5);
++        }
++    } elsif (button == 10) {#MARK
++        if (!lock_tgp or armament.contactPoint == nil) return;
++        line10.setText("#"~steerpoints.markTGP(armament.contactPoint.get_Coord()));
++        settimer(func {line10.setText("MARK");}, 2.5);
++    } elsif (button == 11) {#UP
++        if (lock_tgp) return;
++        gps = 0;
++        setprop("controls/displays/cursor-slew-y", -1);
++        return;
++        var fov = getprop("sim/current-view/field-of-view");
++        if (getprop("/aircraft/flir/target/auto-track")) {
++            flir_updater.offsetP += fov/camera_movement_speed_lock;
++        } else {
++            setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")+fov/camera_movement_speed_free);
++        }
++    } elsif (button == 12) {#DOWN
++        if (lock_tgp) return;
++        gps = 0;
++        setprop("controls/displays/cursor-slew-y", 1);
++        return;
++        var fov = getprop("sim/current-view/field-of-view");
++        if (getprop("/aircraft/flir/target/auto-track")) {
++            flir_updater.offsetP -= fov/camera_movement_speed_lock;
++        } else {
++            setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")-fov/camera_movement_speed_free);
++        }
++    } elsif (button == 14) {#LEFT
++        if (lock_tgp) return;
++        gps = 0;
++        setprop("controls/displays/cursor-slew-x", -1);
++        return;
++        var fov = getprop("sim/current-view/field-of-view");
++        if (getprop("/aircraft/flir/target/auto-track")) {
++            flir_updater.offsetH -= fov/camera_movement_speed_lock;
++        } else {
++            setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")+fov/camera_movement_speed_free);
++        }
++    } elsif (button == 15) {#RGHT
++        if (lock_tgp) return;
++        gps = 0;
++        setprop("controls/displays/cursor-slew-x", 1);
++        return;
++        var fov = getprop("sim/current-view/field-of-view");
++        if (getprop("/aircraft/flir/target/auto-track")) {
++            flir_updater.offsetH += fov/camera_movement_speed_lock;
++        } else {
++            setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")-fov/camera_movement_speed_free);
++        }
++    } elsif (button == 13) {#WIDE/NARO
++        wide = !wide;
++    } elsif (button == 2) {#ZOOM
++        zoomlvl += 1;
++        if (zoomlvl > 4) {
++            zoomlvl = 1;
++        }
++    }
++};
++setlistener("controls/MFD[2]/button-pressed", list);
++setlistener("controls/displays/cursor-click", list);
++
++
++var flyupTime = 0;
++var flyupVis = 0;
++
++var fast_loop = func {
++  var viewName = getprop("/sim/current-view/name");
++
++    if (viewName == "TGP" and (getprop("/fdm/jsbsim/gear/unit[0]/WOW") or !getprop("f16/stores/tgp-mounted"))) {
++        # deselect view back to pilot default
++        masterMode = STBY;
++        view.setViewByIndex(0);
++        setprop("sim/rendering/als-filters/use-IR-vision", 0);
++        setprop("sim/view[105]/enabled", 0);
++        pullup_cue_3.setVisible(0);
++    } elsif (viewName == "TGP") {
++        if (!getprop("f16/avionics/power-mfd") or getprop("f16/avionics/power-ufc-warm")!=1) {
++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
++            midl.setText("    MFD OFF   ");
++            bott.setText("");
++            ralt.setText("");
++            line9.hide();
++            line10.hide();
++            line3.setText("");
++            cross.hide();
++            enable = 0;
++            masterMode = STBY;
++            pullup_cue_3.setVisible(0);
++        } elsif (getprop("f16/avionics/power-right-hdpt") == 0 or getprop("fdm/jsbsim/elec/bus/ess-dc") <=20) {
++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
++            midl.setText("      OFF     ");
++            bott.setText("");
++            ralt.setText("");
++            line9.hide();
++            line10.hide();
++            line3.setText("");
++            cross.hide();
++            enable = 0;
++            masterMode = STBY;
++            pullup_cue_3.setVisible(0);
++        } elsif (getprop("f16/avionics/power-right-hdpt-warm") < 1) {
++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
++
++            var to_secs = (1.0-getprop("/f16/avionics/power-right-hdpt-warm"))*180;
++            var mins = int(to_secs/60);
++            var secs = to_secs-mins*60;
++            var ttxt = sprintf(" %1d:%02d ", mins, secs);
++            midl.setText("NOT TIMED OUT");
++            bott.setText(ttxt);
++            ralt.setText("");
++            line9.hide();
++            line10.hide();
++            line3.setText(masterMode==0?"STBY":(hiddenMode==AG?"A-G":"A-A"));
++            cross.hide();
++            enable = 0;
++            pullup_cue_3.setVisible(0);
++        } elsif (masterMode == STBY) {
++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
++            midl.setText("   STANDBY   ");
++            bott.setText("");
++            ralt.setText("");
++            line9.hide();
++            line10.hide();
++            line3.setText("STBY");
++            cross.hide();
++            enable = 0;
++            flyupTime = getprop("instrumentation/radar/time-till-crash");
++            if (flyupTime != nil and flyupTime > 0 and flyupTime < 8) {
++                flyupVis = math.mod(getprop("sim/time/elapsed-sec"), 0.50) < 0.25;
++            } else {
++                flyupVis = 0;
++            }
++            pullup_cue_3.setVisible(flyupVis);
++        } else {
++            canvasMFDext.setColorBackground(1.00, 1.00, 1.00, 0.00);
++            line3.setText(hiddenMode==AG?"A-G":"A-A");
++            cross.show();
++            enable = 1;
++            flyupTime = getprop("instrumentation/radar/time-till-crash");
++            if (flyupTime != nil and flyupTime > 0 and flyupTime < 8) {
++                flyupVis = math.mod(getprop("sim/time/elapsed-sec"), 0.50) < 0.25;
++            } else {
++                flyupVis = 0;
++            }
++            pullup_cue_3.setVisible(flyupVis);
++        }
++
++        # FLIR TGP stuff:
++        setprop("aircraft/flir/target/view-enabled", viewName == "TGP");
++        setprop("sim/rendering/als-filters/use-filtering", viewName == "TGP");
++        setprop("sim/rendering/als-filters/use-IR-vision", viewName == "TGP" and ir);
++        setprop("sim/rendering/als-filters/use-night-vision", 0);
++
++        var x = getprop("sim/gui/canvas/size[0]");
++        var y = getprop("sim/gui/canvas/size[1]");
++
++        var degs = 3.6/zoomlvl;
++        if (wide) {
++            line13.setText("WIDE");
++        } else {
++            degs = 1.0/zoomlvl;
++            line13.setText("NARO");
++        }
++        var fov = degs*(x/y);
++        var format = (x/y)/2.25;#16/9 = 1.777
++        var scale = format*20/fov;# we take into account that different pilots have different screen formats so the height of the MFD in screen stays same relative.
++        setprop("sim/current-view/field-of-view-scale",scale);
++        setprop("sim/current-view/field-of-view",fov);
++
++        zoom.setText(sprintf("%.1fX",zoomlvl));
++
++        line6.setText(ir==1?"WHOT":"TV");
++
++        if (enable) {
++            lasercode = getprop("f16/avionics/laser-code");
++            if (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil) {
++                var dist = flir_updater.click_coord_cam.direct_distance_to(geo.aircraft_position())*M2NM;
++                bott.setText(sprintf("%2.1f  CMBT  %04d",dist,lasercode));
++                lat.setText(ded.convertDegreeToStringLat(flir_updater.click_coord_cam.lat()));
++                lon.setText(ded.convertDegreeToStringLon(flir_updater.click_coord_cam.lon()));
++            } else {
++                bott.setText(sprintf("      CMBT  %04d",lasercode));
++                lat.setText("");
++                lon.setText("");
++            }
++            if (getprop("f16/avionics/cara-on")) {
++                #1F-F16CJ-34-1 page 1-224
++                ralt.setText(sprintf("%4d",getprop("position/altitude-agl-ft")));
++            } else {
++                ralt.setText("");
++            }
++        } else {
++            lat.setText("");
++            lon.setText("");
++        }
++        if (!getprop("/aircraft/flir/target/auto-track") or flir_updater.click_coord_cam == nil) {
++            setprop("sim/view[105]/heading-offset-deg", -getprop("sim/current-view/heading-offset-deg"));
++            setprop("sim/view[105]/pitch-offset-deg", getprop("sim/current-view/pitch-offset-deg"));
++        }
++        setprop("sim/current-view/x-offset-m",0.8536);
++        setprop("sim/current-view/y-offset-m",-1.4121);
++        setprop("sim/current-view/z-offset-m",-2.5856);
++    } else {
++        # remove FLIR effects and disable TGP view
++        setprop("sim/rendering/als-filters/use-IR-vision", 0);
++        setprop("sim/view[105]/enabled", 0);#!getprop("gear/gear/wow"));
++        #lock.hide();
++        #setprop("f16/avionics/lock-flir",0.05);
++    }
++
++    steerlock = 0;
++    var follow = 0;
++    if (armament.contactPoint !=nil and armament.contactPoint.get_range()>35 and armament.contactPoint.get_Callsign() != "GPS-Spot") {
++        print("TGP attempted lock at 35+ nm: ",armament.contactPoint.get_range());
++        armament.contactPoint = nil;
++    }
++    var gpps = 0;
++    if (armament.contactPoint == nil or !enable) {
++        # no TGP lock
++        if (armament.contact == nil and enable and masterMode) {# we do not check for get_display here since as long as something is selected we dont show steerpoint.
++            if (steerpoints.getCurrentNumber() != 0) {
++                # TGP follow steerpoint
++                hiddenMode = AG;
++                var stpt = steerpoints.getCurrent();
++                var ele = stpt.alt;
++                var lat = stpt.lat;
++                var lon = stpt.lon;
++                if (ele == nil) {
++                    ele = 0;
++                }
++                ele *= FT2M;
++                var ele2 = geo.elevation(lat,lon);
++                if (ele2 != nil) {
++                    ele = ele2;
++                }
++                var sp = geo.Coord.new();
++                sp.set_latlon(lat,lon,ele);
++                flir_updater.click_coord_cam = sp;
++                setprop("/aircraft/flir/target/auto-track", 1);
++                if (callsign != "#"~steerpoints.getCurrentNumber()) {
++                    # we switched steerpoint or from radar to steerpoint
++                    flir_updater.offsetP = 0;
++                    flir_updater.offsetH = 0;
++                }
++                callsign = "#"~steerpoints.getCurrentNumber();
++                steerlock = 1;
++                steer = 1;
++            } else {
++                # TGP not follow, locked from aircraft
++                hiddenMode = AG;
++                setprop("/aircraft/flir/target/auto-track", 0);
++                flir_updater.click_coord_cam = nil;
++                flir_updater.offsetP = 0;
++                flir_updater.offsetH = 0;
++                steer = 0;
++                callsign = nil;
++            }
++        } elsif (armament.contact != nil and armament.contact.isVisible() and enable and masterMode) {
++            # TGP follow radar lock
++            flir_updater.click_coord_cam = armament.contact.get_Coord();
++            setprop("/aircraft/flir/target/auto-track", 1);
++            if (callsign != armament.contact.getUnique()) {
++                flir_updater.offsetP = 0;
++                flir_updater.offsetH = 0;
++            }
++            callsign = armament.contact.getUnique();
++            hiddenMode = armament.contact.get_type() == armament.AIR?AA:AG;
++            steer = 0;
++        } else {
++            hiddenMode = AG;
++            setprop("/aircraft/flir/target/auto-track", 0);
++            flir_updater.click_coord_cam = nil;
++            callsign = nil;
++            flir_updater.offsetP = 0;
++            flir_updater.offsetH = 0;
++            steer = 0;
++        }
++        lock_tgp = 0;
++        gps = 0;
++    } else {
++        # TGP lock
++        var vis = 1;
++        line10.show();
++        gpss = armament.contactPoint.get_Callsign() == "GPS-Spot";# GPS-Spot only used by "program GPS dialog"
++        if (armament.contactPoint.get_Callsign() != "TGP-Spot" and !gps and !gpss and !steer) {
++            # we do not check for visibility if:
++            # - following steerpoint
++            # - a GPS coord has been entered manually by "program GPS dialog"
++            follow = 1;
++            vis = radar_system.terrain.fastTerrainCheck(armament.contactPoint);
++            if (vis > 0) vis = 1;
++        }
++        if (!vis or !masterMode) {
++            setprop("/aircraft/flir/target/auto-track", 0);
++            flir_updater.click_coord_cam = nil;
++            callsign = nil;
++            flir_updater.offsetP = 0;
++            flir_updater.offsetH = 0;
++            lock_tgp = 0;
++            armament.contactPoint = nil;print("No vis on TGP lock");
++            hiddenMode = AG;
++        } else {
++            lock_tgp = 1;
++            flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
++            #callsign = armament.contactPoint.getUnique();
++            setprop("/aircraft/flir/target/auto-track", 1);
++            #flir_updater.offsetP = 0;
++            #flir_updater.offsetH = 0;# commented so we get back to where we were when unlocking
++        }
++    }
++    setprop("f16/avionics/tgp-lock", lock_tgp);#used in HUD
++
++    if (getprop("f16/stores/tgp-mounted") and enable) {
++        if (lock_tgp and !lock_tgp_last) {
++            interpolate("f16/avionics/lock-flir",1,1.5);
++        } elsif (!lock_tgp) {
++            setprop("f16/avionics/lock-flir",0.05);
++        }
++        lock_tgp_last = lock_tgp;
++        if (lock_tgp) {
++            line1box.show();
++            line9.hide();
++            line11.hide();
++            line12.hide();
++            line14.hide();
++            line15.hide();
++        } else {
++            line1box.hide();
++            line9.show();
++            line11.show();
++            line12.show();
++            line14.show();
++            line15.show();
++        }
++        if (lock_tgp and gps) {
++            midl.setText(sprintf("%s      %s", "GPS", getprop("controls/armament/laser-arm-dmd")?"L":""));
++        } elsif (lock_tgp and follow) {
++            midl.setText(sprintf("%s POINT %s", gps?"GPS":(ir==1?"IR":"TV"), getprop("controls/armament/laser-arm-dmd")?"L":""));
++        } elsif (lock_tgp) {
++            midl.setText(sprintf("%s AREA  %s", gps?"GPS":(ir==1?"IR":"TV"), getprop("controls/armament/laser-arm-dmd")?"L":""));
++        } elsif (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil and steerlock) {
++            midl.setText(sprintf("STPT %s  %s", "#"~steerpoints.getCurrentNumber(), getprop("controls/armament/laser-arm-dmd")?"L":""));
++        } elsif (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil) {
++            midl.setText(sprintf("  RADAR  %s", getprop("controls/armament/laser-arm-dmd")?"L":""));
++        } else {
++            midl.setText(sprintf("         %s", getprop("controls/armament/laser-arm-dmd")?"L":""));
++        }
++
++        var scaleLock = getprop("f16/avionics/lock-flir");
++        lock.setScale(scaleLock,scaleLock);
++        lock.setStrokeLineWidth(1/scaleLock);
++        if (scaleLock != 0.05) {
++            lock.show();
++        } else {
++            lock.hide();
++        }
++        lock.update();
++
++        # animate the LANTIRN camera:
++        var b = geo.normdeg180(getprop("sim/view[105]/heading-offset-deg"));
++        var p = getprop("sim/view[105]/pitch-offset-deg");
++        var polarL = math.sqrt(p*p+b*b);
++        var polarD = polarL!=0 and b!=0?math.atan2(p,b)*R2D:-90;
++        setprop("aircraft/flir/swivel/pitch-deg",polarL);
++        setprop("aircraft/flir/swivel/roll-deg",polarD);
++    } elsif (!masterMode) {
++        lock.hide();
++    }
++    var dt = systime();
++    if (viewName == "TGP" and getprop("f16/stores/tgp-mounted") and enable) {
++        var cx = -getprop("/controls/displays/cursor-slew-x-delta");
++        var cy = -getprop("/controls/displays/cursor-slew-y-delta");
++        setprop("/controls/displays/cursor-slew-x-delta",0);
++        setprop("/controls/displays/cursor-slew-y-delta",0);
++        var modifier = getprop("/controls/displays/tgp-movement-modifier");
++        if (!lock_tgp and (cy != 0 or cx != 0)) {
++            gps = 0;
++            var fov = getprop("sim/current-view/field-of-view");
++            #var tme = dt - dt_old;
++            if (getprop("/aircraft/flir/target/auto-track")) {
++                var dist_modi = 1.0;
++                if (flir_updater.click_coord_cam != nil) {
++                    # 5nm is 5.0, 50 nm is 1.0
++                    dist_modi = 5 + ((flir_updater.click_coord_cam.direct_distance_to(radar_system.self.getCoord())*M2NM - 5) / (50 - 5)) * (1 - 5);
++                }
++                flir_updater.offsetP += dist_modi*modifier*cy*fov/camera_movement_speed_lock;
++                flir_updater.offsetH -= dist_modi*modifier*cx*fov/camera_movement_speed_lock;
++            } else {
++                setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")+modifier*cy*fov/camera_movement_speed_free);
++                setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")+modifier*cx*fov/camera_movement_speed_free);
++            }
++        }
++    }
++    dt_old = dt;
++}
++
++var flooptimer = nil;# started from f16.nas
++
++var dt_old = 0;
++
++var line1 = nil;
++var line1box = nil;
++var line2 = nil;
++var line3 = nil;
++var line4 = nil;
++var line6 = nil;
++var line7 = nil;
++var line10 = nil;
++var line11 = nil;
++var line12 = nil;
++var line13 = nil;
++var line14 = nil;
++var line15 = nil;
++var line20 = nil;
++var cross = nil;
++var lock = nil;
++var zoom = nil;
++var bott = nil;
++var ralt = nil;
++var lat = nil;
++var lon = nil;
++var line9 = nil;
++var midl = nil;
++var ir = 1;
++var lasercode = int(rand()*1778+1111);setprop("f16/avionics/laser-code",lasercode);
++var callsign = nil;
++var lock_tgp = 0;
++var lock_tgp_last = 0;
++var wide = 1;
++var zoomlvl = 1.0;
++var gps = 0;# set from Program GPS dialog
++var steer = 0;
++var STBY = 0;
++var AG = 1;
++var AA = 2;
++var masterMode = STBY;
++var hiddenMode = AG;
++var pullup_cue_3 = nil;
++
++var canvasMFDext = nil;
++var callInit = func {
++  canvasMFDext = canvas.new({
++        "name": "MFD-EXT",
++        "size": [256, 256],
++        "view": [256, 256],
++        "mipmapping": 1
++  });
++
++  canvasMFDext.addPlacement({"node": "MFDimage3", "texture": "tranbg.png"});
++  canvasMFDext.setColorBackground(1.00, 1.00, 1.00, 0.00);
++
++  dedGroup = canvasMFDext.createGroup();
++  dedGroup.show();
++  var color = [getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"),1];
++  line1 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("left-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("LOCK")
++        .setTranslation(5, 256*0.20);# 1
++  line1box = dedGroup.createChild("path")
++        .moveTo(0,-7)
++        .vert(14)
++        .horiz(35)
++        .vert(-14)
++        .horiz(-35)
++        .setStrokeLineWidth(1)
++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
++        .hide()
++        .setTranslation(5, 256*0.20);
++  line2 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("left-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("ZOOM")
++        .setTranslation(5, 256*0.35);# 2
++  line3 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("left-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("STBY")
++        .setTranslation(5, 256*0.50);# 3
++  line4 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("left-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("")
++        .setTranslation(5, 256*0.65);# 4
++  line6 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("right-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("WHOT")
++        .setTranslation(256-5, 256*0.2);# 6
++  line7 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("right-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("XFER")
++        .hide()
++        .setTranslation(256-5, 256*0.35);# 7
++  line9 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("right-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("CZ")
++        .hide()
++        .setTranslation(256-5, 256*0.65);# 9
++  line10 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("right-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("MARK")
++        .hide()
++        .setTranslation(256-5, 256*0.8);# 10
++  line11 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("center-top")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("UP")
++        .setTranslation(256*0.2, 5);# 11
++  line12 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("center-top")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("DOWN")
++        .setTranslation(256*0.35, 5);# 12
++  line13 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("center-top")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("WIDE")
++        .setTranslation(256*0.50, 5);# 13
++  line14 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("center-top")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("LEFT")
++        .setTranslation(256*0.65, 5);# 14
++  line15 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("center-top")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("RGHT")
++        .setTranslation(256*0.8, 5);# 15
++  line20 = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("center-bottom")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("BACK")
++        .setTranslation(256*0.8, 256-5);# 20
++
++    zoom = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
++        .setAlignment("center-top")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("1.0X")
++        .setTranslation(256*0.5, 20);
++    midl = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
++        .setAlignment("center-bottom")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("IR POINT    L")
++        .setTranslation(256*0.5, 256*0.8);
++    bott = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
++        .setAlignment("center-bottom")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("13.0  CMBT  1538")
++        .setTranslation(256*0.5, 256*0.9);
++    ralt = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("right-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("RALT")
++        .setTranslation(256-25, 256*0.1);
++    lat = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("left-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("LAT")
++        .setTranslation(50, 256*0.2);
++    lon = dedGroup.createChild("text")
++        .setFontSize(13, 1)
++        .setColor(color)
++        .setAlignment("left-center")
++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
++        .setText("LON")
++        .setTranslation(50, 256*0.25);
++
++  cross = dedGroup.createChild("path")
++            .moveTo(128,0)
++            .vert(120)
++            .moveTo(128,256)
++            .vert(-120)
++            .moveTo(0,128)
++            .horiz(120)
++            .moveTo(256,128)
++            .horiz(-120)
++            .setStrokeLineWidth(1)
++            .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"));
++    lock = dedGroup.createChild("path")
++            #.setCenter(128,128)
++            .moveTo(48,48)
++            .vert(-96)
++            .horiz(-96)
++            .vert(96)
++            .horiz(96)
++            .hide()
++            .setTranslation(128,128)
++            .setStrokeLineWidth(1)
++            .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"));
++
++    pullup_cue_3 = canvasMFDext.createGroup().set("z-index", 9000).hide();
++    pullup_cue_3.createChild("path")
++               .moveTo(0, 0)
++               .lineTo(256, 256)
++               .moveTo(0, 256)
++               .lineTo(256, 0)
++               .setStrokeLineWidth(3)
++               .setColor([getprop("/sim/model/MFD-color/circle1/red"), getprop("/sim/model/MFD-color/circle1/green"), getprop("/sim/model/MFD-color/circle1/blue")]);
++};
+diff --git a/Systems/b1-payload.xml b/Systems/b1-payload.xml
+index 089126a..60ce9da 100644
+--- a/Systems/b1-payload.xml
++++ b/Systems/b1-payload.xml
+@@ -328,7 +328,7 @@
+             <terminal-rise-time type="double">20.0</terminal-rise-time>
+             <terminal-dive-time type="double">12.0</terminal-dive-time>
+             <seeker-angular-speed-dps type="double">150</seeker-angular-speed-dps>
+-            <ready-time type="double">300</ready-time>
++            <ready-time type="double">10</ready-time>
+             <requires-power-on type="bool">true</requires-power-on>
+             <power-on-battery-time type="double">2700</power-on-battery-time>
+             <ejector-speed-fps type="double">5</ejector-speed-fps>
+diff --git a/changes.patch b/changes.patch
+new file mode 100644
+index 0000000..4280d8c
+--- /dev/null
++++ b/changes.patch
+@@ -0,0 +1,7106 @@
++diff --git a/B-1B-set.xml b/B-1B-set.xml
++index fd12235..dd64a04 100644
++--- a/B-1B-set.xml
+++++ b/B-1B-set.xml
++@@ -100,6 +100,14 @@ B-1B set file.
++                 <default-field-of-view-deg>60</default-field-of-view-deg>
++             </config>
++         </view>
+++        <view n="101">
+++            <!-- also used for ejection view, if change this number, also change it in MissileView.nas -->
+++            <name>Missile View</name>
+++            <type>lookat</type>
+++            <enabled>true</enabled>
+++            <heading-offset-deg>180</heading-offset-deg>
+++            <pitch-offset-deg>10</pitch-offset-deg>
+++        </view>
++ 
++         <view n="96000">
++             <name>DSO/OSO centered view</name>
++@@ -337,11 +345,12 @@ B-1B set file.
++                             <script>weapons.repair_damage()</script>
++                         </binding>
++                     </item>
++-                    <item n="4">
+++                    <item>
++                         <label>Targeting Computer</label>
+++                        <name>targeting_comp</name>
++                         <binding>
++-                            <command>nasal</command>
++-                            <script>weapons.targeting_comp.open()</script>
+++                            <command>dialog-show</command>
+++                            <dialog-name>targeting_comp</dialog-name>
++                         </binding>
++                     </item>
++                     <item n="10">
++@@ -764,6 +773,15 @@ B-1B set file.
++             <lightning type="bool" archive="y">true</lightning>
++             <display-mode archive="y">arc</display-mode>
++         </wxradar>
+++        <datalink>
+++            <data type="int">0</data>
+++            <power type="bool">false</power>
+++            <channel type="int">42</channel>
+++            <power_prop type="string">/instrumentation/datalink/power</power_prop>
+++            <channel_prop type="string">instrumentation/datalink/channel</channel_prop>
+++            <receive_period type="double">1</receive_period>
+++            <!--identifier_prop type="string">instrumentation/datalink/ident</identifier_prop-->
+++        </datalink>
++     </instrumentation>
++ 
++     <input>
++@@ -935,8 +953,27 @@ B-1B set file.
++         <vector>
++             <file>Aircraft/B-1B/Nasal/vector.nas</file>
++         </vector>
+++        <ai>
+++          <file>Aircraft/f16/Nasal/AI_list.nas</file>
+++        </ai>
+++        <view>
+++          <file>Aircraft/B-1B/Nasal/MissileView.nas</file>
+++        </view>
+++        <tgp>
+++          <file>Aircraft/B-1B/Nasal/tgp.nas</file>
+++        </tgp>
+++        <tacview>
+++            <file>Aircraft/B-1B/Nasal/tacview.nas</file>
+++        </tacview>
+++        <datalink>
+++            <file>Aircraft/B-1B/Nasal/datalink.nas</file>
+++        </datalink>
+++        <steerpoints>
+++            <file>Aircraft/B-1B/Nasal/steerpoints.nas</file>
+++        </steerpoints>
++         <radar_system>
++             <file>Aircraft/B-1B/Nasal/radar/radar-system.nas</file>
+++            <file>Aircraft/B-1B/Nasal/radar/apg-68.nas</file>
++             <file>Aircraft/B-1B/Nasal/radar/rwr_new.nas</file>
++         </radar_system>
++         <armament>
++diff --git a/Nasal/AI_list.nas b/Nasal/AI_list.nas
++new file mode 100644
++index 0000000..27a1a79
++--- /dev/null
+++++ b/Nasal/AI_list.nas
++@@ -0,0 +1,98 @@
+++#print("*** LOADING AI_list.nas ... ***");
+++# Autonomous singleton class that monitors AI object,
+++# maintains data in various structures, and raises signal
+++# "/sim/signals/ai-updated" whenever an aircraft
+++# joined or left. Available data containers are:
+++#
+++#   ai.AImodel.data:        hash, key := /ai/models/~ path
+++#   ai.AImodel.callsign     hash, key := callsign
+++#   ai.AImodel.list         vector, sorted alphabetically (ASCII, case insensitive)
+++#
+++# All of them contain hash entries of this form:
+++#
+++# {
+++#    callsign: "BiMaus", or 5H1N0B1 ;)
+++#    root: "/ai/models/multiplayer[4]",            # root property
+++#    node: {...},        # root property as props.Node hash
+++#    sort: "bimaus",     # callsign in lower case (for sorting)
+++# }
+++
+++var AImodel = {
+++    new: func() {
+++        var m = { parents: [AImodel] };
+++        m.data = {};
+++        m.callsign = {};
+++        m.list = {};
+++
+++        # return our new object
+++        return m;
+++    },
+++
+++    init: func() {
+++        #me.L = [];
+++        #append(me.L, setlistener("ai/models/model-added", func(n) {
+++            # Defer update() to the next convenient time to allow the
+++            # new MP entry to become fully initialized.
+++            #settimer(func me.update(), 0);
+++        #}));
+++        #append(me.L, setlistener("ai/models/model-removed", func(n) {
+++            # Defer update() to the next convenient time to allow the
+++            # old MP entry to become fully deactivated.
+++            #settimer(func me.update(), 0);
+++        #}));
+++        me.update();
+++    },
+++    update: func(n = nil) {
+++        var changedNode = props.globals.getNode(n, 1);
+++        me.data = {};
+++        me.callsign = {};
+++        #print("UPDATE AI LIST");
+++        foreach(var n ; props.globals.getNode("ai/models", 1).getChildren())
+++        {
+++            #print(n.getName());
+++
+++            if((var valid = n.getNode("valid")) == nil or !valid.getValue() or ((n.getNode("missile") == nil or n.getNode("missile").getValue() != 1) and (n.getNode("type") == nil or (n.getNode("type").getValue() != "Mig-28" and n.getNode("type").getValue() != "F-16"))))
+++            {
+++                continue;
+++            }
+++            var myName = string.replace(n.getPath(), "/ai/models/", "");
+++            if (n.getNode("callsign") != nil and n.getNode("callsign").getValue()!=nil) {
+++              myName = n.getNode("callsign").getValue();
+++            }
+++            #print( string.replace(n.getPath(),"/ai/models/",""));
+++
+++            var root = n.getPath();
+++
+++            var data = {
+++                node: n,
+++                callsign: myName,
+++                root: root,
+++                sort: string.lc(myName)
+++            };
+++            me.data[root] = data;
+++            me.callsign[myName] = data;
+++        }
+++        #print(size(me.data));
+++        me.list = sort(values(me.data), func(a, b) cmp(a.sort, b.sort));
+++
+++        if(size(me.data) > 0)
+++        {
+++            #print(me.list[1]);
+++            setprop("ai/models/num-ai", size(me.list));
+++            setprop("sim/signals/ai-updated", 1);
+++        }
+++        settimer(func(){ me.update() }, 0.5);
+++    },
+++    get_list: func(){
+++        return me.list;
+++    },
+++
+++    remove_suffix: func(s, x) {
+++        var len = size(x);
+++        if(substr(s, -len) == x)
+++        {
+++            return substr(s, 0, size(s) - len);
+++        }
+++        return s;
+++    },
+++};
++diff --git a/Nasal/MissileView.nas b/Nasal/MissileView.nas
++new file mode 100644
++index 0000000..542bcd2
++--- /dev/null
+++++ b/Nasal/MissileView.nas
++@@ -0,0 +1,113 @@
+++#print("*** LOADING MissileView.nas ... ***");
+++var missile_view_handler = {
+++  init: func(node) {
+++    me.viewN = node;
+++    me.current = nil;
+++    me.legendN = props.globals.initNode("/sim/current-view/missile-view", "");
+++    me.dialog = props.Node.new({ "dialog-name": "missile-view" });
+++    me.listener = nil;
+++  },
+++  start: func {
+++    me.listener = setlistener("/sim/signals/ai-updated", func me._update_(), 1);
+++    me.reset();
+++    fgcommand("dialog-show", me.dialog);
+++  },
+++  stop: func {
+++    fgcommand("dialog-close", me.dialog);
+++    if (me.listener!=nil)
+++    {
+++      removelistener(me.listener);
+++      me.listener=nil;
+++    }
+++  },
+++  reset: func {
+++    me.select(0);
+++  },
+++  find: func(callsign) {
+++    forindex (var i; me.list)
+++      if (me.list[i].callsign == callsign)
+++        return i;
+++    return nil;
+++  },
+++  select: func(which, by_callsign=0) {
+++    if (by_callsign or num(which) == nil)
+++      which = me.find(which) or 0;  # turn callsign into index
+++
+++    me.setup(me.list[which]);
+++  },
+++  next: func(step) {
+++    #ai.model.update();
+++    me._update_();
+++    var i = me.find(me.current);
+++    i = i == nil ? 0 : math.mod(i + step, size(me.list));
+++    me.setup(me.list[i]);
+++  },
+++  _update_: func {
+++    var self = { callsign: getprop("/sim/multiplay/callsign"), model:,
+++        node: props.globals, root: '/' };
+++    #ai.myModel.update();
+++    me.list = [self] ~ myModel.get_list();
+++    if (!me.find(me.current))
+++      me.select(0);
+++  },
+++  setup: func(data) {
+++    if (data.root == '/') {
+++      var zoffset = getprop("/sim/chase-distance-m");
+++      var ident = '[' ~ data.callsign ~ ']';
+++    } else {
+++      var zoffset = 70;
+++      #var ident = '"' ~ data.callsign ~ '" (' ~ data.model ~ ')';
+++      var ident = '"' ~ data.callsign ~ '"';
+++    }
+++
+++    me.current = data.callsign;
+++    me.legendN.setValue(ident);
+++    setprop("/sim/current-view/z-offset-m", zoffset);
+++    setprop("/sim/current-view/heading-offset-deg", 110);
+++    setprop("/sim/current-view/pitch-offset-deg", 30);
+++
+++    #print(me.current);
+++
+++    me.viewN.getNode("config").setValues({
+++      "eye-lat-deg-path": data.root ~ "/position/latitude-deg",
+++      "eye-lon-deg-path": data.root ~ "/position/longitude-deg",
+++      "eye-alt-ft-path": data.root ~ "/position/altitude-ft",
+++      "eye-heading-deg-path": data.root ~ "/orientation/true-heading-deg",
+++      "target-lat-deg-path": data.root ~ "/position/latitude-deg",
+++      "target-lon-deg-path": data.root ~ "/position/longitude-deg",
+++      "target-alt-ft-path": data.root ~ "/position/altitude-ft",
+++      "target-heading-deg-path": data.root ~ "/orientation/true-heading-deg",
+++      "target-pitch-deg-path": data.root ~ "/orientation/pitch-deg",
+++      "target-roll-deg-path": data.root ~ "/orientation/roll-deg",
+++      "heading-offset-deg":180
+++    });
+++  },
+++};
+++
+++var myModel = ai.AImodel.new();
+++myModel.init();
+++
+++view.manager.register("Missile View",missile_view_handler);
+++
+++
+++var view_firing_missile = func(myMissile)
+++{
+++
+++    # We select the missile name
+++    var myMissileName = string.replace(myMissile.ai.getPath(), "/ai/models/", "");
+++    if (myMissile.ai.getNode("callsign") != nil and myMissile.ai.getNode("callsign").getValue()!=nil) {
+++      myMissileName = myMissile.ai.getNode("callsign").getValue();
+++    }
+++
+++    # We memorize the initial view number
+++    var actualView = getprop("/sim/current-view/view-number");
+++
+++    # We recreate the data vector to feed the missile_view_handler
+++    var data = { node: myMissile.ai, callsign: myMissileName, root: myMissile.ai.getPath()};
+++
+++    # We activate the AI view (on this aircraft it is the number 8)
+++    view.setViewByIndex(101);
+++
+++    # We feed the handler
+++    view.missile_view_handler.setup(data);
+++}
++diff --git a/Nasal/Radar/apg-68.nas b/Nasal/Radar/apg-68.nas
++new file mode 100644
++index 0000000..3b2f73f
++--- /dev/null
+++++ b/Nasal/Radar/apg-68.nas
++@@ -0,0 +1,3515 @@
+++
+++
+++
+++
+++
+++############# BEGIN SOMEWHAT GENERIC CLASSES ###########################################
+++
+++
+++
+++# Field of regard requests
+++var FOR_ROUND  = 0;# TODO: be able to ask noseradar for round field of regard.
+++var FOR_SQUARE = 1;
+++#Pulses
+++var DOPPLER = 1;
+++var MONO = 0;
+++
+++var overlapHorizontal = 1.5;
+++
+++
+++#   █████  ██ ██████  ██████   ██████  ██████  ███    ██ ███████     ██████   █████  ██████   █████  ██████
+++#  ██   ██ ██ ██   ██ ██   ██ ██    ██ ██   ██ ████   ██ ██          ██   ██ ██   ██ ██   ██ ██   ██ ██   ██
+++#  ███████ ██ ██████  ██████  ██    ██ ██████  ██ ██  ██ █████       ██████  ███████ ██   ██ ███████ ██████
+++#  ██   ██ ██ ██   ██ ██   ██ ██    ██ ██   ██ ██  ██ ██ ██          ██   ██ ██   ██ ██   ██ ██   ██ ██   ██
+++#  ██   ██ ██ ██   ██ ██████   ██████  ██   ██ ██   ████ ███████     ██   ██ ██   ██ ██████  ██   ██ ██   ██
+++#
+++#
+++var AirborneRadar = {
+++	#
+++	# This is an base class for an airborne forward looking radar
+++	# The class RadarMode uses this. Subclass as needed.
+++	#
+++	# TODO: Cleaner calls to optional ground mapper
+++	#
+++	fieldOfRegardType: FOR_SQUARE,
+++	fieldOfRegardMaxAz: 60,
+++	fieldOfRegardMaxElev: 60,
+++	fieldOfRegardMinElev: -60,
+++	currentMode: nil, # vector of cascading modes ending with current submode
+++	currentModeIndex: nil,
+++	rootMode: 0,
+++	mainModes: nil,
+++	instantFoVradius: 2.0,#average of horiz/vert radius
+++	instantVertFoVradius: 2.5,# real vert radius (could be used by ground mapper)
+++	instantHoriFoVradius: 1.5,# real hori radius (not used)
+++	rcsRefDistance: 70,
+++	rcsRefValue: 3.2,
+++	#closureReject: -1, # The minimum kt closure speed it will pick up, else rejected.
+++	#positionEuler: [0,0,0,0],# euler direction
+++	positionDirection: [1,0,0],# vector direction
+++	positionCart: [0,0,0,0],
+++	eulerX: 0,
+++	eulerY: 0,
+++	horizonStabilized: 1, # When true antennae ignore roll (and pitch until its high)
+++	vector_aicontacts_for: [],# vector of contacts found in field of regard
+++	vector_aicontacts_bleps: [],# vector of not timed out bleps
+++	chaffList: [],
+++	chaffSeenList: [],
+++	chaffFilter: 0.60,# 1=filters all chaff, 0=sees all chaff all the time
+++	timer: nil,
+++	timerMedium: nil,
+++	timerSlow: nil,
+++	timeToKeepBleps: 13,
+++	elapsed: elapsedProp.getValue(),
+++	lastElapsed: elapsedProp.getValue(),
+++	debug: 0,
+++	newAirborne: func (mainModes, child) {
+++		var rdr = {parents: [child, AirborneRadar, Radar]};
+++
+++		rdr.mainModes = mainModes;
+++
+++		foreach (modes ; mainModes) {
+++			foreach (mode ; modes) {
+++				# this needs to be set on submodes also...hmmm
+++				mode.radar = rdr;
+++			}
+++		}
+++
+++		rdr.currentModeIndex = setsize([], size(mainModes));
+++		forindex (var i; rdr.currentModeIndex) {
+++			rdr.currentModeIndex[i] = 0;
+++		}
+++
+++		rdr.setCurrentMode(rdr.mainModes[0][0], nil);
+++
+++		rdr.SliceNotification = SliceNotification.new();
+++		rdr.ContactNotification = VectorNotification.new("ContactNotification");
+++		rdr.ActiveDiscRadarRecipient = emesary.Recipient.new("ActiveDiscRadarRecipient");
+++		rdr.ActiveDiscRadarRecipient.radar = rdr;
+++		rdr.ActiveDiscRadarRecipient.Receive = func(notification) {
+++	        if (notification.NotificationType == "FORNotification") {
+++	        	#printf("DiscRadar recv: %s", notification.NotificationType);
+++	            #if (rdr.enabled == 1) { no, lets keep this part running, so we have fresh data when its re-enabled
+++	    		    rdr.vector_aicontacts_for = notification.vector;
+++	    		    rdr.purgeBleps();
+++	    		    #print("size(rdr.vector_aicontacts_for)=",size(rdr.vector_aicontacts_for));
+++	    	    #}
+++	            return emesary.Transmitter.ReceiptStatus_OK;
+++	        }
+++	        if (notification.NotificationType == "ChaffReleaseNotification") {
+++	    		rdr.chaffList ~= notification.vector;
+++	            return emesary.Transmitter.ReceiptStatus_OK;
+++	        }
+++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+++	    };
+++		emesary.GlobalTransmitter.Register(rdr.ActiveDiscRadarRecipient);
+++		rdr.timer = maketimer(scanInterval, rdr, func rdr.loop());
+++		rdr.timerSlow = maketimer(0.75, rdr, func rdr.loopSlow());
+++		rdr.timerMedium = maketimer(0.25, rdr, func rdr.loopMedium());
+++		rdr.timerMedium.start();
+++		rdr.timerSlow.start();
+++		rdr.timer.start();
+++    	return rdr;
+++	},
+++	getTiltKnob: func {
+++		me.theKnob = antennae_knob_prop.getValue();
+++		if (math.abs(me.theKnob) < 0.01) {
+++			antennae_knob_prop.setValue(0);
+++			me.theKnob = 0;
+++		}
+++		return me.theKnob*60;
+++	},
+++	increaseRange: func {
+++		if (me["gmapper"] != nil) me.gmapper.clear();
+++		me.currentMode.increaseRange();
+++	},
+++	decreaseRange: func {
+++		if (me["gmapper"] != nil) me.gmapper.clear();
+++		me.currentMode.decreaseRange();
+++	},
+++	designate: func (designate_contact) {
+++		me.currentMode.designate(designate_contact);
+++	},
+++	designateRandom: func {
+++		# Use this method mostly for testing
+++		if (size(me.vector_aicontacts_bleps) > 0) {
+++			me.designate(me.vector_aicontacts_bleps[size(me.vector_aicontacts_bleps)-1]);
+++		}
+++	},
+++	undesignate: func {
+++		me.currentMode.undesignate();
+++	},
+++	getPriorityTarget: func {
+++		if (!me.enabled) return nil;
+++		return me.currentMode.getPriority();
+++	},
+++	cycleDesignate: func {
+++		me.currentMode.cycleDesignate();
+++	},
+++	cycleMode: func {
+++		me.currentModeIndex[me.rootMode] += 1;
+++		if (me.currentModeIndex[me.rootMode] >= size(me.mainModes[me.rootMode])) {
+++			me.currentModeIndex[me.rootMode] = 0;
+++		}
+++		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+++		me.newMode.setRange(me.currentMode.getRange());
+++		me.oldMode = me.currentMode;
+++		me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+++	},
+++	cycleRootMode: func {
+++		me.rootMode += 1;
+++		if (me.rootMode >= size(me.mainModes)) {
+++			me.rootMode = 0;
+++		}
+++
+++		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+++		#me.newMode.setRange(me.currentMode.getRange());
+++		me.oldMode = me.currentMode;
+++		me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+++	},
+++	cycleAZ: func {
+++		if (me["gmapper"] != nil) me.gmapper.clear();
+++		me.clearShowScan();
+++		me.currentMode.cycleAZ();
+++	},
+++	cycleBars: func {
+++		me.currentMode.cycleBars();
+++		me.clearShowScan();
+++	},
+++	getDeviation: func {
+++		return me.currentMode.getDeviation();
+++	},
+++	setCursorDeviation: func (cursor_az) {
+++		return me.currentMode.setCursorDeviation(cursor_az);
+++	},
+++	getCursorDeviation: func {
+++		return me.currentMode.getCursorDeviation();
+++	},
+++	setCursorDistance: func (nm) {
+++		# Return if the cursor should be distance zeroed.
+++		return me.currentMode.setCursorDistance(nm);;
+++	},
+++	getCursorAltitudeLimits: func {
+++		if (!me.enabled) return nil;
+++		return me.currentMode.getCursorAltitudeLimits();
+++	},
+++	getBars: func {
+++		return me.currentMode.getBars();
+++	},
+++	getAzimuthRadius: func {
+++		return me.currentMode.getAz();
+++	},
+++	getMode: func {
+++		return me.currentMode.shortName;
+++	},
+++	setCurrentMode: func (new_mode, priority = nil) {
+++		me.olderMode = me.currentMode;
+++		me.currentMode = new_mode;
+++		new_mode.radar = me;
+++		#new_mode.setCursorDeviation(me.currentMode.getCursorDeviation()); # no need since submodes don't overwrite this
+++		new_mode.designatePriority(priority);
+++		if (me.olderMode != nil) me.olderMode.leaveMode();
+++		new_mode.enterMode();
+++		settimer(func me.clearShowScan(), 0.5);
+++	},
+++	setRootMode: func (mode_number, priority = nil) {
+++		me.rootMode = mode_number;
+++		if (me.rootMode >= size(me.mainModes)) {
+++			me.rootMode = 0;
+++		}
+++
+++		me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+++		#me.newMode.setRange(me.currentMode.getRange());
+++		me.oldMode = me.currentMode;
+++		me.setCurrentMode(me.newMode, priority);
+++	},
+++	getRange: func {
+++		return me.currentMode.getRange();
+++	},
+++	getCaretPosition: func {
+++		if (me["eulerX"] == nil or me["eulerY"] == nil) {
+++			return [0,0];
+++		} elsif (me.horizonStabilized) {
+++			return [me.eulerX/me.fieldOfRegardMaxAz,me.eulerY/me.fieldOfRegardMaxElev];
+++		} else {
+++			return [me.eulerX/me.fieldOfRegardMaxAz,me.eulerY/me.fieldOfRegardMaxElev];
+++		}
+++	},
+++	setAntennae: func (local_dir) {
+++		# remember to set horizonStabilized when calling this.
+++
+++		# convert from coordinates to polar
+++		me.eulerDir = vector.Math.cartesianToEuler(local_dir);
+++
+++		# Make sure if pitch is 90 or -90 that heading gets set to something sensible
+++		me.eulerX = me.eulerDir[0]==nil?0:geo.normdeg180(me.eulerDir[0]);
+++		me.eulerY = me.eulerDir[1];
+++
+++		# Make array: [heading_degs, pitch_degs, heading_norm, pitch_norm], for convinience, not used atm.
+++		#me.positionEuler = [me.eulerX,me.eulerDir[1],me.eulerX/me.fieldOfRegardMaxAz,me.eulerDir[1]/me.fieldOfRegardMaxElev];
+++
+++		# Make the antennae direction-vector be length 1.0
+++		me.positionDirection = vector.Math.normalize(local_dir);
+++
+++		# Decompose the antennae direction-vector into seperate angles for Azimuth and Elevation
+++		me.posAZDeg = -90+R2D*math.acos(vector.Math.normalize(vector.Math.projVectorOnPlane([0,0,1],me.positionDirection))[1]);
+++		me.posElDeg = R2D*math.asin(vector.Math.normalize(vector.Math.projVectorOnPlane([0,1,0],me.positionDirection))[2]);
+++
+++		# Make an array that holds: [azimuth_norm, elevation_norm, azimuth_deg, elevation_deg]
+++		me.positionCart = [me.posAZDeg/me.fieldOfRegardMaxAz, me.posElDeg/me.fieldOfRegardMaxElev,me.posAZDeg,me.posElDeg];
+++
+++		# Note: that all these numbers can be either relative to aircraft or relative to scenery.
+++		# Its the modes responsibility to call this method with antennae local_dir that is either relative to
+++		# aircraft, or to landscape so that they match how scanFOV compares the antennae direction to target positions.
+++		#
+++		# Make sure that scanFOV() knows what coord system you are operating in. By setting me.horizonStabilized.
+++	},
+++	installMapper: func (gmapper) {
+++		me.gmapper = gmapper;
+++	},
+++	isEnabled: func {
+++		return 1;
+++	},
+++	loop: func {
+++		me.enabled = me.isEnabled();
+++		setprop("instrumentation/radar/radar-standby", !me.enabled);
+++		# calc dt here, so we don't get a massive dt when going from disabled to enabled:
+++		me.elapsed = elapsedProp.getValue();
+++		me.dt = me.elapsed - me.lastElapsed;
+++		me.lastElapsed = me.elapsed;
+++		if (me.enabled) {
+++			if (me.currentMode.painter and me.currentMode.detectAIR) {
+++				# We need faster updates to not lose track of oblique flying locks close by when in STT.
+++				me.ContactNotification.vector = [me.getPriorityTarget()];
+++				emesary.GlobalTransmitter.NotifyAll(me.ContactNotification);
+++			}
+++
+++			while (me.dt > 0.001) {
+++				# mode tells us how to move disc and to scan
+++				me.dt = me.currentMode.step(me.dt);# mode already knows where in pattern we are and AZ and bars.
+++
+++				# we then step to the new position, and scan for each step
+++				me.scanFOV();
+++				me.showScan();
+++			}
+++
+++		} elsif (size(me.vector_aicontacts_bleps)) {
+++			# So that when radar is restarted there is not old bleps.
+++			me.purgeAllBleps();
+++		}
+++	},
+++	loopMedium: func {
+++		#
+++		# It send out what target we are Single-target-track locked onto if any so the target get RWR warning.
+++		# It also sends out on datalink what we are STT/SAM/TWS locked onto.
+++		# In addition it notifies the weapons what we have targeted.
+++		# Plus it sets the MP property for radar standby so others can see us on RWR.
+++		if (me.enabled) {
+++			me.focus = me.getPriorityTarget();
+++			if (me.focus != nil and me.focus.callsign != "") {
+++				if (me.currentMode.painter) sttSend.setValue(left(md5(me.focus.callsign), 4));
+++				else sttSend.setValue("");
+++				if (steerpoints.sending == nil) {
+++			        datalink.send_data({"contacts":[{"callsign":me.focus.callsign,"iff":0}]});
+++			    }
+++			} else {
+++				sttSend.setValue("");
+++				if (steerpoints.sending == nil) {
+++		            datalink.clear_data();
+++		        }
+++			}
+++			armament.contact = me.focus;
+++			stbySend.setIntValue(0);
+++		} else {
+++			armament.contact = nil;
+++			sttSend.setValue("");
+++			stbySend.setIntValue(1);
+++			if (steerpoints.sending == nil) {
+++	            datalink.clear_data();
+++	        }
+++		}
+++
+++		me.debug = getprop("debug-radar/debug-main");
+++	},
+++	loopSlow: func {
+++		#
+++		# Here we ask the NoseRadar for a slice of the sky once in a while.
+++		#
+++		if (me.enabled and !(me.currentMode.painter and me.currentMode.detectAIR)) {
+++			emesary.GlobalTransmitter.NotifyAll(me.SliceNotification.slice(self.getPitch(), self.getHeading(), math.max(-me.fieldOfRegardMinElev, me.fieldOfRegardMaxElev)*1.414, me.fieldOfRegardMaxAz*1.414, me.getRange()*NM2M, !me.currentMode.detectAIR, !me.currentMode.detectSURFACE, !me.currentMode.detectMARINE));
+++		}
+++	},
+++	scanFOV: func {
+++		#
+++		# Here we test for IFF and test the radar beam against targets to see if the radar picks them up.
+++		#
+++		# Note that this can happen in aircraft coords (ACM modes) or in landscape coords (the other modes).
+++		me.doIFF = getprop("instrumentation/radar/iff");
+++    	setprop("instrumentation/radar/iff",0);
+++    	if (me.doIFF) iff.last_interogate = systime();
+++    	if (me["gmapper"] != nil) me.gmapper.scanGM(me.eulerX, me.eulerY, me.instantVertFoVradius, me.instantFoVradius,
+++    		 me.currentMode.bars == 1 or (me.currentMode.bars == 4 and me.currentMode["nextPatternNode"] == 0) or (me.currentMode.bars == 3 and me.currentMode["nextPatternNode"] == 7) or (me.currentMode.bars == 2 and me.currentMode["nextPatternNode"] == 1),
+++    		 me.currentMode.bars == 1 or (me.currentMode.bars == 4 and me.currentMode["nextPatternNode"] == 2) or (me.currentMode.bars == 3 and me.currentMode["nextPatternNode"] == 3) or (me.currentMode.bars == 2 and me.currentMode["nextPatternNode"] == 3));# The last two parameter is hack
+++
+++    	# test for passive ECM (chaff)
+++		#
+++		me.closestChaff = 1000000;# meters
+++		if (size(me.chaffList)) {
+++			if (me.horizonStabilized) {
+++				me.globalAntennaeDir = vector.Math.yawVector(-self.getHeading(), me.positionDirection);
+++			} else {
+++				me.globalAntennaeDir = vector.Math.rollPitchYawVector(self.getRoll(), self.getPitch(), -self.getHeading(), me.positionDirection);
+++			}
+++
+++			foreach (me.chaff ; me.chaffList) {
+++				if (rand() < me.chaffFilter or me.chaff.meters < 10000+10000*rand()) continue;# some chaff are filtered out.
+++				me.globalToTarget = vector.Math.pitchYawVector(me.chaff.pitch, -me.chaff.bearing, [1,0,0]);
+++
+++				# Degrees from center of radar beam to center of chaff cloud
+++				me.beamDeviation = vector.Math.angleBetweenVectors(me.globalAntennaeDir, me.globalToTarget);
+++
+++				if (me.beamDeviation < me.instantFoVradius) {
+++					if (me.chaff.meters < me.closestChaff) {
+++						me.closestChaff = me.chaff.meters;
+++					}
+++					me.registerChaff(me.chaff);# for displays
+++					#print("REGISTER CHAFF");
+++				}# elsif(me.debug > -1) {
+++					# This is too detailed for most debugging, remove later
+++				#	setprop("debug-radar/main-beam-deviation-chaff", me.beamDeviation);
+++				#}
+++			}
+++		}
+++
+++    	me.testedPrio = 0;
+++		foreach(contact ; me.vector_aicontacts_for) {
+++			if (me.doIFF == 1) {
+++	            me.iffr = iff.interrogate(contact.prop);
+++	            if (me.iffr) {
+++	                contact.iff = me.elapsed;
+++	            } else {
+++	                contact.iff = -me.elapsed;
+++	            }
+++	        }
+++			if (me.elapsed - contact.getLastBlepTime() < me.currentMode.minimumTimePerReturn) {
+++				if(me.debug > 1 and me.currentMode.painter and contact == me.getPriorityTarget()) {
+++					me.testedPrio = 1;
+++				}
+++				continue;# To prevent double detecting in overlapping beams
+++			}
+++
+++			me.dev = contact.getDeviationStored();
+++
+++			if (me.horizonStabilized) {
+++				# ignore roll and pitch
+++
+++				# Vector that points to target in radar coordinates as if aircraft it was not rolled or pitched.
+++				me.globalToTarget = vector.Math.eulerToCartesian3X(-me.dev.bearing,me.dev.elevationGlobal,0);
+++
+++				# Vector that points to target in radar coordinates as if aircraft it was not yawed, rolled or pitched.
+++				me.localToTarget = vector.Math.yawVector(self.getHeading(), me.globalToTarget);
+++			} else {
+++				# Vector that points to target in local radar coordinates.
+++				me.localToTarget = vector.Math.eulerToCartesian3X(-me.dev.azimuthLocal,me.dev.elevationLocal,0);
+++			}
+++
+++			# Degrees from center of radar beam to target, note that positionDirection must match the coord system defined by horizonStabilized.
+++			me.beamDeviation = vector.Math.angleBetweenVectors(me.positionDirection, me.localToTarget);
+++
+++			if(me.debug > 1 and me.currentMode.painter and contact == me.getPriorityTarget()) {
+++				# This is too detailed for most debugging, remove later
+++				setprop("debug-radar/main-beam-deviation", me.beamDeviation);
+++				me.testedPrio = 1;
+++			}
+++			if (me.beamDeviation < me.instantFoVradius and (me.dev.rangeDirect_m < me.closestChaff or rand() < me.chaffFilter) ) {#  and (me.closureReject == -1 or me.dev.closureSpeed > me.closureReject)
+++				# TODO: Refine the chaff conditional (ALOT)
+++				me.registerBlep(contact, me.dev, me.currentMode.painter, me.currentMode.pulse);
+++				#print("REGISTER BLEP");
+++
+++				# Return here, so that each instant FoV max gets 1 target:
+++				# TODO: refine by testing angle between contacts seen in this FoV
+++				break;
+++			}
+++		}
+++
+++		if(me.debug > 1 and me.currentMode.painter and !me.testedPrio) {
+++			setprop("debug-radar/main-beam-deviation", "--unseen-lock--");
+++		}
+++	},
+++	registerBlep: func (contact, dev, stt, doppler = 1) {
+++		if (!contact.isVisible()) return 0;
+++		if (doppler) {
+++			if (contact.isHiddenFromDoppler()) {
+++				return 0;
+++			}
+++			if (math.abs(dev.closureSpeed) < me.currentMode.minClosure) {
+++				return 0;
+++			}
+++		}
+++
+++		me.maxDistVisible = me.currentMode.rcsFactor * me.targetRCSSignal(self.getCoord(), dev.coord, contact.model, dev.heading, dev.pitch, dev.roll,me.rcsRefDistance*NM2M,me.rcsRefValue);
+++
+++		if (me.maxDistVisible > dev.rangeDirect_m) {
+++			me.extInfo = me.currentMode.getSearchInfo(contact);# if the scan gives heading info etc..
+++
+++			if (me.extInfo == nil) {
+++				return 0;
+++			}
+++			contact.blep(me.elapsed, me.extInfo, me.maxDistVisible, stt);
+++			if (!me.containsVectorContact(me.vector_aicontacts_bleps, contact)) {
+++				append(me.vector_aicontacts_bleps, contact);
+++			}
+++			return 1;
+++		}
+++		return 0;
+++	},
+++	registerChaff: func (chaff) {
+++		chaff.seenTime = me.elapsed;
+++		if (!me.containsVector(me.chaffSeenList, chaff)) {
+++			append(me.chaffSeenList, chaff);
+++		}
+++	},
+++	purgeBleps: func {
+++		#ok, lets clean up old bleps:
+++		me.vector_aicontacts_bleps_tmp = [];
+++		me.elapsed = elapsedProp.getValue();
+++		foreach(contact ; me.vector_aicontacts_bleps) {
+++			me.bleps_cleaned = [];
+++			foreach (me.blep;contact.getBleps()) {
+++				if (me.elapsed - me.blep.getBlepTime() < me.currentMode.timeToFadeBleps) {
+++					append(me.bleps_cleaned, me.blep);
+++				}
+++			}
+++			contact.setBleps(me.bleps_cleaned);
+++			if (size(me.bleps_cleaned)) {
+++				append(me.vector_aicontacts_bleps_tmp, contact);
+++				me.currentMode.testContact(contact);# TODO: do this smarter
+++			} else {
+++				me.currentMode.prunedContact(contact);
+++			}
+++		}
+++		#print("Purged ", size(me.vector_aicontacts_bleps) - size(me.vector_aicontacts_bleps_tmp), " bleps   remains:",size(me.vector_aicontacts_bleps_tmp), " orig ",size(me.vector_aicontacts_bleps));
+++		me.vector_aicontacts_bleps = me.vector_aicontacts_bleps_tmp;
+++
+++		#lets purge the old chaff also, both seen and unseen
+++		me.wnd = wndprop.getValue();
+++		me.chaffLifetime = math.max(0, me.wnd==0?25:25*(1-me.wnd/50));
+++		me.chaffList_tmp = [];
+++		foreach(me.evilchaff ; me.chaffList) {
+++			if (me.elapsed - me.evilchaff.releaseTime < me.chaffLifetime) {
+++				append(me.chaffList_tmp, me.evilchaff);
+++			}
+++		}
+++		me.chaffList = me.chaffList_tmp;
+++
+++		me.chaffSeenList_tmp = [];
+++		foreach(me.evilchaff ; me.chaffSeenList) {
+++			if (me.elapsed - me.evilchaff.releaseTime < me.chaffLifetime or me.elapsed - me.evilchaff.seenTime < me.timeToKeepBleps) {
+++				append(me.chaffSeenList_tmp, me.evilchaff);
+++			}
+++		}
+++		me.chaffSeenList = me.chaffSeenList_tmp;
+++	},
+++	purgeAllBleps: func {
+++		#ok, lets delete all bleps:
+++		foreach(contact ; me.vector_aicontacts_bleps) {
+++			contact.setBleps([]);
+++			me.currentMode.prunedContact(contact);
+++		}
+++		me.vector_aicontacts_bleps = [];
+++		me.chaffSeenList = [];
+++	},
+++	targetRCSSignal: func(aircraftCoord, targetCoord, targetModel, targetHeading, targetPitch, targetRoll, myRadarDistance_m = 74000, myRadarStrength_rcs = 3.2) {
+++		#
+++		# test method. Belongs in rcs.nas.
+++		#
+++	    me.target_front_rcs = nil;
+++	    if ( contains(rcs.rcs_oprf_database,targetModel) ) {
+++	        me.target_front_rcs = rcs.rcs_oprf_database[targetModel];
+++	    } elsif ( contains(rcs.rcs_database,targetModel) ) {
+++	        me.target_front_rcs = rcs.rcs_database[targetModel];
+++	    } else {
+++	        # GA/Commercial return most likely
+++	        me.target_front_rcs = rcs.rcs_oprf_database["default"];
+++	    }
+++	    me.target_rcs = rcs.getRCS(targetCoord, targetHeading, targetPitch, targetRoll, aircraftCoord, me.target_front_rcs);
+++
+++	    # standard formula
+++	    return myRadarDistance_m/math.pow(myRadarStrength_rcs/me.target_rcs, 1/4);
+++	},
+++	getActiveBleps: func {
+++		return me.vector_aicontacts_bleps;
+++	},
+++	getActiveChaff: func {
+++		return me.chaffSeenList;
+++	},
+++	showScan: func {
+++		if (me.debug > 0) {
+++			if (me["canvas2"] == nil) {
+++	            me.canvas2 = canvas.Window.new([512,512],"dialog").set('title',"Scan").getCanvas(1);
+++				me.canvas_root2 = me.canvas2.createGroup().setTranslation(256,256);
+++				me.canvas2.setColorBackground(0.25,0.25,1);
+++			}
+++
+++			if (me.elapsed - me.currentMode.lastFrameStart < 0.1) {
+++				me.clearShowScan();
+++			}
+++			me.canvas_root2.createChild("path")
+++				.setTranslation(256*me.eulerX/60, -256*me.eulerY/60)
+++				.moveTo(0, 256*me.instantFoVradius/60)
+++				.lineTo(0, -256*me.instantFoVradius/60)
+++				.setColor(1,1,1);
+++		}
+++	},
+++	clearShowScan: func {
+++		if (me["canvas2"] == nil or me.debug < 1) return;
+++		me.canvas_root2.removeAllChildren();
+++		if (me.horizonStabilized) {
+++			me.canvas_root2.createChild("path")
+++				.moveTo(-250, 0)
+++				.lineTo(250, 0)
+++				.setColor(1,1,0)
+++				.setStrokeLineWidth(4);
+++		} else {
+++			me.canvas_root2.createChild("path")
+++				.moveTo(256*-5/60, 256*-1.5/60)
+++				.lineTo(256*5/60, 256*-1.5/60)
+++				.lineTo(256*5/60,  256*15/60)
+++				.lineTo(256*-5/60,  256*15/60)
+++				.lineTo(256*-5/60, 256*-1.5/60)
+++				.setColor(1,1,0)
+++				.setStrokeLineWidth(4);
+++		}
+++	},
+++	containsVector: func (vec, item) {
+++		foreach(test; vec) {
+++			if (test == item) {
+++				return 1;
+++			}
+++		}
+++		return 0;
+++	},
+++
+++	containsVectorContact: func (vec, item) {
+++		foreach(test; vec) {
+++			if (test.equals(item)) {
+++				return 1;
+++			}
+++		}
+++		return 0;
+++	},
+++
+++	vectorIndex: func (vec, item) {
+++		me.i = 0;
+++		foreach(test; vec) {
+++			if (test == item) {
+++				return me.i;
+++			}
+++			me.i += 1;
+++		}
+++		return -1;
+++	},
+++	del: func {
+++        emesary.GlobalTransmitter.DeRegister(me.ActiveDiscRadarRecipient);
+++    },
+++};
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++var SPOT_SCAN = -1; # must be -1
+++
+++
+++
+++
+++
+++#  ██████   █████  ██████   █████  ██████      ███    ███  ██████  ██████  ███████
+++#  ██   ██ ██   ██ ██   ██ ██   ██ ██   ██     ████  ████ ██    ██ ██   ██ ██
+++#  ██████  ███████ ██   ██ ███████ ██████      ██ ████ ██ ██    ██ ██   ██ █████
+++#  ██   ██ ██   ██ ██   ██ ██   ██ ██   ██     ██  ██  ██ ██    ██ ██   ██ ██
+++#  ██   ██ ██   ██ ██████  ██   ██ ██   ██     ██      ██  ██████  ██████  ███████
+++#
+++#
+++var RadarMode = {
+++	#
+++	# Subclass and modify as needed.
+++	#
+++	radar: nil,
+++	range: 40,
+++	minRange: 5,
+++	maxRange: 160,
+++	az: 60,
+++	bars: 1,
+++	azimuthTilt: 0,# modes set these depending on where they want the pattern to be centered.
+++	elevationTilt: 0,
+++	barHeight: 0.80,# multiple of instantFoVradius
+++	barPattern:  [ [[-1,0],[1,0]] ],     # The second is multitude of instantFoVradius, the first is multitudes of me.az
+++	barPatternMin: [0],
+++	barPatternMax: [0],
+++	nextPatternNode: 0,
+++	scanPriorityEveryFrame: 0,# Related to SPOT_SCAN.
+++	timeToFadeBleps: 13,
+++	rootName: "Base",
+++	shortName: "",
+++	longName: "",
+++	superMode: nil,
+++	minimumTimePerReturn: 0.5,
+++	rcsFactor: 0.9,
+++	lastFrameStart: -1,
+++	lastFrameDuration: 5,
+++	detectAIR: 1,
+++	detectSURFACE: 0,
+++	detectMARINE: 0,
+++	pulse: DOPPLER, # MONO or DOPPLER
+++	minClosure: 0, # kt
+++	cursorAz: 0,
+++	cursorNm: 20,
+++	upperAngle: 10,
+++	lowerAngle: 10,
+++	painter: 0, # if the mode when having a priority target will produce a hard lock on target.
+++	mapper: 0,
+++	discSpeed_dps: 1,# current disc speed. Must never be zero.
+++	setRange: func (range) {
+++		me.testMulti = me.maxRange/range;
+++		if (int(me.testMulti) != me.testMulti) {
+++			# max range is not dividable by range, so we don't change range
+++			return 0;
+++		}
+++		me.range = math.min(me.maxRange, range);
+++		me.range = math.max(me.minRange, me.range);
+++		return range == me.range;
+++	},
+++	getRange: func {
+++		return me.range;
+++	},
+++	_increaseRange: func {
+++		me.range*=2;
+++		if (me.range>me.maxRange) {
+++			me.range*=0.5;
+++			return 0;
+++		}
+++		return 1;
+++	},
+++	_decreaseRange: func {
+++		me.range *= 0.5;
+++		if (me.range < me.minRange) {
+++			me.range *= 2;
+++			return 0;
+++		}
+++		return 1;
+++	},
+++	getDeviation: func {
+++		# how much the pattern is deviated from straight ahead in azimuth
+++		return me.azimuthTilt;
+++	},
+++	getBars: func {
+++		return me.bars;
+++	},
+++	getAz: func {
+++		return me.az;
+++	},
+++	constrainAz: func () {
+++		# Convinience method that the modes can use.
+++		if (me.az == me.radar.fieldOfRegardMaxAz) {
+++			me.azimuthTilt = 0;
+++		} elsif (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+++		}
+++	},
+++	getPriority: func {
+++		return me["priorityTarget"];
+++	},
+++	computePattern: func {
+++		# Translate the normalized pattern nodes into degrees. Since me.az or maybe me.bars have tendency to change rapidly
+++		# We do this every step. Its fast anyway.
+++		me.currentPattern = [];
+++		foreach (me.eulerNorm ; me.barPattern[me.bars-1]) {
+++			me.patternNode = [me.eulerNorm[0]*me.az, me.eulerNorm[1]*me.radar.instantFoVradius*me.barHeight];
+++			append(me.currentPattern, me.patternNode);
+++		}
+++		return me.currentPattern;
+++	},
+++	step: func (dt) {
+++		me.radar.horizonStabilized = 1;# Might be unset inside preStep()
+++
+++		# Individual modes override this method and get ready for the step.
+++		# Inside this they typically set 'azimuthTilt' and 'elevationTilt' for moving the pattern around.
+++		me.preStep();
+++
+++		# Lets figure out the desired antennae tilts
+++	 	me.azimuthTiltIntern = me.azimuthTilt;
+++	 	me.elevationTiltIntern = me.elevationTilt;
+++		if (me.nextPatternNode == SPOT_SCAN and me.priorityTarget != nil) {
+++			# We never do spot scans in ACM modes so no check for horizonStabilized here.
+++			me.lastBlep = me.priorityTarget.getLastBlep();
+++			if (me.lastBlep != nil) {
+++				me.azimuthTiltIntern = me.lastBlep.getAZDeviation();
+++				me.elevationTiltIntern = me.lastBlep.getElev();
+++			} else {
+++				me.priorityTarget = nil;
+++				me.undesignate();
+++				me.nextPatternNode == 0;
+++			}
+++		} elsif (me.nextPatternNode == SPOT_SCAN) {
+++			# We cannot do spot scan on stuff we cannot see, reverting back to pattern
+++			me.nextPatternNode = 0;
+++		}
+++
+++		# now lets check where we want to move the disc to
+++		me.currentPattern      = me.computePattern();
+++		me.targetAzimuthTilt   = me.azimuthTiltIntern+(me.nextPatternNode!=SPOT_SCAN?me.currentPattern[me.nextPatternNode][0]:0);
+++		me.targetElevationTilt = me.elevationTiltIntern+(me.nextPatternNode!=SPOT_SCAN?me.currentPattern[me.nextPatternNode][1]:0);
+++
+++		# The pattern min/max pitch when not tilted.
+++		me.min = me.barPatternMin[me.bars-1]*me.barHeight*me.radar.instantFoVradius;
+++		me.max = me.barPatternMax[me.bars-1]*me.barHeight*me.radar.instantFoVradius;
+++
+++		# We check if radar gimbal mount can turn enough.
+++		me.gimbalInBounds = 1;
+++		if (me.radar.horizonStabilized) {
+++			# figure out if we reach the gimbal limit
+++	 		me.actualMin = self.getPitch()+me.radar.fieldOfRegardMinElev;
+++	 		me.actualMax = self.getPitch()+me.radar.fieldOfRegardMaxElev;
+++	 		if (me.targetElevationTilt < me.actualMin) {
+++	 			me.gimbalInBounds = 0;
+++	 		} elsif (me.targetElevationTilt > me.actualMax) {
+++	 			me.gimbalInBounds = 0;
+++	 		}
+++ 		}
+++ 		if (!me.gimbalInBounds) {
+++ 			# Don't move the antennae if it cannot reach whats requested.
+++ 			# This basically stop the radar from working while still not on standby
+++ 			# until better attitude is reached.
+++ 			#
+++ 			# It used to attempt to scan in edge of FoR but thats not really helpful to a pilot.
+++ 			# If need to scan while extreme attitudes then the are specific modes for that (in some aircraft).
+++ 			me.radar.setAntennae(me.radar.positionDirection);
+++ 			#print("db-Out of gimbal bounds");
+++	 		return 0;
+++	 	}
+++
+++	 	# For help with cursor limits we need to compute these
+++		if (me.radar.horizonStabilized and me.gimbalInBounds) {
+++			me.lowerAngle = me.min+me.elevationTiltIntern;
+++			me.upperAngle = me.max+me.elevationTiltIntern;
+++		} else {
+++			me.lowerAngle = 0;
+++			me.upperAngle = 0;
+++		}
+++
+++	 	# Lets get a status for where we are in relation to where we are going
+++		me.targetDir = vector.Math.pitchYawVector(me.targetElevationTilt, -me.targetAzimuthTilt, [1,0,0]);# A vector for where we want the disc to go
+++		me.angleToNextNode = vector.Math.angleBetweenVectors(me.radar.positionDirection, me.targetDir);# Lets test how far from the target tilts we are.
+++
+++		# Move the disc
+++		if (me.angleToNextNode < me.radar.instantFoVradius) {
+++			# We have reached our target
+++			me.radar.setAntennae(me.targetDir);
+++			me.nextPatternNode += 1;
+++			if (me.nextPatternNode >= size(me.currentPattern)) {
+++				me.nextPatternNode = (me.scanPriorityEveryFrame and me.priorityTarget!=nil)?SPOT_SCAN:0;
+++				me.frameCompleted();
+++			}
+++			#print("db-node:", me.nextPatternNode);
+++			# Now the antennae has been moved and we return how much leftover dt there is to the main radar.
+++			return dt-me.angleToNextNode/me.discSpeed_dps;# Since we move disc seperately in axes, this is not strictly correct, but close enough.
+++		}
+++
+++		# Lets move each axis of the radar seperate, as most radars likely has 2 joints anyway.
+++		me.maxMove = math.min(me.radar.instantFoVradius*overlapHorizontal, me.discSpeed_dps*dt);# 1.75 instead of 2 is because the FoV is round so we overlap em a bit
+++
+++		# Azimuth
+++		me.distance_deg = me.targetAzimuthTilt - me.radar.eulerX;
+++		if (me.distance_deg >= 0) {
+++			me.moveX =  math.min(me.maxMove, me.distance_deg);
+++		} else {
+++			me.moveX = math.max(-me.maxMove, me.distance_deg);
+++		}
+++		me.newX = me.radar.eulerX + me.moveX;
+++
+++		# Elevation
+++		me.distance_deg = me.targetElevationTilt - me.radar.eulerY;
+++		if (me.distance_deg >= 0) {
+++			me.moveY =  math.min(me.maxMove, me.distance_deg);
+++		} else {
+++			me.moveY =  math.max(-me.maxMove, me.distance_deg);
+++		}
+++		me.newY = me.radar.eulerY + me.moveY;
+++
+++		# Convert the angles to a vector and set the new antennae position
+++		me.newPos = vector.Math.pitchYawVector(me.newY, -me.newX, [1,0,0]);
+++		me.radar.setAntennae(me.newPos);
+++
+++		# As the two joins move at the same time, we find out which moved the most
+++		me.movedMax = math.max(math.abs(me.moveX), math.abs(me.moveY));
+++		if (me.movedMax == 0) {
+++			# This should really not happen, we return 0 to make sure the while loop don't get infinite.
+++			print("me.movedMax == 0");
+++			return 0;
+++		}
+++		if (me.movedMax > me.discSpeed_dps) {
+++			print("me.movedMax > me.discSpeed_dps");
+++			return 0;
+++		}
+++		return dt-me.movedMax/me.discSpeed_dps;
+++	},
+++	frameCompleted: func {
+++		if (me.lastFrameStart != -1) {
+++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+++		}
+++		me.lastFrameStart = me.radar.elapsed;
+++	},
+++	setCursorDeviation: func (cursor_az) {
+++		me.cursorAz = cursor_az;
+++	},
+++	getCursorDeviation: func {
+++		return me.cursorAz;
+++	},
+++	setCursorDistance: func (nm) {
+++		# Return if the cursor should be distance zeroed.
+++		return 0;
+++	},
+++	getCursorAltitudeLimits: func {
+++		# Used in F-16 with two numbers next to cursor that indicates min/max for radar pattern in altitude above sealevel.
+++		# It needs: me.lowerAngle, me.upperAngle and me.cursorNm
+++		me.vectorToDist = [math.cos(me.upperAngle*D2R), 0, math.sin(me.upperAngle*D2R)];
+++		me.selfC = self.getCoord();
+++		me.geo = vector.Math.vectorToGeoVector(me.vectorToDist, me.selfC);
+++		me.geo = vector.Math.product(me.cursorNm*NM2M, vector.Math.normalize(me.geo.vector));
+++		me.up = geo.Coord.new();
+++		me.up.set_xyz(me.selfC.x()+me.geo[0],me.selfC.y()+me.geo[1],me.selfC.z()+me.geo[2]);
+++		me.vectorToDist = [math.cos(me.lowerAngle*D2R), 0, math.sin(me.lowerAngle*D2R)];
+++		me.geo = vector.Math.vectorToGeoVector(me.vectorToDist, me.selfC);
+++		me.geo = vector.Math.product(me.cursorNm*NM2M, vector.Math.normalize(me.geo.vector));
+++		me.down = geo.Coord.new();
+++		me.down.set_xyz(me.selfC.x()+me.geo[0],me.selfC.y()+me.geo[1],me.selfC.z()+me.geo[2]);
+++		return [me.up.alt()*M2FT, me.down.alt()*M2FT];
+++	},
+++	leaveMode: func {
+++		# Warning: In this method do not set anything on me.radar only on me.
+++		me.lastFrameStart = -1;
+++	},
+++	enterMode: func {
+++	},
+++	designatePriority: func (contact) {},
+++	cycleDesignate: func {},
+++	testContact: func (contact) {},
+++	prunedContact: func (c) {
+++		if (c.equalsFast(me["priorityTarget"])) {
+++			me.priorityTarget = nil;
+++		}
+++	},
+++};#                                    END Radar Mode class
+++
+++
+++
+++
+++
+++
+++#  ██████   █████  ████████  █████  ██      ██ ███    ██ ██   ██ 
+++#  ██   ██ ██   ██    ██    ██   ██ ██      ██ ████   ██ ██  ██  
+++#  ██   ██ ███████    ██    ███████ ██      ██ ██ ██  ██ █████  
+++#  ██   ██ ██   ██    ██    ██   ██ ██      ██ ██  ██ ██ ██  ██ 
+++#  ██████  ██   ██    ██    ██   ██ ███████ ██ ██   ████ ██   ██ 
+++#                                                                
+++#
+++DatalinkRadar = {
+++	# I check the sky 360 deg for anything on datalink
+++	#
+++	# I will set 'blue' and 'blueIndex' on contacts.
+++	# blue==1: On our datalink
+++	# blue==2: Targeted by someone on our datalink
+++	#
+++	# Direct line of sight required for ~1000MHz signal.
+++	#
+++	# This class is only semi generic!
+++	new: func (rate, max_dist_fighter_nm, max_dist_station_nm) {
+++		var dlnk = {parents: [DatalinkRadar, Radar]};
+++
+++		dlnk.max_dist_fighter_nm = max_dist_fighter_nm;
+++		dlnk.max_dist_station_nm = max_dist_station_nm;
+++
+++		datalink.can_transmit = func(callsign, mp_prop, mp_index) {
+++		    dlnk.contactSender = callsignToContact.get(callsign);
+++		    if (dlnk.contactSender == nil) return 0;
+++		    if (!dlnk.contactSender.isValid()) return 0;
+++		    if (!dlnk.contactSender.isVisible()) return 0;
+++
+++		    dlnk.isContactStation = isKnownSurface(dlnk.contactSender.getModel()) or isKnownShip(dlnk.contactSender.getModel()) or isKnownAwacs(dlnk.contactSender.getModel());
+++		    dlnk.max_dist_nm = dlnk.isContactStation?dlnk.max_dist_station_nm:dlnk.max_dist_fighter_nm;
+++
+++		    return dlnk.contactSender.get_range() < dlnk.max_dist_nm;
+++		}
+++
+++
+++		dlnk.index = 0;
+++		dlnk.vector_aicontacts = [];
+++		dlnk.vector_aicontacts_for = [];
+++		dlnk.timer          = maketimer(rate, dlnk, func dlnk.scan());
+++
+++		dlnk.DatalinkRadarRecipient = emesary.Recipient.new("DatalinkRadarRecipient");
+++		dlnk.DatalinkRadarRecipient.radar = dlnk;
+++		dlnk.DatalinkRadarRecipient.Receive = func(notification) {
+++	        if (notification.NotificationType == "AINotification") {
+++	        	#printf("DLNKRadar recv: %s", notification.NotificationType);
+++	        	#printf("DLNKRadar notified of %d contacts", size(notification.vector));
+++    		    me.radar.vector_aicontacts = notification.vector;
+++    		    me.radar.index = 0;
+++	            return emesary.Transmitter.ReceiptStatus_OK;
+++	        }
+++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+++	    };
+++		emesary.GlobalTransmitter.Register(dlnk.DatalinkRadarRecipient);
+++		dlnk.DatalinkNotification = VectorNotification.new("DatalinkNotification");
+++		dlnk.DatalinkNotification.updateV(dlnk.vector_aicontacts_for);
+++		dlnk.timer.start();
+++		return dlnk;
+++	},
+++
+++	scan: func () {
+++		if (!me.enabled) return;
+++
+++		#this loop is really fast. But we only check 1 contact per call
+++		if (me.index >= size(me.vector_aicontacts)) {
+++			# will happen if there is no contacts or if contact(s) went away
+++			me.index = 0;
+++			return;
+++		}
+++		me.contact = me.vector_aicontacts[me.index];
+++		me.wasBlue = me.contact["blue"];
+++		me.cs = me.contact.get_Callsign();
+++		if (me.wasBlue == nil) me.wasBlue = 0;
+++
+++		if (!me.contact.isValid()) {
+++			me.contact.blue = 0;
+++			if (me.wasBlue > 0) {
+++				#print(me.cs," is invalid and purged from Datalink");
+++				me.new_vector_aicontacts_for = [];
+++				foreach (me.c ; me.vector_aicontacts_for) {
+++					if (!me.c.equals(me.contact) and !me.c.equalsFast(me.contact)) {
+++						append(me.new_vector_aicontacts_for, me.c);
+++					}
+++				}
+++				me.vector_aicontacts_for = me.new_vector_aicontacts_for;
+++			}
+++		} else {
+++
+++
+++	        if (!me.contact.isValid()) {
+++	        	me.lnk = nil;
+++	        } else {
+++	        	me.lnk = datalink.get_data(damage.processCallsign(me.cs));
+++	        }
+++
+++	        if (me.lnk != nil and me.lnk.on_link() == 1) {
+++	            me.blue = 1;
+++	            me.blueIndex = me.lnk.index()+1;
+++	        } elsif (me.cs == getprop("link16/wingman-4")) { # Hack that the F16 need. Just ignore it, as nil wont cause expection.
+++	            me.blue = 1;
+++	            me.blueIndex = 0;
+++	        } else {
+++	        	me.blue = 0;
+++	            me.blueIndex = -1;
+++	        }
+++	        if (!me.blue and me.lnk != nil and me.lnk.tracked() == 1) {
+++	        	me.dl_idx = me.lnk.tracked_by_index();
+++	        	if (me.dl_idx != nil and me.dl_idx > -1) {
+++		            me.blue = 2;
+++		            me.blueIndex = me.dl_idx+1;
+++			    }
+++	        }
+++
+++	        me.contact.blue = me.blue;
+++	        if (me.blue > 0) {
+++	        	me.contact.blueIndex = me.blueIndex;
+++				if (!AirborneRadar.containsVectorContact(me.vector_aicontacts_for, me.contact)) {
+++					append(me.vector_aicontacts_for, me.contact);
+++					emesary.GlobalTransmitter.NotifyAll(me.DatalinkNotification.updateV(me.vector_aicontacts_for));
+++				}
+++			} elsif (me.wasBlue > 0) {
+++				me.new_vector_aicontacts_for = [];
+++				foreach (me.c ; me.vector_aicontacts_for) {
+++					if (!me.c.equals(me.contact) and !me.c.equalsFast(me.contact)) {
+++						append(me.new_vector_aicontacts_for, me.c);
+++					}
+++				}
+++				me.vector_aicontacts_for = me.new_vector_aicontacts_for;
+++			}
+++		}
+++		me.index += 1;
+++        if (me.index > size(me.vector_aicontacts)-1) {
+++        	me.index = 0;
+++
+++        	# Lets not keep contacts no longer in our scene
+++        	me.new_vector_aicontacts_for = [];
+++			foreach (me.c ; me.vector_aicontacts_for) {
+++				if (AirborneRadar.containsVectorContact(me.vector_aicontacts, me.c)) {
+++					append(me.new_vector_aicontacts_for, me.c);
+++				}
+++			}
+++			me.vector_aicontacts_for = me.new_vector_aicontacts_for;
+++
+++        	emesary.GlobalTransmitter.NotifyAll(me.DatalinkNotification.updateV(me.vector_aicontacts_for));
+++        }
+++	},
+++	del: func {
+++        emesary.GlobalTransmitter.DeRegister(me.DatalinkRadarRecipient);
+++    },
+++};
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++########################### BEGIN NON-GENERIC CLASSES ##########################
+++
+++
+++
+++
+++
+++
+++
+++#   █████  ██████   ██████         ██████   █████ 
+++#  ██   ██ ██   ██ ██             ██       ██   ██ 
+++#  ███████ ██████  ██   ███ █████ ███████   █████  
+++#  ██   ██ ██      ██    ██       ██    ██ ██   ██ 
+++#  ██   ██ ██       ██████         ██████   █████  
+++#                                                 
+++#
+++var APG68 = {
+++	#
+++	# Root modes is  0: CRM  1: ACM 2: SEA 3: GM 4: GMT
+++	#
+++	instantFoVradius: 3.90*0.5,#average of horiz/vert radius
+++	instantVertFoVradius: 4.55*0.5,# real vert radius (used by ground mapper)
+++	instantHoriFoVradius: 3.25*0.5,# real hori radius (not used)
+++	rcsRefDistance: 70,
+++	rcsRefValue: 3.2,
+++	targetHistory: 3,# Not used in TWS
+++	isEnabled: func {
+++		return getprop("/f16/avionics/power-fcr-bit") == 2 and getprop("instrumentation/radar/radar-enable") and !getprop("/fdm/jsbsim/gear/unit[0]/WOW") and getprop("instrumentation/radar/serviceable");
+++	},
+++	setAGMode: func {
+++		if (me.rootMode != 3) {
+++			me.rootMode = 3;
+++			me.oldMode = me.currentMode;
+++
+++			me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+++			me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+++		}
+++	},
+++	setAAMode: func {
+++		if (me.rootMode != 0) {
+++			me.rootMode = 0;
+++			me.oldMode = me.currentMode;
+++
+++			me.newMode = me.mainModes[me.rootMode][me.currentModeIndex[me.rootMode]];
+++			me.setCurrentMode(me.newMode, me.oldMode["priorityTarget"]);
+++		}
+++	},
+++	showAZ: func {
+++		me.currentMode.showAZ();
+++	},
+++	showAZinHSD: func {
+++		me.currentMode.showAZinHSD();
+++	},
+++};
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++#  ███████        ██  ██████      ███    ███  █████  ██ ███    ██     ███    ███  ██████  ██████  ███████
+++#  ██            ███ ██           ████  ████ ██   ██ ██ ████   ██     ████  ████ ██    ██ ██   ██ ██
+++#  █████   █████  ██ ███████      ██ ████ ██ ███████ ██ ██ ██  ██     ██ ████ ██ ██    ██ ██   ██ █████
+++#  ██             ██ ██    ██     ██  ██  ██ ██   ██ ██ ██  ██ ██     ██  ██  ██ ██    ██ ██   ██ ██
+++#  ██             ██  ██████      ██      ██ ██   ██ ██ ██   ████     ██      ██  ██████  ██████  ███████
+++#
+++#
+++var APG68Mode = {
+++	minRange: 5, # MLU T1 .. should we make this 10 for block 10/30/YF? TODO
+++	maxRange: 160,
+++	bars: 4,
+++	barPattern:  [ [[-1,0],[1,0]],                    # These are multitudes of [me.az, instantFoVradius]
+++	               [[-1,-1],[1,-1],[1,1],[-1,1]],
+++	               [[-1,0],[1,0],[1,2],[-1,2],[-1,0],[1,0],[1,-2],[-1,-2]],
+++	               [[1,-3],[1,3],[-1,3],[-1,1],[1,1],[1,-1],[-1,-1],[-1,-3]] ],
+++	barPatternMin: [0,-1, -2, -3],
+++	barPatternMax: [0, 1,  2,  3],
+++	rootName: "CRM",
+++	shortName: "",
+++	longName: "",
+++	EXPsupport: 0,#if support zoom
+++	EXPsearch: 1,# if zoom should include search targets
+++	EXPfixedAim: 0,# If map underneath should move instead of cursor when slewing
+++	showAZ: func {
+++		return me.az != me.radar.fieldOfRegardMaxAz; # If this return false, then they are also not shown in PPI.
+++	},
+++	showAZinHSD: func {
+++		return 1;
+++	},
+++	showBars: func {
+++		return 1;
+++	},
+++	showRangeOptions: func {
+++		return 1;
+++	},
+++	setCursorDistance: func (nm) {
+++		# Return if the cursor should be distance zeroed.
+++		me.cursorNm = nm;
+++		if (nm < me.radar.getRange()*0.05) {
+++			return me.decreaseRange();
+++		} elsif (nm > me.radar.getRange()*0.95) {
+++			return me.increaseRange();
+++		}
+++		return 0;
+++	},
+++	frameCompleted: func {
+++		if (me.lastFrameStart != -1) {
+++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+++			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
+++		}
+++		me.lastFrameStart = me.radar.elapsed;
+++	},
+++};#                                    END APG-68 Mode base class
+++
+++
+++
+++
+++
+++
+++
+++
+++#  ██████  ██     ██ ███████ 
+++#  ██   ██ ██     ██ ██      
+++#  ██████  ██  █  ██ ███████ 
+++#  ██   ██ ██ ███ ██      ██ 
+++#  ██   ██  ███ ███  ███████ 
+++#                            
+++#
+++var F16RWSMode = {
+++	radar: nil,
+++	shortName: "RWS",
+++	longName: "Range While Search",
+++	superMode: nil,
+++	subMode: nil,
+++	maxRange: 160,
+++	discSpeed_dps: 65,#authentic for RWS
+++	rcsFactor: 0.9,
+++	EXPsupport: 1,#if support zoom
+++	EXPsearch: 1,# if zoom should include search targets
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16RWSMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		subMode.superMode = mode;
+++		subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++	cycleAZ: func {
+++		if (me.az == 10) me.az = 30;
+++		elsif (me.az == 30) me.az = 60;
+++		elsif (me.az == 60) me.az = 10;
+++	},
+++	cycleBars: func {
+++		me.bars += 1;
+++		if (me.bars == 3) me.bars = 4;# 3 is only for TWS
+++		elsif (me.bars == 5) me.bars = 1;
+++		me.nextPatternNode = 0;
+++	},
+++	designate: func (designate_contact) {
+++		if (designate_contact == nil) return;
+++		me.radar.setCurrentMode(me.subMode, designate_contact);
+++		me.subMode.radar = me.radar;# find some smarter way of setting it.
+++	},
+++	undesignate: func {},
+++	designatePriority: func (contact) {
+++		me.designate(contact);
+++	},
+++	preStep: func {
+++		var dev_tilt_deg = me.cursorAz;
+++		me.elevationTilt = me.radar.getTiltKnob();
+++		if (me.az == 60) {
+++			dev_tilt_deg = 0;
+++		}
+++		me.azimuthTilt = dev_tilt_deg;
+++		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+++		}
+++	},
+++	increaseRange: func {
+++		me._increaseRange();
+++	},
+++	decreaseRange: func {
+++		me._decreaseRange();
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		return [1,0,1,0,0,1];
+++	},
+++};
+++
+++
+++#  ██      ██████  ███████ 
+++#  ██      ██   ██ ██      
+++#  ██      ██████  ███████ 
+++#  ██      ██   ██      ██ 
+++#  ███████ ██   ██ ███████ 
+++#                          
+++#
+++var F16LRSMode = {
+++	shortName: "LRS",
+++	longName: "Long Range Search",
+++	range: 160,
+++	discSpeed_dps: 45,
+++	rcsFactor: 1,
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16LRSMode, F16RWSMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		subMode.superMode = mode;
+++		subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++};
+++
+++
+++#  ███████ ███████  █████ 
+++#  ██      ██      ██   ██ 
+++#  ███████ █████   ███████ 
+++#       ██ ██      ██   ██ 
+++#  ███████ ███████ ██   ██ 
+++#                          
+++#
+++var F16SeaMode = {
+++	rootName: "SEA",
+++	shortName: "AUTO",
+++	longName: "Sea Navigation Mode",
+++	discSpeed_dps: 55,# was 55
+++	maxRange: 80,
+++	range: 20,
+++	bars: 1,
+++	rcsFactor: 1,
+++	detectAIR: 0,
+++	detectSURFACE: 0,
+++	detectMARINE: 1,
+++	pulse: MONO, # MONO or DOPPLER
+++	#barPattern:  [ [[-1,-3],[1,-3]], # The SURFACE/SEA pattern is centered so pattern is almost entirely under horizon
+++	#               [[-1,-5],[1,-5],[1,-3],[-1,-3]],
+++	#               [[-1,-5],[1,-5],[1,-3],[-1,-3],[-1,-5],[1,-5],[1,-7],[-1,-7]],
+++	#               [[1,-7],[1,-1],[-1,-1],[-1,-3],[1,-3],[1,-5],[-1,-5],[-1,-7]] ],
+++	#barPatternMin: [-3, -5, -7, -7], # about down to -15 degs coverage from horizon with 4 bars
+++	#barPatternMax: [-3, -3, -3, -1],
+++	EXPsupport: 1,
+++	EXPfixedAim: 1,
+++	exp: 0,
+++	expAz: 0,
+++	expDistNm: 10,
+++	autoCursor: 1,
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16SeaMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		subMode.superMode = mode;
+++		subMode.shortName = mode.shortName;
+++		subMode.rootName = mode.rootName;
+++		return mode;
+++	},
+++	toggleAuto: func {
+++		me.autoCursor = !me.autoCursor;
+++		me.shortName = me.autoCursor?"AUTO":"MAN";
+++	},
+++	setCursorDistance: func (nm) {
+++		# Return if the cursor should be distance zeroed.
+++		me.cursorNm = nm;
+++		if (me.autoCursor and nm < me.radar.getRange()*0.425) {
+++			return me.decreaseRange();
+++		} elsif (me.autoCursor and nm > me.radar.getRange()*0.95) {
+++			return me.increaseRange();
+++		}
+++		return 0;
+++	},
+++	preStep: func {
+++		var dev_tilt_deg = me.cursorAz;
+++		if (me.az == 60) {
+++			dev_tilt_deg = 0;
+++		}
+++		me.azimuthTilt = dev_tilt_deg;
+++		me.elevationTilt = me.radar.getTiltKnob();
+++		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+++		}
+++		if (me.radar.getTiltKnob() == 0 and steerpoints.getCurrentNumber() != 0) {
+++			me.groundPitch = steerpoints.getCurrentGroundPitch();
+++			if (me.groundPitch != nil and me.groundPitch > -55 and me.groundPitch < 55) {
+++				me.elevationTilt = me.groundPitch;
+++			}
+++		}
+++	},
+++	cycleAZ: func {
+++		if (me.az == 10) me.az = 30;
+++		elsif (me.az == 30) me.az = 60;
+++		elsif (me.az == 60) me.az = 10;
+++	},
+++	cycleBars: func {
+++	},
+++	showBars: func {
+++		return 0;
+++	},
+++	getEXPsize: func {
+++		# return nm of zoom width
+++		if (me.getRange() == 10) {
+++			return 3.5;
+++		} elsif (me.getRange() == 20) {
+++			return 7;
+++		} elsif (me.getRange() == 40) {
+++			return 14;
+++		} elsif (me.getRange() == 80) {
+++			return 21;
+++		}
+++	},
+++	showAZ: func {
+++		return 1;
+++	},
+++	increaseRange: func {
+++		me._increaseRange();
+++	},
+++	decreaseRange: func {
+++		me._decreaseRange();
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		return [1,0,1,0,0,1];
+++	},
+++	designate: func (designate_contact) {
+++		if (designate_contact == nil) return;
+++		me.radar.setCurrentMode(me.subMode, designate_contact);
+++		me.subMode.radar = me.radar;# find some smarter way of setting it.
+++	},
+++	undesignate: func {},
+++	designatePriority: func (contact) {
+++	},
+++	enterMode: func {
+++		me.radar.purgeAllBleps();
+++	},
+++};
+++
+++
+++#   ██████  ███    ███ 
+++#  ██       ████  ████ 
+++#  ██   ███ ██ ████ ██ 
+++#  ██    ██ ██  ██  ██ 
+++#   ██████  ██      ██ 
+++#                      
+++#
+++var F16GMMode = {
+++	rootName: "GM",
+++	longName: "Ground Map",
+++	discSpeed_dps: 55,
+++	detectAIR: 0,
+++	detectSURFACE: 1,
+++	detectMARINE: 0,
+++	mapper: 1,
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16GMMode, F16SeaMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		subMode.superMode = mode;
+++		subMode.shortName = mode.shortName;
+++		subMode.rootName = mode.rootName;
+++		return mode;
+++	},
+++	frameCompleted: func {
+++		#print("frame ",me.radar.elapsed-me.lastFrameStart);
+++		if (me.lastFrameStart != -1) {
+++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+++			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
+++		}
+++		me.lastFrameStart = me.radar.elapsed;
+++		if (me.radar["gmapper"] != nil) {
+++			me.radar.gmapper.frameDone();
+++		}
+++	},
+++	setExp: func (exp) {
+++		me.exp = exp;
+++		if (me.radar["gmapper"] != nil) me.radar.gmapper.expChanged(exp);
+++	},
+++	isEXP: func {
+++		return me.exp;
+++	},
+++	setExpPosition: func (azimuth, distance_nm) {
+++		me.expAz = azimuth;
+++		me.expDistNm = distance_nm;
+++	},
+++	getEXPBoundary: func {
+++		if (me.exp and 0) {
+++			me.expWidthNm = me.getEXPsize();
+++			me.expCart = [me.expDistNm*math.sin(me.expAz*D2R), me.expDistNm*math.cos(me.expAz*D2R)];
+++			me.expCornerCartBegin = [me.expCart[0]-me.expWidthNm*0.5, me.expCart[1]-me.expWidthNm*0.5];
+++			me.expCornerCartEnd   = [me.expCart[0]+me.expWidthNm*0.5, me.expCart[1]-me.expWidthNm*0.5];
+++			me.expCornerDist1 = math.sqrt(me.expCornerCartBegin[0]*me.expCornerCartBegin[0]+me.expCornerCartBegin[1]*me.expCornerCartBegin[1]);
+++			me.expCornerDist2 = math.sqrt(me.expCornerCartEnd[0]*me.expCornerCartEnd[0]+me.expCornerCartEnd[1]*me.expCornerCartEnd[1]);
+++			me.azStart = math.asin(math.clamp(me.expCornerCartBegin[0]/me.expCornerDist1,0,1))*R2D;
+++			me.azEnd = math.asin(math.clamp(me.expCornerCartEnd[0]/me.expCornerDist2,0,1))*R2D;
+++			if (me.expCornerDist1 > me.expCornerDist2) {
+++				me.expCornerCartBegin[1] += me.expWidthNm;
+++				me.cornerRangeNm = math.sqrt(me.expCornerCartBegin[0]*me.expCornerCartBegin[0]+me.expCornerCartBegin[1]*me.expCornerCartBegin[1]);
+++				me.expMinRange = me.expCornerCartEnd[1];
+++			} else {
+++				me.expCornerCartEnd[1] += me.expWidthNm;
+++				me.cornerRangeNm = math.sqrt(me.expCornerCartEnd[0]*me.expCornerCartEnd[0]+me.expCornerCartEnd[1]*me.expCornerCartEnd[1]);
+++				me.expMinRange = me.expCornerCartBegin[1];
+++			}
+++			# deg start/end and min and max range in nm:
+++			return [me.azStart, me.azEnd, me.expMinRange, me.cornerRangeNm];
+++		} else {
+++			return nil;
+++		}
+++	},
+++};
+++
+++
+++#   ██████  ███    ███ ████████ 
+++#  ██       ████  ████    ██    
+++#  ██   ███ ██ ████ ██    ██ 
+++#  ██    ██ ██  ██  ██    ██ 
+++#   ██████  ██      ██    ██ 
+++#                            
+++#
+++var F16GMTMode = {
+++	rootName: "GMT",
+++	longName: "Ground Moving Target",
+++	discSpeed_dps: 55,
+++	maxRange: 40,
+++	bars: 4,
+++	detectAIR: 0,
+++	detectSURFACE: 1,
+++	detectMARINE: 0,
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16GMTMode, F16SeaMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		subMode.superMode = mode;
+++		subMode.shortName = mode.shortName;
+++		subMode.rootName = mode.rootName;
+++		return mode;
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		me.devGMT = contact.getDeviationStored();
+++		if (me.devGMT.speed_kt < 10) return nil;# A gain knob decide this. (should it be radial speed instead?)
+++		return [1,0,1,1,0,1];
+++	},
+++};
+++
+++
+++#  ██    ██ ███████
+++#  ██    ██ ██     
+++#  ██    ██ ███████
+++#   ██  ██       ██ 
+++#    ████   ███████ 
+++#                           
+++#
+++var F16VSMode = {
+++	shortName: "VS",#todo: make vsr also for newer blocks
+++	longName: "Velocity Search",
+++	range: 160,
+++	discSpeed_dps: 45,
+++	discSpeed_alert_dps: 45,    # From manual
+++	discSpeed_confirm_dps: 100, # From manual
+++	maxScanIntervalForVelocity: 12,
+++	rcsFactor: 1.15,
+++	minClosure: 75, # kt
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16VSMode, F16LRSMode, F16RWSMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		subMode.superMode = mode;
+++		subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++	frameCompleted: func {
+++		if (me.lastFrameStart != -1 and me.discSpeed_dps == me.discSpeed_alert_dps) {
+++			# Its max around 11.5 secs for alert scan
+++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+++			me.timeToFadeBleps = me.radar.targetHistory*me.lastFrameDuration;
+++		}
+++		me.lastFrameStart = me.radar.elapsed;
+++		if (me.discSpeed_dps == me.discSpeed_alert_dps) {
+++			me.discSpeed_dps = me.discSpeed_confirm_dps;
+++		} elsif (me.discSpeed_dps == me.discSpeed_confirm_dps) {
+++			me.discSpeed_dps = me.discSpeed_alert_dps;
+++		}
+++	},
+++	designate: func (designate_contact) {
+++		if (designate_contact == nil) return;
+++		me.radar.setCurrentMode(me.subMode, designate_contact);
+++		me.subMode.radar = me.radar;# find some smarter way of setting it.
+++		me.radar.registerBlep(designate_contact, designate_contact.getDeviationStored(), 0);
+++	},
+++	designatePriority: func {
+++		# NOP
+++	},
+++	undesignate: func {
+++		# NOP
+++	},
+++	preStep: func {
+++		me.elevationTilt = me.radar.getTiltKnob();
+++		var dev_tilt_deg = me.cursorAz;
+++		if (me.az == 60) {
+++			dev_tilt_deg = 0;
+++		}
+++		me.azimuthTilt = dev_tilt_deg;
+++		if (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+++			me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+++		} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+++			me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+++		}
+++	},
+++	increaseRange: func {
+++		#me._increaseRange();
+++	},
+++	decreaseRange: func {
+++		#me._decreaseRange();
+++	},
+++	showRangeOptions: func {
+++		return 0;
+++	},
+++	setRange: func {# Range is always 160 in VS
+++		return 0;
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		#print(me.currentTracked,"   ",(me.radar.elapsed - contact.blepTime));
+++		if (((me.radar.elapsed - contact.getLastBlepTime()) < me.maxScanIntervalForVelocity) and contact.getLastClosureRate() > 0) {
+++			#print("VELOCITY");
+++			return [0,0,1,1,1,0];
+++		}
+++		#print("  EMPTY");
+++		return [0,0,0,0,1,0];
+++	},
+++	getCursorAltitudeLimits: func {
+++		return nil;
+++	},
+++};
+++
+++
+++
+++
+++
+++
+++
+++#  ████████ ██     ██ ███████ 
+++#     ██    ██     ██ ██      
+++#     ██    ██  █  ██ ███████ 
+++#     ██    ██ ███ ██      ██ 
+++#     ██     ███ ███  ███████ 
+++#                             
+++#
+++var F16TWSMode = {
+++	radar: nil,
+++	shortName: "TWS",
+++	longName: "Track While Scan",
+++	superMode: nil,
+++	subMode: nil,
+++	maxRange: 80,
+++	discSpeed_dps: 50, # source: https://www.youtube.com/watch?v=Aq5HXTGUHGI
+++	rcsFactor: 0.9,
+++	timeToBlinkTracks: 8,# GR1F-16CJ-34-1-1
+++	maxScanIntervalForTrack: 6.5,# authentic for TWS
+++	priorityTarget: nil,
+++	currentTracked: [],
+++	maxTracked: 10,
+++	az: 25,# slow scan, so default is 25 to get those double taps in there.
+++	bars: 3,# default is less due to need 2 scans of target to get groundtrack
+++	EXPsupport: 1,#if support zoom
+++	EXPsearch: 0,# if zoom should include search targets
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16TWSMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		subMode.superMode = mode;
+++		subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++	cycleAZ: func {
+++		if (me.az == 10) {
+++			me.az = 25;
+++		} elsif (me.az == 25 and me.priorityTarget == nil) {
+++			me.az = 60;
+++		} elsif (me.az == 25) {
+++			me.az = 10;
+++		} elsif (me.az == 60) {
+++			me.az = 10;
+++		}
+++	},
+++	cycleBars: func {
+++		me.bars += 1;
+++		if (me.priorityTarget != nil and me.bars > 3) {
+++			me.bars = 2;
+++		}
+++		if (me.bars == 5) me.bars = 2;# bars:1 not available in TWS
+++		me.nextPatternNode = 0;
+++	},
+++	designate: func (designate_contact) {
+++		if (designate_contact != nil) {
+++			me.radar.setCurrentMode(me.subMode, designate_contact);
+++			me.subMode.radar = me.radar;# find some smarter way of setting it.
+++		} else {
+++			me.priorityTarget = nil;
+++		}
+++	},
+++	designatePriority: func (contact) {
+++		me.priorityTarget = contact;
+++		if (contact != nil) {
+++			# With a target of interest (TOI), AZ is not allowed to be 60
+++			# Source MLU Tape 1:
+++			me.bars = math.min(3, me.bars);
+++			me.az = math.min(25, me.az);
+++		}
+++	},
+++	getPriority: func {
+++		return me.priorityTarget;
+++	},
+++	undesignate: func {
+++		me.priorityTarget = nil;
+++	},
+++	preStep: func {
+++	 	me.azimuthTilt = me.cursorAz;
+++	 	me.elevationTilt = me.radar.getTiltKnob();
+++		if (me.priorityTarget != nil) {
+++			if (!size(me.priorityTarget.getBleps()) or me.priorityTarget.getLastRangeDirect() == nil or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget) or me.radar.elapsed - me.priorityTarget.getLastBlepTime() > me.radar.timeToKeepBleps) {
+++				me.priorityTarget = nil;
+++				me.undesignate();
+++				return;
+++			}
+++			me.prioRange_nm = me.priorityTarget.getLastRangeDirect()*M2NM;
+++			me.lastBlep = me.priorityTarget.getLastBlep();
+++			if (me.lastBlep != nil) {
+++				me.centerTilt = me.lastBlep.getAZDeviation();
+++				if (me.centerTilt > me.azimuthTilt+me.az) {
+++					me.azimuthTilt = me.centerTilt-me.az;
+++				} elsif (me.centerTilt < me.azimuthTilt-me.az) {
+++					me.azimuthTilt = me.centerTilt+me.az;
+++				}
+++				me.elevationTilt = me.lastBlep.getElev();
+++			} else {
+++				me.priorityTarget = nil;
+++				me.undesignate();
+++				return;
+++			}
+++			if (me.prioRange_nm < 0.40 * me.getRange()) {
+++				me._decreaseRange();
+++			} elsif (me.prioRange_nm > 0.90 * me.getRange()) {
+++				me._increaseRange();
+++			} elsif (me.prioRange_nm < 3) {
+++				# auto go to STT when target is very close
+++				me.designate(me.priorityTarget);
+++			}
+++			# Source MLU Tape 1:
+++			me.bars = math.min(3, me.bars);
+++			me.az = math.min(25, me.az);
+++		} else {
+++			me.undesignate();
+++		}
+++		me.constrainAz();
+++	},
+++	frameCompleted: func {
+++		if (me.lastFrameStart != -1) {
+++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+++		}
+++		me.lastFrameStart = me.radar.elapsed;
+++	},
+++	enterMode: func {
+++		me.currentTracked = [];
+++		foreach(c;me.radar.vector_aicontacts_bleps) {
+++			c.ignoreTrackInfo();# Kind of a hack to make it give out false info. Bypasses hadTrackInfo() but not hasTrackInfo().
+++		}
+++	},
+++	leaveMode: func {
+++		me.priorityTarget = nil;
+++		me.lastFrameStart = -1;
+++	},
+++	increaseRange: func {
+++		if (me.priorityTarget != nil) return 0;
+++		me._increaseRange();
+++	},
+++	decreaseRange: func {
+++		if (me.priorityTarget != nil) return 0;
+++		me._decreaseRange();
+++	},
+++	showRangeOptions: func {
+++		if (me.priorityTarget != nil) return 0;
+++		return 1;
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		#print(me.currentTracked,"   ",(me.radar.elapsed - contact.blepTime));
+++		me.scanInterval = (me.radar.elapsed - contact.getLastBlepTime()) < me.maxScanIntervalForTrack;
+++		me.isInCurrent = me.radar.containsVectorContact(me.currentTracked, contact);
+++		if (size(me.currentTracked) < me.maxTracked and me.scanInterval) {
+++			#print("  TWICE    ",me.radar.elapsed);
+++			#print(me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, contact),"   ",me.radar.elapsed - contact.blepTime);
+++			if (!me.isInCurrent) append(me.currentTracked, contact);
+++			return [1,1,1,1,1,1];
+++		} elsif (me.isInCurrent and me.scanInterval) {
+++			return [1,1,1,1,1,1];
+++		} elsif (me.isInCurrent) {
+++			me.tmp = [];
+++			foreach (me.cc ; me.currentTracked) {
+++				if(!me.cc.equals(contact)) {
+++					append(me.tmp, me.cc);
+++				}
+++			}
+++			me.currentTracked = me.tmp;
+++		}
+++		#print("  ONCE    ",me.currentTracked);
+++		return [1,0,1,0,0,1];
+++	},
+++	prunedContact: func (c) {
+++		if (c.equals(me.priorityTarget)) {
+++			me.priorityTarget = nil;# this might have fixed the nil exception
+++		}
+++		if (c.hadTrackInfo()) {
+++			me.del = me.radar.containsVectorContact(me.currentTracked, c);
+++			if (me.del) {
+++				me.tmp = [];
+++				foreach (me.cc ; me.currentTracked) {
+++					if(!me.cc.equals(c)) {
+++						append(me.tmp, me.cc);
+++					}
+++				}
+++				me.currentTracked = me.tmp;
+++			}
+++		}
+++	},
+++	testContact: func (contact) {
+++		#if (me.radar.elapsed - contact.getLastBlepTime() > me.maxScanIntervalForTrack and contact.azi == 1) {
+++		#	contact.azi = 0;
+++		#	me.currentTracked -= 1;
+++		#}
+++	},
+++	cycleDesignate: func {
+++		if (!size(me.radar.vector_aicontacts_bleps)) {
+++			me.priorityTarget = nil;
+++			return;
+++		}
+++		if (me.priorityTarget == nil) {
+++			me.testIndex = -1;
+++		} else {
+++			me.testIndex = me.radar.vectorIndex(me.radar.vector_aicontacts_bleps, me.priorityTarget);
+++		}
+++		for(me.i = me.testIndex+1;me.i<size(me.radar.vector_aicontacts_bleps);me.i+=1) {
+++			#if (me.radar.vector_aicontacts_bleps[me.i].hadTrackInfo()) {
+++				me.priorityTarget = me.radar.vector_aicontacts_bleps[me.i];
+++				return;
+++			#}
+++		}
+++		for(me.i = 0;me.i<=me.testIndex;me.i+=1) {
+++			#if (me.radar.vector_aicontacts_bleps[me.i].hadTrackInfo()) {
+++				me.priorityTarget = me.radar.vector_aicontacts_bleps[me.i];
+++				return;
+++			#}
+++		}
+++	},
+++};
+++
+++
+++
+++
+++#  ██████  ██     ██ ███████       ███████  █████  ███    ███ 
+++#  ██   ██ ██     ██ ██            ██      ██   ██ ████  ████ 
+++#  ██████  ██  █  ██ ███████ █████ ███████ ███████ ██ ████ ██ 
+++#  ██   ██ ██ ███ ██      ██            ██ ██   ██ ██  ██  ██ 
+++#  ██   ██  ███ ███  ███████       ███████ ██   ██ ██      ██ 
+++#                                                             
+++#
+++var F16RWSSAMMode = {
+++	radar: nil,
+++	shortName: "RWS",
+++	longName: "Range While Search - Situational Awareness Mode",
+++	superMode: nil,
+++	discSpeed_dps: 65,
+++	rcsFactor: 0.9,
+++	maxRange: 160,
+++	priorityTarget: nil,
+++	bars: 2,
+++	azMFD: 60,
+++	new: func (subMode = nil, radar = nil) {
+++		var mode = {parents: [F16RWSSAMMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		if (subMode != nil) {
+++			subMode.superMode = mode;
+++			subMode.radar = radar;
+++			subMode.shortName = mode.shortName;
+++		}
+++		return mode;
+++	},
+++	calcSAMwidth: func {
+++		if (me.prioRange_nm<30) return math.min(60,18 + 2.066667*me.prioRange_nm - 0.02222222*me.prioRange_nm*me.prioRange_nm);
+++		else return 60;
+++	},
+++	preStep: func {
+++		me.azimuthTilt = me.cursorAz;
+++		me.elevationTilt = me.radar.getTiltKnob();
+++		if (me.priorityTarget != nil) {
+++			# azimuth width is autocalculated in F16 AUTO-SAM:
+++			if (!size(me.priorityTarget.getBleps()) or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget)) {
+++				me.priorityTarget = nil;
+++				me.undesignate();
+++				return;
+++			}
+++			me.prioRange_nm = me.priorityTarget.getRangeDirect()*M2NM;
+++			me.az = math.min(me.calcSAMwidth(), me.azMFD);#GR1F-16CJ-34-1-1 page 1-125
+++			me.lastBlep = me.priorityTarget.getLastBlep();
+++			if (me.lastBlep != nil) {
+++				if (math.abs(me.azimuthTilt - (me.lastBlep.getAZDeviation())) > me.az) {
+++					me.scanPriorityEveryFrame = 1;
+++				} else {
+++					me.scanPriorityEveryFrame = 0; # due to the overlap not being perfect, scan the designation extra, just to be safe
+++				}
+++				me.elevationTilt = me.lastBlep.getElev();
+++			} else {
+++				me.priorityTarget = nil;
+++				me.undesignate();
+++				return;
+++			}
+++			if (me.prioRange_nm < 0.40 * me.getRange()) {
+++				me._decreaseRange();
+++			} elsif (me.prioRange_nm > 0.90 * me.getRange()) {
+++				me._increaseRange();
+++			} elsif (me.prioRange_nm < 3) {
+++				# auto go to STT when target is very close
+++				me.designate(me.priorityTarget);
+++			}
+++		} else {
+++			me.scanPriorityEveryFrame = 0;
+++			me.undesignate();
+++		}
+++		me.constrainAz();
+++	},
+++	undesignate: func {
+++		me.priorityTarget = nil;
+++		me.radar.setCurrentMode(me.superMode, nil);
+++	},
+++	designate: func (designate_contact) {
+++		if (designate_contact == nil) return;
+++		if (designate_contact.equals(me.priorityTarget)) {
+++			me.radar.setCurrentMode(me.subMode, designate_contact);
+++			me.subMode.radar = me.radar;# find some smarter way of setting it.
+++		} else {
+++			me.priorityTarget = designate_contact;
+++		}
+++	},
+++	designatePriority: func (contact) {
+++		me.priorityTarget = contact;
+++	},
+++	cycleBars: func {
+++		me.bars += 1;
+++		if (me.bars == 3) me.bars = 4;# 3 is only for TWS
+++		elsif (me.bars == 5) me.bars = 1;
+++		me.nextPatternNode = 0;
+++	},
+++	cycleAZ: func {
+++		if (me.azMFD == 10) me.azMFD = 30;
+++		elsif (me.azMFD == 30) me.azMFD = 60;
+++		elsif (me.azMFD == 60) me.azMFD = 10;
+++	},
+++	getAz: func {
+++		return me.azMFD;
+++	},
+++	increaseRange: func {# Range is auto-set in RWS-SAM
+++		return 0;
+++	},
+++	decreaseRange: func {# Range is auto-set in RWS-SAM
+++		return 0;
+++	},
+++	setRange: func {# Range is auto-set in RWS-SAM
+++	},
+++	leaveMode: func {
+++		me.priorityTarget = nil;
+++		me.lastFrameStart = -1;
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		if (me.priorityTarget != nil and contact.equals(me.priorityTarget)) {
+++			return [1,1,1,1,1,1];
+++		}
+++		return [1,0,1,0,0,1];
+++	},
+++	showRangeOptions: func {
+++		return 0;
+++	},
+++	showAZ: func {
+++		return 1;
+++	},
+++};
+++
+++
+++#  ██      ██████  ███████       ███████  █████  ███    ███ 
+++#  ██      ██   ██ ██            ██      ██   ██ ████  ████ 
+++#  ██      ██████  ███████ █████ ███████ ███████ ██ ████ ██ 
+++#  ██      ██   ██      ██            ██ ██   ██ ██  ██  ██ 
+++#  ███████ ██   ██ ███████       ███████ ██   ██ ██      ██ 
+++#                                                           
+++#
+++var F16LRSSAMMode = {
+++	shortName: "LRS",
+++	longName: "Long Range Search - Situational Awareness Mode",
+++	discSpeed_dps: 45,
+++	rcsFactor: 1,
+++	new: func (subMode = nil, radar = nil) {
+++		var mode = {parents: [F16LRSSAMMode, F16RWSSAMMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		if (subMode != nil) {
+++			subMode.superMode = mode;
+++			subMode.radar = radar;
+++			subMode.shortName = mode.shortName;
+++		}
+++		return mode;
+++	},
+++	showAZ: func {
+++		return 1;
+++	},
+++	calcSAMwidth: func {
+++		if (me.prioRange_nm<42) return math.min(60,18 + 1.4*me.prioRange_nm - 0.01*me.prioRange_nm*me.prioRange_nm);
+++		else return 60;
+++	},
+++};
+++
+++
+++
+++#   █████   ██████ ███    ███ 
+++#  ██   ██ ██      ████  ████ 
+++#  ███████ ██      ██ ████ ██ 
+++#  ██   ██ ██      ██  ██  ██ 
+++#  ██   ██  ██████ ██      ██ 
+++#                             
+++#
+++var F16ACMMode = {#TODO
+++	radar: nil,
+++	rootName: "ACM",
+++	shortName: "STBY",
+++	longName: "Air Combat Mode Standby",
+++	superMode: nil,
+++	subMode: nil,
+++	range: 10,
+++	maxRange: 10,
+++	discSpeed_dps: 84.6,# have reliable source for this.
+++	rcsFactor: 0.9,
+++	timeToFadeBleps: 1,
+++	bars: 1,
+++	az: 1,
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16ACMMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		mode.subMode.superMode = mode;
+++		mode.subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++	showBars: func {
+++		return 0;
+++	},
+++	showAZinHSD: func {
+++		return 0;
+++	},
+++	cycleAZ: func {	},
+++	cycleBars: func { },
+++	designate: func (designate_contact) {
+++	},
+++	designatePriority: func (contact) {
+++
+++	},
+++	getPriority: func {
+++		return nil;
+++	},
+++	undesignate: func {
+++	},
+++	preStep: func {
+++	},
+++	increaseRange: func {
+++		return 0;
+++	},
+++	decreaseRange: func {
+++		return 0;
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		return nil;
+++	},
+++	testContact: func (contact) {
+++	},
+++	cycleDesignate: func {
+++	},
+++};
+++
+++var F16ACM20Mode = {
+++	radar: nil,
+++	rootName: "ACM",
+++	shortName: "20",
+++	longName: "Air Combat Mode 30x20",
+++	superMode: nil,
+++	subMode: nil,
+++	range: 10,
+++	minRange: 10,
+++	maxRange: 10,
+++	discSpeed_dps: 84.6,
+++	rcsFactor: 0.9,
+++	timeToFadeBleps: 1,# TODO
+++	bars: 1,
+++	barPattern: [ [[1,-7],[1,3],[-1,3],[-1,1],[1,1],[1,-1],[-1,-1],[-1,-3],[1,-3],[1,-5],[-1,-5],[-1,-7]] ],
+++	az: 15,
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16ACM20Mode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		mode.subMode.superMode = mode;
+++		mode.subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++	showBars: func {
+++		return 0;
+++	},
+++	showAZinHSD: func {
+++		return 0;
+++	},
+++	cycleAZ: func {	},
+++	cycleBars: func { },
+++	designate: func (designate_contact) {
+++		if (designate_contact == nil) {
+++			acmLockSound.setBoolValue(0);
+++			return;
+++		}
+++		acmLockSound.setBoolValue(1);
+++		me.radar.setCurrentMode(me.subMode, designate_contact);
+++		me.subMode.radar = me.radar;
+++	},
+++	designatePriority: func (contact) {
+++	},
+++	getPriority: func {
+++		return nil;
+++	},
+++	undesignate: func {
+++	},
+++	preStep: func {
+++		me.radar.horizonStabilized = 0;
+++		me.elevationTilt = -3;
+++	},
+++	increaseRange: func {
+++		return 0;
+++	},
+++	decreaseRange: func {
+++		return 0;
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		me.designate(contact);
+++		return [1,1,1,1,1,1];
+++	},
+++	testContact: func (contact) {
+++	},
+++	cycleDesignate: func {
+++	},
+++	getCursorAltitudeLimits: func {
+++		return nil;
+++	},
+++};
+++
+++var F16ACM60Mode = {
+++	radar: nil,
+++	rootName: "ACM",
+++	shortName: "60",
+++	longName: "Air Combat Mode 10x60",
+++	superMode: nil,
+++	subMode: nil,
+++	maxRange: 10,
+++	discSpeed_dps: 84.6,
+++	rcsFactor: 0.9,
+++	bars: 1,
+++	barHeight: 1.0/APG68.instantFoVradius,# multiple of instantFoV (in this case 1 deg)
+++	az: 5,
+++	barPattern:  [ [[-0.6,-5],[0.0,-5],[0.0, 51],[0.6,51],[0.6,-5],[0.0,-5],[0.0,51],[-0.6,51]], ],
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16ACM60Mode, F16ACM20Mode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		mode.subMode.superMode = mode;
+++		mode.subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++	preStep: func {
+++		me.radar.horizonStabilized = 0;
+++		me.elevationTilt = 0;
+++	},
+++};
+++
+++var F16ACMBoreMode = {
+++	radar: nil,
+++	rootName: "ACM",
+++	shortName: "BORE",
+++	longName: "Air Combat Mode Bore",
+++	bars: 1,
+++	barHeight: 1.0,# multiple of instantFoV (in this case 1 deg)
+++	az: 0,
+++	barPattern:  [ [[0.0,-1]], ],
+++	new: func (subMode, radar = nil) {
+++		var mode = {parents: [F16ACMBoreMode, F16ACM20Mode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		mode.subMode = subMode;
+++		mode.subMode.superMode = mode;
+++		mode.subMode.shortName = mode.shortName;
+++		return mode;
+++	},
+++	preStep: func {
+++		me.radar.horizonStabilized = 0;
+++		me.elevationTilt = -me.radar.instantFoVradius;
+++		me.azimuthTilt = 0;
+++		if (getprop("payload/armament/hmd-active") == 1) {
+++			me.azimuthTilt = math.clamp(getprop("payload/armament/hmd-horiz-deg"),-60,60);
+++			me.elevationTilt = math.clamp(getprop("payload/armament/hmd-vert-deg"),-60,60);
+++		}
+++	},
+++	step: func (dt) {
+++		me.preStep();
+++		me.localDirHMD = vector.Math.pitchYawVector(me.elevationTilt, -me.azimuthTilt, [1,0,0]);
+++		me.angleToHMD = vector.Math.angleBetweenVectors(me.radar.positionDirection, me.localDirHMD);
+++		me.maxMove = math.min(me.angleToHMD, me.discSpeed_dps*dt);
+++		if (me.angleToHMD < 0.1) {
+++			me.radar.setAntennae(me.localDirHMD);
+++			me.lastFrameDuration = 0;
+++			return 0;
+++		}
+++		# Great circle movement to reach the bore spot
+++		me.newPos = vector.Math.rotateVectorTowardsVector(me.radar.positionDirection, me.localDirHMD, me.maxMove);
+++		me.radar.setAntennae(me.newPos);
+++		return dt-me.maxMove/me.discSpeed_dps;
+++	},
+++};
+++
+++
+++
+++
+++#  ███████ ████████ ████████ 
+++#  ██         ██       ██    
+++#  ███████    ██       ██ 
+++#       ██    ██       ██ 
+++#  ███████    ██       ██ 
+++#                         
+++#
+++var F16STTMode = {
+++	radar: nil,
+++	shortName: "STT",
+++	longName: "Single Target Track",
+++	superMode: nil,
+++	discSpeed_dps: 80,
+++	rcsFactor: 1,
+++	maxRange: 160,
+++	priorityTarget: nil,
+++	az: APG68.instantFoVradius*0.8,
+++	barHeight: 0.90,# multiple of instantFoVradius
+++	bars: 2,
+++	minimumTimePerReturn: 0.10,
+++	timeToFadeBleps: 13, # Need to have time to move disc to the selection from wherever it was before entering STT. Plus already faded bleps from superMode will get pruned if this is to low.
+++	debug: 1,
+++	painter: 1,
+++	debug: 0,
+++	new: func (radar = nil) {
+++		var mode = {parents: [F16STTMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		return mode;
+++	},
+++	showAZ: func {
+++		return 0;
+++	},
+++	showAZinHSD: func {
+++		return 0;
+++	},
+++	showBars: func {
+++		return me.superMode.showBars();
+++	},
+++	showRangeOptions: func {
+++		return 0;
+++	},
+++	getBars: func {
+++		return me.superMode.getBars();
+++	},
+++	getAz: func {
+++		# We return the parents mode AZ and bars in this class, so they are shown in radar display as B4 A4 etc etc.
+++		return me.superMode.getAz();
+++	},
+++	preStep: func {
+++		me.debug = getprop("debug-radar/debug-stt");
+++		if (me.priorityTarget != nil and size(me.priorityTarget.getBleps())) {
+++			me.lastBlep = me.priorityTarget.getLastBlep();
+++			if (me.debug > 0) {
+++				setprop("debug-radar/STT-bleps", size(me.priorityTarget.getBleps()));
+++			}
+++			if (me.lastBlep != nil) {
+++				me.azimuthTilt = me.lastBlep.getAZDeviation();
+++				me.elevationTilt = me.lastBlep.getElev(); # tilt here is in relation to horizon
+++			} else {
+++				me.priorityTarget = nil;
+++				me.undesignate();
+++				return;
+++			}
+++			if (!size(me.priorityTarget.getBleps()) or !me.radar.containsVectorContact(me.radar.vector_aicontacts_bleps, me.priorityTarget)) {
+++				me.priorityTarget = nil;
+++				me.undesignate();
+++				return;
+++			} elsif (me.azimuthTilt > me.radar.fieldOfRegardMaxAz-me.az) {
+++				me.azimuthTilt = me.radar.fieldOfRegardMaxAz-me.az;
+++			} elsif (me.azimuthTilt < -me.radar.fieldOfRegardMaxAz+me.az) {
+++				me.azimuthTilt = -me.radar.fieldOfRegardMaxAz+me.az;
+++			}
+++			if (me.priorityTarget.getRangeDirect()*M2NM < 0.40 * me.getRange()) {
+++				me._decreaseRange();
+++			}
+++			if (me.priorityTarget.getRangeDirect()*M2NM > 0.90 * me.getRange()) {
+++				me._increaseRange();
+++			}
+++			if (me.debug > 0) {
+++				setprop("debug-radar/STT-focused", me.priorityTarget.get_Callsign());
+++			}
+++		} else {
+++			if (me.debug > 0) {
+++				setprop("debug-radar/STT-focused", "--none--");
+++			}
+++			if (me.debug > 0) {
+++				setprop("debug-radar/STT-bleps", -1);
+++			}
+++			me.priorityTarget = nil;
+++			me.undesignate();
+++		}
+++	},
+++	designatePriority: func (prio) {
+++		me.priorityTarget = prio;
+++	},
+++	undesignate: func {
+++		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
+++		me.priorityTarget = nil;
+++		#var log = caller(1); foreach (l;log) print(l);
+++	},
+++	designate: func {},
+++	cycleBars: func {},
+++	cycleAZ: func {},
+++	increaseRange: func {# Range is auto-set in STT
+++		return 0;
+++	},
+++	decreaseRange: func {# Range is auto-set in STT
+++		return 0;
+++	},
+++	setRange: func {# Range is auto-set in STT
+++	},
+++	frameCompleted: func {
+++		if (me.lastFrameStart != -1) {
+++			me.lastFrameDuration = me.radar.elapsed - me.lastFrameStart;
+++			#me.timeToFadeBleps = math.max(2, me.radar.targetHistory*me.lastFrameDuration);
+++		}
+++		me.lastFrameStart = me.radar.elapsed;
+++	},
+++	leaveMode: func {
+++		me.priorityTarget = nil;
+++		me.lastFrameStart = -1;
+++		me.timeToFadeBleps = 13;# Reset to 5, since getSearchInfo might have lowered it.
+++	},
+++	getSearchInfo: func (contact) {
+++		# searchInfo:               dist, groundtrack, deviations, speed, closing-rate, altitude
+++		if (me.priorityTarget != nil and contact.equals(me.priorityTarget)) {
+++			me.timeToFadeBleps = 1.5;
+++			return [1,1,1,1,1,1];
+++		}
+++		return nil;
+++	},
+++	getCursorAltitudeLimits: func {
+++		return nil;
+++	},
+++};
+++
+++var F16ACMSTTMode = {
+++	rootName: "ACM",
+++	shortName: "STT",
+++	longName: "Air Combat Mode - Single Target Track",
+++	new: func (radar = nil) {
+++		var mode = {parents: [F16ACMSTTMode, F16STTMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		return mode;
+++	},
+++	designatePriority: func (prio) {
+++		me.priorityTarget = prio;
+++		if (prio != nil) acmLockSound.setBoolValue(1);
+++	},
+++	undesignate: func {
+++		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
+++		me.priorityTarget = nil;
+++		acmLockSound.setBoolValue(0);
+++	},
+++};
+++
+++var F16MultiSTTMode = {
+++	rootName: "CRM",
+++	shortName: "STT",
+++	longName: "Multisearch - Single Target Track",
+++	new: func (radar = nil) {
+++		var mode = {parents: [F16MultiSTTMode, F16STTMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		return mode;
+++	},
+++	undesignate: func {
+++		if (me.priorityTarget != nil and me.priorityTarget.getRangeDirect()*M2NM < 3) {
+++			me.priorityTarget = nil;
+++		}
+++		me.radar.setCurrentMode(me.superMode, me.priorityTarget);
+++		me.priorityTarget = nil;
+++		#var log = caller(1); foreach (l;log) print(l);
+++	},
+++};
+++
+++
+++#  ███████ ████████ ████████ 
+++#  ██         ██       ██    
+++#  █████      ██       ██ 
+++#  ██         ██       ██ 
+++#  ██         ██       ██ 
+++#                         
+++#
+++var F16SEAFTTMode = {
+++	rootName: "",
+++	shortName: "FTT",
+++	longName: "SEA Mode - Fixed Target Track",
+++	maxRange: 80,
+++	detectAIR: 0,
+++	detectSURFACE: 0,
+++	detectMARINE: 1,
+++	pulse: MONO,
+++	minimumTimePerReturn: 0.20,
+++	new: func (radar = nil) {
+++		var mode = {parents: [F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		return mode;
+++	},
+++};
+++
+++var F16GMFTTMode = {
+++	longName: "Ground Map Mode - Fixed Target Track",
+++	detectSURFACE: 1,
+++	detectMARINE: 0,
+++	mapper: 1,
+++	new: func (radar = nil) {
+++		var mode = {parents: [F16GMFTTMode, F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		return mode;
+++	},
+++	getPriority: func {
+++		if (me.priorityTarget == nil or (rand() > 0.95 and me.priorityTarget.getSpeed() < 11)) {
+++			return me.priorityTarget;
+++		} else {
+++			return me.priorityTarget.getNearbyVirtualContact(60);
+++		}
+++	},
+++};
+++
+++var F16GMTFTTMode = {
+++	longName: "Ground Moving Target - Fixed Target Track",
+++	detectSURFACE: 1,
+++	detectMARINE: 0,
+++	new: func (radar = nil) {
+++		var mode = {parents: [F16GMTFTTMode, F16SEAFTTMode, F16STTMode, APG68Mode, RadarMode]};
+++		mode.radar = radar;
+++		return mode;
+++	},
+++};
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++#  ███████        ██  ██████      ██████  ██     ██ ██████ 
+++#  ██            ███ ██           ██   ██ ██     ██ ██   ██ 
+++#  █████   █████  ██ ███████      ██████  ██  █  ██ ██████  
+++#  ██             ██ ██    ██     ██   ██ ██ ███ ██ ██   ██ 
+++#  ██             ██  ██████      ██   ██  ███ ███  ██   ██ 
+++#                                                           
+++#
+++
+++var noRadarList = {
+++	# These have no radar
+++	depot:nil, point:nil, struct:nil, rig:nil, truck:nil, hunter:nil,
+++	"alphajet":nil, "jaguar":nil, "Jaguar-GR3":nil, "A-10-modelB":nil, "Jaguar-GR1":nil, "A-10-model":nil, "A-10":nil, "G91-R1B":nil, "G91":nil, "g91":nil, "mb339":nil, "mb339pan":nil,
+++};
+++
+++var RWR = {
+++	# inherits from Radar
+++	# will check radar/transponder and ground occlusion.
+++	# will sort according to threat level
+++	new: func () {
+++		var rr = {parents: [RWR, Radar]};
+++
+++		rr.vector_aicontacts = [];
+++		rr.vector_aicontacts_threats = [];
+++		#rr.timer          = maketimer(2, rr, func rr.scan());
+++
+++		rr.RWRRecipient = emesary.Recipient.new("RWRRecipient");
+++		rr.RWRRecipient.radar = rr;
+++		rr.RWRRecipient.Receive = func(notification) {
+++	        if (notification.NotificationType == "OmniNotification") {
+++	        	#printf("RWR recv: %s", notification.NotificationType);
+++	            if (me.radar.enabled == 1) {
+++	    		    me.radar.vector_aicontacts = notification.vector;
+++	    		    me.radar.scan();
+++	    	    }
+++	            return emesary.Transmitter.ReceiptStatus_OK;
+++	        }
+++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+++	    };
+++		emesary.GlobalTransmitter.Register(rr.RWRRecipient);
+++		rr.RWRNotification = VectorNotification.new("RWRNotification");
+++		rr.RWRNotification.updateV(rr.vector_aicontacts_threats);
+++		#rr.timer.start();
+++		return rr;
+++	},
+++	heatDefense: 0,
+++	scan: func {
+++		# sort in threat?
+++		# run by notification
+++		# mock up code, ultra simple threat index, is just here cause rwr have special needs:
+++		# 1) It has almost no range restriction
+++		# 2) Its omnidirectional
+++		# 3) It might have to update fast (like 0.25 secs)
+++		# 4) To build a proper threat index it needs at least these properties read:
+++		#       model type
+++		#       class (AIR/SURFACE/MARINE)
+++		#       lock on myself
+++		#       missile launch
+++		#       transponder on/off
+++		#       bearing and heading
+++		#       IFF info
+++		#       ECM
+++		#       radar on/off
+++		if (!getprop("instrumentation/rwr/serviceable") or getprop("f16/avionics/power-ufc-warm") != 1 or getprop("f16/ews/ew-rwr-switch") != 1) {
+++            setprop("sound/rwr-lck", 0);
+++            setprop("ai/submodels/submodel[0]/flare-auto-release-cmd", 0);
+++            return;
+++        }
+++        me.vector_aicontacts_threats = [];
+++		me.fct = 10*2.0;
+++        me.myCallsign = self.getCallsign();
+++        me.myCallsign = size(me.myCallsign) < 8 ? me.myCallsign : left(me.myCallsign,7);
+++        me.act_lck = 0;
+++        me.autoFlare = 0;
+++        me.closestThreat = 0;
+++        me.elapsed = elapsedProp.getValue();
+++        foreach(me.u ; me.vector_aicontacts) {
+++        	# [me.ber,me.head,contact.getCoord(),me.tp,me.radar,contact.getDeviationHeading(),contact.getRangeDirect()*M2NM, contact.getCallsign()]
+++        	me.threatDB = me.u.getThreatStored();
+++            me.cs = me.threatDB[7];
+++            me.rn = me.threatDB[6];
+++            if ((me.u["blue"] != nil and me.u.blue == 1 and !me.threatDB[10]) or me.rn > 150) {
+++                continue;
+++            }
+++            me.bearing = me.threatDB[0];
+++            me.trAct = me.threatDB[3];
+++            me.show = 1;
+++            me.heading = me.threatDB[1];
+++            me.inv_bearing =  me.bearing+180;#bearing from target to me
+++            me.deviation = me.inv_bearing - me.heading;# bearing deviation from target to me
+++            me.dev = math.abs(geo.normdeg180(me.deviation));# my degrees from opponents nose
+++
+++            if (me.show == 1) {
+++                if (me.dev < 30 and me.rn < 7 and me.threatDB[8] > 60) {
+++                    # he is in position to fire heatseeker at me
+++                    me.heatDefenseNow = me.elapsed + me.rn*1.5;
+++                    if (me.heatDefenseNow > me.heatDefense) {
+++                        me.heatDefense = me.heatDefenseNow;
+++                    }
+++                }
+++                me.threat = 0;
+++                if (me.u.getModel() != "missile_frigate" and me.u.getModel() != "S-75" and me.u.getModel() != "SA-6" and me.u.getModel() != "buk-m2" and me.u.getModel() != "MIM104D" and me.u.getModel() != "s-200" and me.u.getModel() != "s-300" and me.u.getModel() != "fleet" and me.u.getModel() != "ZSU-23-4M") {
+++                    me.threat += ((180-me.dev)/180)*0.30;# most threat if I am in front of his nose
+++                    me.spd = (60-me.threatDB[8])/60;
+++                    #me.threat -= me.spd>0?me.spd:0;# if his speed is lower than 60kt then give him minus threat else positive
+++                } elsif (me.u.getModel() == "missile_frigate" or me.u.getModel() == "fleet") {
+++                    me.threat += 0.30;
+++                } else {
+++                    me.threat += 0.30;
+++                }
+++                me.danger = 50;# within this range he is most dangerous
+++                if (me.u.getModel() == "missile_frigate" or me.u.getModel() == "fleet" or me.u.getModel() == "s-300") {
+++                    me.danger = 80;
+++                } elsif (me.u.getModel() == "buk-m2" or me.u.getModel() == "S-75") {
+++                    me.danger = 35;
+++                } elsif (me.u.getModel() == "SA-6") {
+++                    me.danger = 15;
+++                } elsif (me.u.getModel() == "s-200") {
+++                    me.danger = 150;
+++                } elsif (me.u.getModel() == "MIM104D") {
+++                    me.danger = 45;
+++                } elsif (me.u.getModel() == "ZSU-23-4M") {
+++                    me.danger = 7.5;
+++                }
+++                if (me.threatDB[10]) me.threat += 0.30;# has me locked
+++                me.threat += ((me.danger-me.rn)/me.danger)>0?((me.danger-me.rn)/me.danger)*0.60:0;# if inside danger zone then add threat, the closer the more.
+++                me.threat += me.threatDB[9]>0?(me.threatDB[9]/500)*0.10:0;# more closing speed means more threat.
+++                if (me.u.getModel() == "AI") me.threat = 0.01;
+++                if (contains(noRadarList, me.u.getModel())) me.threat = - 1;
+++                if (me.threat > me.closestThreat) me.closestThreat = me.threat;
+++                #printf("A %s threat:%.2f range:%d dev:%d", me.u.get_Callsign(),me.threat,me.u.get_range(),me.deviation);
+++                if (me.threat > 1) me.threat = 1;
+++                if (me.threat <= 0) continue;
+++                #printf("B %s threat:%.2f range:%d dev:%d", me.u.get_Callsign(),me.threat,me.u.get_range(),me.deviation);
+++                append(me.vector_aicontacts_threats,[me.u,me.threat, me.threatDB[5]]);
+++            } else {
+++#                printf("%s ----", me.u.get_Callsign());
+++            }
+++        }
+++
+++        me.launchClose = getprop("payload/armament/MLW-launcher") != "";
+++        me.incoming = getprop("payload/armament/MAW-active") or getprop("payload/armament/MAW-semiactive") or me.heatDefense > me.elapsed;
+++        me.spike = 0;#getprop("payload/armament/spike")*(getprop("ai/submodels/submodel[0]/count")>15);
+++        me.autoFlare = me.spike?math.max(me.closestThreat*0.25,0.05):0;
+++
+++        if (0 and getprop("f16/ews/ew-mode-knob") == 2)
+++        	print("wow: ", getprop("/fdm/jsbsim/gear/unit[0]/WOW"),"  spiked: ",me.spike,"  incoming: ",me.incoming, "  launch: ",me.launchClose,"  spikeResult:", me.autoFlare,"  aggresive:",me.launchClose * 0.85 + me.incoming * 0.85,"  total:",me.launchClose * 0.85 + me.incoming * 0.85+me.autoFlare);
+++
+++        me.autoFlare += me.launchClose * 0.85 + me.incoming * 0.85;
+++
+++        me.autoFlare *= 0.1 * 2.5 * !getprop("/fdm/jsbsim/gear/unit[0]/WOW");#0.1 being the update rate for flare dropping code.
+++
+++        setprop("ai/submodels/submodel[0]/flare-auto-release-cmd", me.autoFlare * (getprop("ai/submodels/submodel[0]/count")>0));
+++        if (me.autoFlare > 0.80 and rand()>0.99 and getprop("ai/submodels/submodel[0]/count") < 1) {
+++            setprop("ai/submodels/submodel[0]/flare-release-out-snd", 1);
+++        }
+++        emesary.GlobalTransmitter.NotifyAll(me.RWRNotification.updateV(me.vector_aicontacts_threats));
+++	},
+++	del: func {
+++        emesary.GlobalTransmitter.DeRegister(me.RWRRecipient);
+++    },
+++};
+++
+++
+++
+++var radiation_list = {
+++	"buk-m2": "11",
+++    "s-300": "20",
+++    "s-200": "5",
+++    "S-75": "2",
+++    "missile_frigate": "SH",
+++    "fleet": "SH",
+++    "SA-6": "6",
+++    "MIM104D": "P",
+++    "ZSU-23-4M": "AAA",
+++    "gci": "S",
+++    "A-50": "S",
+++    "EC-137R": "S",
+++    "E-3": "S",
+++    "E-3R": "S",
+++};
+++
+++var RadSensor = {
+++	# inherits from Radar
+++	new: func () {
+++		var rs = {parents: [RadSensor, Radar]};
+++
+++		rs.vector_aicontacts = [];
+++		rs.vector_aicontacts_seen = [];
+++
+++		rs.RadSensorRecipient = emesary.Recipient.new("RadSensorRecipient");
+++		rs.RadSensorRecipient.radar = rs;
+++		rs.RadSensorRecipient.Receive = func(notification) {
+++	        if (notification.NotificationType == "OmniNotification") {
+++	        	#printf("RadSensor recv: %s", notification.NotificationType);
+++	            if (me.radar.enabled == 1) {
+++	    		    me.radar.vector_aicontacts = notification.vector;
+++	    	    }
+++	            return emesary.Transmitter.ReceiptStatus_OK;
+++	        }
+++	        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+++	    };
+++		emesary.GlobalTransmitter.Register(rs.RadSensorRecipient);
+++		rs.timer          = maketimer(0.05, rs, func rs.scan());
+++		rs.timer.singleShot = 1;
+++		rs.enabled = 0;
+++		return rs;
+++	},
+++	range: 40,
+++	area: 10,
+++	maxArea: 20,
+++	maxDura: 90,
+++	dura: 60,
+++	searchTime: 0,
+++	searchStart: 0,
+++	index: -1,
+++	timing: 0.05,
+++	table: [],
+++    tables: [["2","11","20","P","S"],["6","5"],["AAA","SH"]],
+++	currtable: 0,
+++	handoffTarget: nil,
+++	handoffTime: 0,
+++	searchCounter: 0,
+++	x: [-40, 40],
+++	y: [-40, 10],
+++	fov: 0,
+++	fov_desired: 0,
+++	setEnabled: func (e) {
+++		me.enabled = e;
+++		if (e and !me.timer.isRunning) {
+++			me.calcDura();
+++        	me.timing = 0.05;
+++        	me.timer.restart(me.timing);
+++			me.timer.start();
+++			me.searchStart = elapsedProp.getValue();
+++
+++			#print("setEnabled again");
+++		} elsif (!e) {
+++			me.timer.stop();
+++			me.reset();
+++		}
+++	},
+++	reset: func {
+++		me.searchTime = 0;
+++		me.searchStart = elapsedProp.getValue();
+++		foreach(me.seen;me.vector_aicontacts_seen) {
+++    		me.seen.discover = 0;
+++    		me.seen.discoverSCT = -2;
+++    	}
+++		me.vector_aicontacts_seen = [];
+++		me.calcDura();
+++    	me.timing = 0.05;
+++	},
+++	calcDura: func {
+++		me.dura = me.maxDura * me.area/me.maxArea * size(me.table)/5;
+++	},
+++	scan: func {
+++		if (!me.enabled) {
+++			foreach(me.seen;me.vector_aicontacts_seen) {
+++        		me.seen.discover = 0;
+++        		me.seen.discoverSCT = -2;
+++        	}
+++            me.vector_aicontacts_seen = [];
+++            return;
+++        }
+++        me.elapsed = elapsedProp.getValue();
+++
+++        me.searchTime = me.elapsed-me.searchStart;
+++        if (me.searchTime > me.dura) {
+++        	me.index = -1;
+++        	me.searchStart = me.elapsed;
+++        	me.searchCounter += 1;
+++        	me.searchTime = 0;
+++        	#print("finished search");
+++        }
+++
+++        if (me.index >= size(me.vector_aicontacts)-1) {
+++        	me.index = -1;
+++        }
+++        if (!size(me.vector_aicontacts)) {
+++        	foreach(me.seen;me.vector_aicontacts_seen) {
+++        		me.seen.discover = 0;
+++        		me.seen.discoverSCT = -2;
+++        	}
+++        	me.vector_aicontacts_seen = [];
+++        	me.timer.restart(me.timing);
+++	        if (!me.timer.isRunning) {
+++	        	me.timer.start();
+++	        }
+++        	return;
+++        }
+++        me.index += 1;
+++
+++        me.candidate = me.vector_aicontacts[me.index];
+++        #print(size(me.vector_aicontacts)," me.candidate.rd is nil: ",me.candidate["isRadiating"]==nil);
+++        me.candidateModel = me.candidate.getModel();
+++        if (contains(radiation_list, me.candidateModel)) {
+++	        me.ownCoord = self.getCoord();
+++	        me.myHeading = radar_system.self.getHeading();
+++	        me.ok = 0;
+++	        if (me.candidate.isRadiating(me.ownCoord)) {
+++	        	me.testBearing = me.candidate.getBearing();
+++	            me.testElevation = me.candidate.getElevation();
+++	            me.testDev = geo.normdeg180(me.testBearing-me.myHeading);
+++	            if (me.testDev > me.x[0] and me.testDev < me.x[1] and me.candidate.get_range() < me.range) {
+++		            if (me.testElevation < me.y[1] and me.testElevation > me.y[0]) {
+++	    	            me.candidate.radiSpike = me.candidate.isSpikingMe()?"T":"A";
+++	    	            me.candidate.pos = [me.testDev, me.testElevation];
+++	    	            me.candidate.mdl = radiation_list[me.candidateModel];
+++
+++	                    for (me.i = 0; me.i < size(me.table);me.i+=1) {
+++	                        me.tableitem = me.table[me.i];
+++	                        if (me.candidate.mdl == me.tableitem) {
+++	                            me.ok = 1;
+++	                            me.candidate.tblIdx = me.i;
+++	                            if (me.candidate["discoverSCT"] != me.searchCounter) {# If we have seen this contact before in this cycle we don't recalc its discover time
+++	                            	me.candidate.discover = me.dura*rand();
+++	                            	me.candidate.discoverSCT = me.searchCounter;
+++	                            }
+++	                            break;
+++	                        }
+++	                    }
+++	                    if (me.ok) {
+++	                    	if (!me.containsVector(me.vector_aicontacts_seen, me.candidate)) {
+++	                    		append(me.vector_aicontacts_seen, me.candidate);
+++	                    		#print("Sensor: seen ",me.candidate.mdl,", planning reveal at ",int(me.dura-me.candidate.discover));
+++	                    	}
+++	                    }
+++	    	        }
+++	            }
+++	        }
+++	        if (!me.ok and me.containsVector(me.vector_aicontacts_seen, me.candidate)) {
+++	        	#print("Sensor: unseen ",me.candidate.mdl);
+++	        	me.temp = [];
+++	        	foreach(me.seen;me.vector_aicontacts_seen) {
+++	        		if (me.seen == me.candidate) continue;
+++	        		append(me.temp,me.seen);
+++	        	}
+++	        	me.vector_aicontacts_seen = me.temp;
+++	        }
+++	    }
+++        me.calcDura();
+++        me.timing = 2/size(me.vector_aicontacts);# Expect there to be 1 to 100 contacts. The last ones in the vector should also be able to show up in the first seconds.
+++        me.timing = math.clamp(me.timing, 0.01, 0.15);
+++        #printf("dura %.3f  size %d  sleep %.3f",me.dura,size(me.vector_aicontacts),0.95*me.dura/size(me.vector_aicontacts));
+++        me.timer.restart(me.timing);
+++        if (!me.timer.isRunning) {
+++        	me.timer.start();
+++        }
+++	},
+++	containsVector: func (vec, item) {
+++		foreach(test; vec) {
+++			if (test == item) {
+++				return 1;
+++			}
+++		}
+++		return 0;
+++	},
+++	del: func {
+++        emesary.GlobalTransmitter.DeRegister(me.RadSensorRecipient);
+++    },
+++};
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++#   ██████  ██████   ██████  ██    ██ ███    ██ ██████      ███    ███  █████  ██████  ██████  ███████ ██████
+++#  ██       ██   ██ ██    ██ ██    ██ ████   ██ ██   ██     ████  ████ ██   ██ ██   ██ ██   ██ ██      ██   ██
+++#  ██   ███ ██████  ██    ██ ██    ██ ██ ██  ██ ██   ██     ██ ████ ██ ███████ ██████  ██████  █████   ██████
+++#  ██    ██ ██   ██ ██    ██ ██    ██ ██  ██ ██ ██   ██     ██  ██  ██ ██   ██ ██      ██      ██      ██   ██
+++#   ██████  ██   ██  ██████   ██████  ██   ████ ██████      ██      ██ ██   ██ ██      ██      ███████ ██   ██
+++#
+++#
+++var TerrainMapper = {
+++	new: func (radar, rate) {
+++		var tm = {parents: [TerrainMapper, Radar]};
+++		tm.radar = radar;
+++		tm.timer = maketimer(rate, tm, func tm.loop());
+++		tm.timer.start();
+++		radar.installMapper(tm);
+++		tm.lowestElev = 0;
+++		tm.highestElev = 5000;
+++		tm.minElev = 35000;
+++		tm.maxElev = 0;
+++		tm.cleaned = 0;
+++		tm.exp = 0;
+++		tm.debug = 0;
+++		tm.t_geo = 0;
+++		tm.t_pix = 0;
+++		return tm;
+++	},
+++	##################################################################################################
+++	##################################################################################################
+++	#
+++	# TODO:
+++	#   Remove image painting from this class
+++	#   EXP mode
+++	#   Optimize
+++	#   Find reason for failing Coord._lat
+++	#   Pixel rounding error review (fills too few x)
+++	#
+++	azData: {
+++				radius: nil,
+++				az: 0,
+++				fromDist: nil,
+++				toDist: nil,
+++				domainNm: nil,
+++				domainFwdNm: nil,
+++				rangeFwdNm: nil,
+++				returns: nil,
+++			},
+++	scanGM: func (eulerX, eulerY, verticalInstantFoV, horizontalInstantFoV, bottomBar, topBar) {
+++		# GM test code
+++
+++		if (me.radar.currentMode.mapper and me.enabled and me.radar.horizonStabilized and me["gmPic"] != nil and !me.exp) {
+++			if (me.debug > 3) {
+++				me.t0 = systime();
+++			}
+++			me.debug = getprop("debug-radar/debug-mapper");
+++			me.mapperHeading = eulerX+self.getHeading();
+++			me.discDirforGMTop = vector.Math.pitchYawVector(eulerY+verticalInstantFoV,-me.mapperHeading,[1,0,0]);
+++			me.discDirforGMBot = vector.Math.pitchYawVector(eulerY-verticalInstantFoV,-me.mapperHeading,[1,0,0]);
+++			if (me.debug) {
+++				setprop("debug-radar/mapper-pitch-high", eulerY+verticalInstantFoV);
+++				setprop("debug-radar/mapper-pitch", eulerY);
+++				setprop("debug-radar/mapper-pitch-low", eulerY-verticalInstantFoV);
+++			}
+++
+++			me.selfCoord = self.getCoord();
+++
+++			me.radarBeamGeoVectorTop = vector.Math.vectorToGeoVector(me.discDirforGMTop, me.selfCoord);
+++			me.radarBeamGeoVectorBot = vector.Math.vectorToGeoVector(me.discDirforGMBot, me.selfCoord);
+++
+++			me.xyzSelf = {"x":me.selfCoord.x(), "y":me.selfCoord.y(), "z":me.selfCoord.z()};
+++
+++            # Check for terrain at top and bottom of radar instant FoV
+++            me.terrainGeodTop = get_cart_ground_intersection(me.xyzSelf, me.radarBeamGeoVectorTop);
+++            me.terrainGeodBot = get_cart_ground_intersection(me.xyzSelf, me.radarBeamGeoVectorBot);
+++            #if (me.debug) {
+++			#	setprop("debug-radar/mapper-last-deg", math.abs(eulerX-me.azData.az));
+++			#}
+++            me.azData.az = eulerX;
+++            me.azData.radius = horizontalInstantFoV;
+++            me.azData.returns = [];
+++            if (me.terrainGeodBot != nil) {
+++            	me.terrainCoordBot = geo.Coord.new().set_latlon(me.terrainGeodBot.lat, me.terrainGeodBot.lon, me.terrainGeodBot.elevation);
+++            	me.azData.fromDist = me.selfCoord.distance_to(me.terrainCoordBot)*M2NM;
+++            	if (!me.testRange(me.azData.fromDist, me.radar.getRange(), me.azData.az)) return;
+++            	if (me.terrainGeodTop != nil) {
+++            		me.terrainCoordTop = geo.Coord.new().set_latlon(me.terrainGeodTop.lat, me.terrainGeodTop.lon, me.terrainGeodTop.elevation);
+++            		if (me.debug) {
+++						setprop("debug-radar/mapper-domain-lost-nm", "works");
+++					}
+++            	} else {
+++            		# The upper part of this instantFoV does not hit terrain here. So we manually add a little bit.
+++            		me.terrainCoordTop = geo.Coord.new(me.terrainCoordBot);
+++            		if (me.azData.domainNm != nil) {
+++            			me.topRange = me.azData.domainNm;
+++            		} else {
+++            			me.topRange = me.radar.getRange() * 1.25 - me.azData.fromDist;
+++            		}
+++            		me.topRange = math.max(me.topRange, 15);
+++            		if (me.debug) {
+++						setprop("debug-radar/mapper-domain-lost-nm", me.topRange);
+++					}
+++            		me.terrainCoordTop.apply_course_distance(me.mapperHeading, me.topRange*NM2M);
+++            	}
+++            	me.azData.toDist = me.selfCoord.distance_to(me.terrainCoordTop)*M2NM;
+++            	me.azData.domainNm = me.azData.toDist-me.azData.fromDist;
+++            	me.azCos = math.cos(me.azData.az*D2R);
+++            	me.azData.rangeFwdNm = me.azData.fromDist*me.azCos;
+++            	me.azData.domainFwdNm = me.azData.domainNm*me.azCos;
+++            	me.pixelsBetweenTopAndBot = math.ceil(me.gmPicSize*me.azData.domainFwdNm/me.radar.getRange());
+++				me.maskAlt  = 0;
+++				me.maskStep = -1;
+++
+++				# Amount each step changes in altitude meters for center of beam.
+++				# Curvature of earth is negliable.
+++				# Each steps has different angle in reality, but its minute.
+++				me.maskAltPerStep = math.tan(eulerY*D2R)*NM2M*me.azData.domainNm/me.pixelsBetweenTopAndBot;
+++
+++            	for (var i = 0; i <= me.pixelsBetweenTopAndBot; i += 1) {
+++            		me.testCoord = me.interpolateCoords(me.terrainCoordBot, me.terrainCoordTop, i/me.pixelsBetweenTopAndBot);
+++            		me.gm_geod = geodinfo(me.testCoord.lat(), me.testCoord.lon(), 10000);
+++            		if (debug.isnan(me.testCoord._lat)) {
+++            			#print("self ",me.selfCoord._lat);
+++            			print("test ",me.testCoord._lat," , ",me.testCoord.lat()," , ",me.testCoord.alt());
+++            			#print("bot  ",me.terrainCoordBot._x," , ",me.terrainCoordBot._y," , ",me.terrainCoordBot._z,"  ,  ",me.terrainGeodBot.elevation*M2FT);
+++            			#print(i);
+++            			append(me.azData.returns, 0);
+++            			continue;
+++            		}
+++            		me.gmReturn = 0;
+++            		if (me.gm_geod != nil) {
+++            			if (me.gm_geod[0] > me.maskAlt+(i - me.maskStep)*me.maskAltPerStep) {
+++            				# Terrain not masked by previous terrain
+++            				me.maskAlt = me.gm_geod[0];
+++            				me.maskStep = i;
+++            				me.gmReturn = me.backScatter(me.gm_geod);
+++            			} else {
+++            				me.gmReturn = -1;
+++            			}
+++            		} else {
+++            			me.gmReturn = -2;
+++            		}
+++            		append(me.azData.returns, me.gmReturn);
+++            	}
+++            	#me.debugOutput();
+++            	if (me.debug > 3) {
+++            		me.t1 = systime();
+++            	}
+++            	me.paintImage(me.azData, bottomBar, topBar);
+++            	if (me.debug > 3) {
+++	            	me.t2 = systime();
+++	            	me.t_geo += me.t1-me.t0;
+++	            	me.t_pix += me.t2-me.t1;
+++	            }
+++            }
+++            if (me.dirty) {
+++            	me.gmPic.dirtyPixels();
+++            	me.dirty = 0;
+++            }
+++		}
+++	},
+++	setImage: func (image, origin_x, origin_y, dimension, monochrome, gainNode) {
+++		if (me["gmPic"] == nil) {
+++			#me.canvas = canvas.Window.new([512,512],"dialog").set('title',"GM").getCanvas(1);
+++			#me.canvas_root = me.canvas.createGroup();
+++			#me.canvas.setColorBackground(0,0,0,1);
+++			me.gainNode = gainNode;
+++			me.gmPic = image;
+++            me.dirty = 0;
+++            me.gmPicSize  = dimension;
+++            me.mono = monochrome;
+++            me.gm_x_origin = origin_x;
+++            me.gm_y_origin = origin_y;
+++            #me.gmPic.setPixel(me.gm_x_origin, me.gm_y_origin, [0,0,1,1]);#blue pixel at ownship
+++            return 1;
+++		} else {
+++			return 0;
+++		}
+++	},
+++	paintImage: func (azData, bottomBar, topBar) {
+++
+++		me.iStart = math.floor(me.gmPicSize*azData.rangeFwdNm/me.radar.getRange());
+++
+++		if (me.debug) {
+++			setprop("debug-radar/mapper-steps", size(azData.returns));
+++			setprop("debug-radar/mapper-domain-fwd-nm", azData.domainFwdNm);
+++		}
+++
+++		# If top or bottom or only 1 bar, pad ahead/behind with nil. This will clear old returns on screen.
+++		if (bottomBar and me.iStart > 0) {
+++			azData.returns = setsize([], me.iStart) ~ azData.returns;
+++			me.iStart = 0;
+++		}
+++		me.behindPad = (int)((1-me.azData.rangeFwdNm/me.radar.getRange())*me.gmPicSize*1.3);
+++		if (topBar and me.behindPad > 0) {
+++			azData.returns = azData.returns ~ setsize([], me.behindPad);
+++		}
+++
+++		me.jStart = math.tan((azData.az-azData.radius)*D2R);
+++		me.jMid   = math.tan(azData.az*D2R);
+++		me.jEnd   = math.tan((azData.az+azData.radius)*D2R);
+++		me.jFactor = me.jEnd-me.jStart;
+++
+++		#me.firstY = 0;
+++		#me.firstX = 0;
+++
+++		for (var i = 0; i < size(azData.returns); i+=1 ) {
+++			me.debugColor = nil;
+++			if (me.debug > 2) {
+++				if (azData.returns[i] == nil) {
+++					me.debugColor = [0,0,1,1];# Blue for not hit by FoV
+++				} elsif (azData.returns[i] == -1) {
+++					me.debugColor = [1,1,0,1];# Yellow for terrain masked
+++				} elsif (azData.returns[i] == -2) {
+++					me.debugColor = [1,0,0,1];# Red for terrasunk
+++				} else {
+++					me.gmColor = math.pow(math.clamp(azData.returns[i],0,1), me.gainNode.getValue());
+++				}
+++			} else {
+++				me.gmColor = azData.returns[i]==nil?0:math.pow(math.clamp(azData.returns[i],0,1), me.gainNode.getValue());
+++			}
+++
+++			me.gmY  = me.gm_y_origin+me.iStart+i;
+++			me.gmX  = math.floor(me.gm_x_origin+me.jMid*(i+me.iStart));
+++			me.gmX0 = me.gm_x_origin+me.jStart*(i+me.iStart);
+++			me.gmXj = math.round(me.gmX0+(i+me.iStart)*me.jFactor-0.5);
+++			me.gmX0 = math.min(me.gmX, math.round(me.gmX0));
+++			#if (me.firstY == 0) {
+++			#	me.firstY = math.max(me.gmY, 0)-me.gm_y_origin;
+++			#	me.firstX = me.gmXj;
+++			#}
+++			for (var j = me.gmX0; j <= me.gmXj; j += 1) {
+++				if (j >= 0 and j <= me.gmPicSize-1 and me.gmY <= me.gmPicSize-1) {
+++					me.gmPic.setPixel(j, math.max(me.gmY, 0), me.debugColor==nil?[me.gmColor*me.mono,me.gmColor,me.gmColor*me.mono,1]:me.debugColor);
+++					me.dirty = 1;
+++				}
+++			}
+++		}
+++		#if (bottomBar and me.firstY != 0) {
+++		#	# Clear the field below the bottom bar as we might have risen in alitude so its old data shown closer to ownship that can confuse pilot.
+++		#	for (var y = me.firstY-1; y >= 0; y-=1 ) {
+++		#		#var x = math.clamp(me.gm_x_origin + (y/me.firstY) * me.firstX, 0, 63);
+++		#		if (me.firstX > 31)    {me.gmPic.setPixel(me.firstX,   y, [0,0,0,1]);me.gmPic.setPixel(me.firstX-1, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX-2, y, [0,0,0,1]);}
+++		#		elsif (me.firstX < 31) {me.gmPic.setPixel(me.firstX+1, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX+2, y, [0,0,0,1]);me.gmPic.setPixel(me.firstX+3, y, [0,0,0,1]);}
+++		#		else                    me.gmPic.setPixel(me.firstX,   y, [0,0,0,1]);
+++		#	}
+++		#}
+++	},
+++	expChanged: func (exp) {
+++		if (me["gmPic"] == nil or exp == me.exp) return;
+++		me.exp = exp;
+++		if (me.exp) {
+++			me.gmPic.fillRect([0,0,me.gmPicSize,me.gmPicSize], [0.0*me.mono,0.0,0.0*me.mono,0]);# why does it allow 64??
+++			me.gmPic.dirtyPixels();
+++			me.dirty = 0;
+++		} else {
+++			me.cleanImage();
+++		}
+++	},
+++	cleanImage: func {
+++		if (me["gmPic"] == nil) return;
+++		me.gmPic.fillRect([0,0,me.gmPicSize,me.gmPicSize], [0,0,0,0]);# why does it allow 64??
+++		#me.gmPic.setPixel(me.gm_x_origin, me.gm_y_origin, [0,0,1,1]);#blue pixel at ownship
+++		me.dirty = 1;
+++	},
+++	loop: func {
+++		if (me.enabled and me.radar.currentMode.mapper and me["gmPic"] != nil and me.dirty) {
+++			me.gmPic.dirtyPixels();
+++		}
+++		if (!me.radar.enabled and !me.cleaned) {
+++			me.cleanImage();
+++			me.cleaned = 1;
+++		} else {
+++			me.cleaned = 0;
+++		}
+++		if (me.debug > 3) {
+++			printf("geo=%8.6f pix=%8.6f",me.t_geo, me.t_pix);
+++			me.t_geo = 0;
+++			me.t_pix = 0;
+++		}
+++	},
+++	clear: func {
+++		#me.lowestElev = 0;
+++		#me.highestElev = 1000*math.ceil(getprop("position/ground-elev-ft")*0.001);
+++		#me.minElev = 35000;
+++		#me.maxElev = 0;
+++		me.cleanImage();
+++	},
+++	testRange: func (range, maxRange, az) {
+++		if (range > maxRange) {
+++			return 0;
+++		}
+++		az = math.abs(az)*D2R;
+++		if (math.sin(az)*range > maxRange*0.5) {
+++			return 0;
+++		}
+++		return 1;
+++	},
+++	debugOutput: func {
+++		if (me.radar.currentMode.bars == 4 and me.radar.currentMode["nextPatternNode"] != nil) {
+++        	if (me.radar.currentMode.nextPatternNode == 0) {
+++        		me.barCount = "4th";
+++        	} elsif (me.radar.currentMode.nextPatternNode == 1) {
+++        		me.barCount = "   ";return;
+++        	} elsif (me.radar.currentMode.nextPatternNode == 2) {
+++        		me.barCount = "1st";
+++        	} elsif (me.radar.currentMode.nextPatternNode == 3) {
+++        		me.barCount = "   ";return;
+++        	} elsif (me.radar.currentMode.nextPatternNode == 4) {
+++        		me.barCount = "2nd";
+++        	} elsif (me.radar.currentMode.nextPatternNode == 5) {
+++        		me.barCount = "   ";return;
+++        	} elsif (me.radar.currentMode.nextPatternNode == 6) {
+++        		me.barCount = "3rd";
+++        	} elsif (me.radar.currentMode.nextPatternNode == 7) {
+++        		me.barCount = "   ";return;
+++        	} else {
+++        		me.barCount = "Unk";return;
+++        	}
+++        	printf("AGL %5dft. Bar %s. Distance to bottom %.1fnm. Bottom to top %6.2fnm. Pitch %5.2f to %5.2f degs",getprop("position/altitude-agl-ft"), me.barCount, me.selfCoord.direct_distance_to(me.terrainCoordBot)*M2NM, me.terrainCoordBot.direct_distance_to(me.terrainCoordTop)*M2NM,me.eulerY-me.radar.instantFoVradius,me.radar.eulerY+me.radar.instantFoVradius);
+++        }
+++	},
+++	backScatter: func (gm_geod) {
+++		if (gm_geod == nil) {
+++			me.reflection = 0;
+++		} else {
+++			if (gm_geod[1] == nil) {
+++				me.reflection = 1;
+++			} elsif (!gm_geod[1].solid) {
+++				me.reflection = 0.05;
+++				if (me.gm_geod[0] != nil) {
+++					me.testElev = me.gm_geod[0]*M2FT;
+++					if (me.testElev < me.minElev) {
+++						me.minElev = me.testElev;
+++					}
+++				}
+++			} else {
+++				me.retur = me.howReflective(gm_geod[1]);
+++				if (me.retur == 0) {
+++					me.retur = gm_geod[1].bumpiness;
+++				}
+++				me.testElev = me.gm_geod[0]*M2FT;
+++				if (me.testElev < me.minElev) {
+++					me.minElev = me.testElev;
+++				}
+++				if (me.testElev > me.maxElev) {
+++					me.maxElev = me.testElev;
+++				}
+++				me.reflection = math.min(1, me.extrapolate(me.testElev, me.lowestElev, me.highestElev, 0.15, 0.6)+me.retur*0.4);
+++			}
+++		}
+++		return me.reflection;
+++	},
+++	frameDone: func {
+++		if (me.minElev != 35000 or me.maxElev != 0) {
+++			me.highestElev = (me.highestElev*1.5+me.maxElev)/2.5;# a simple lowpass filter to prevent it from changing too abrupt.
+++			me.lowestElev = (me.lowestElev*1.5+math.max(0, math.min(me.maxElev-1000, me.minElev)))/2.5;# prevent somewhat flat terrain to show as very undulated.
+++		}
+++		if (me.debug) setprop("debug-radar/mapper-elevation-min", me.lowestElev);
+++		if (me.debug) setprop("debug-radar/mapper-elevation-max", me.highestElev);
+++
+++		me.minElev = 35000;
+++		me.maxElev = 0;
+++	},
+++	howReflective: func(info) {
+++		# from AJS-37
+++	    foreach (var name; info.names) {
+++	        if (contains(me.urban_names, name)) return 1;
+++	    }
+++	    foreach (var name; info.names) {
+++	        if (contains(me.natural_names, name)) return me.natural_names[name];
+++	    }
+++    	return 0;
+++    },
+++    urban_names: {
+++		# from AJS-37
+++	    "Urban": 1,
+++	    "BuiltUpCover": 1,
+++	    "Construction": 1,
+++	    "Industrial": 1,
+++	    "Port": 1,
+++	    "Town": 1,
+++	    "SubUrban": 1,
+++	},
+++	natural_names: {
+++		# TODO: find more real data on this. Best source so far: AP3456 – 11-x - Radar
+++	    "Cliffs": 0.8,  # tend to be steep, hence greater return
+++	    "Asphalt": 0.7, # very granular hence good backscatter
+++	    "Airport": 0.5, #
+++	    "Rock": 0.6,    # tend to be somewhat steep, hence some solid backscatter
+++	    "RainForest": 0.35,
+++	    "MixedForest": 0.35,# wood does very little backscatter, but trees are upright, so good opportunity for specular return
+++	    "AgroForest": 0.25,
+++	    "SnowCover": 0.2,   # snow is very diffuse, hence very little backscatter
+++	    "PolarIce": 0.4,
+++	    "PackIce": 0.25,    # very smooth like the water it formed on, hence little return
+++	    "Glacier": 0.5,
+++	},
+++	interpolateCoords: func (start, end, fraction) {
+++		if (fraction == 0) {
+++			return geo.Coord.new(start);
+++		}
+++		if (fraction == 1) return geo.Coord.new(end);
+++		me.xx = (start.x()*(1-fraction)+end.x()*fraction);
+++		me.yy = (start.y()*(1-fraction)+end.y()*fraction);
+++		me.zz = (start.z()*(1-fraction)+end.z()*fraction);
+++
+++		me.cc = geo.Coord.new();
+++		me.cc.set_xyz(me.xx,me.yy,me.zz);
+++
+++		return me.cc;
+++	},
+++	extrapolate: func (x, x1, x2, y1, y2) {
+++    	return y1 + ((x - x1) / (x2 - x1)) * (y2 - y1);
+++	},
+++	##################################################################################################
+++	##################################################################################################
+++	##################################################################################################
+++	##################################################################################################
+++};
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++#  ████████  ██████  ██████      ██████   ██████  ██ ███    ██ ████████
+++#     ██    ██       ██   ██     ██   ██ ██    ██ ██ ████   ██    ██
+++#     ██    ██   ███ ██████      ██████  ██    ██ ██ ██ ██  ██    ██
+++#     ██    ██    ██ ██          ██      ██    ██ ██ ██  ██ ██    ██
+++#     ██     ██████  ██          ██       ██████  ██ ██   ████    ██
+++#
+++#
+++var ContactTGP = {
+++	new: func(callsign, coord, laser = 1) {
+++		var obj             = { parents : [ContactTGP, Contact]};# in real OO class this should inherit from Contact, but in nasal it does not need to
+++		obj.coord           = geo.Coord.new(coord);
+++		#obj.coord.set_alt(coord.alt()+1);#avoid z fighting
+++		obj.callsign        = callsign;
+++		obj.unique          = rand();
+++
+++		obj.tacobj = {parents: [tacview.tacobj]};
+++		obj.tacobj.tacviewID = right((obj.unique~""),5);
+++		obj.tacobj.valid = 1;
+++
+++		obj.laser = laser;
+++		return obj;
+++	},
+++
+++	isValid: func () {
+++		return 1;
+++	},
+++
+++	isVirtual: func () {
+++		return 1;
+++	},
+++
+++	getVirtualType: func {
+++		# Used to debug issue #532
+++		return "tgp-ground";
+++	},
+++
+++	isPainted: func () {
+++		return 0;
+++	},
+++
+++	isLaserPainted: func{
+++		return getprop("controls/armament/laser-arm-dmd") and me.laser;
+++	},
+++
+++	isRadiating: func (c) {
+++		return 0;
+++	},
+++
+++	getUnique: func () {
+++		return me.unique;
+++	},
+++
+++	getElevation: func() {
+++		#var e = 0;
+++		var selfPos = geo.aircraft_position();
+++		#var angleInv = ja37.clamp(self.distance_to(me.coord)/self.direct_distance_to(me.coord), -1, 1);
+++		#e = (self.alt()>me.coord.alt()?-1:1)*math.acos(angleInv)*R2D;
+++		return vector.Math.getPitch(selfPos, me.coord);
+++	},
+++
+++	getFlareNode: func () {
+++		return nil;
+++	},
+++
+++	getChaffNode: func () {
+++		return nil;
+++	},
+++
+++	get_Coord: func() {
+++		return me.coord;
+++	},
+++
+++	getCoord: func {
+++		return me.get_Coord();
+++	},
+++
+++	getETA: func {
+++		return nil;
+++	},
+++
+++	getHitChance: func {
+++		return nil;
+++	},
+++
+++	get_Callsign: func(){
+++		return me.callsign;
+++	},
+++
+++	getModel: func(){
+++		return "TGP spot";
+++	},
+++
+++	get_Speed: func(){
+++		# return true airspeed
+++		return 0;
+++	},
+++
+++	get_uBody: func {
+++		return 0;
+++	},
+++	get_vBody: func {
+++		return 0;
+++	},
+++	get_wBody: func {
+++		return 0;
+++	},
+++
+++	get_Longitude: func(){
+++		var n = me.coord.lon();
+++		return n;
+++	},
+++
+++	get_Latitude: func(){
+++		var n = me.coord.lat();
+++		return n;
+++	},
+++
+++	get_Pitch: func(){
+++		return 0;
+++	},
+++
+++	get_Roll: func(){
+++		return 0;
+++	},
+++
+++	get_heading : func(){
+++		return 0;
+++	},
+++
+++	get_bearing: func(){
+++		var n = me.get_bearing_from_Coord(geo.aircraft_position());
+++		return n;
+++	},
+++
+++	get_relative_bearing : func() {
+++		return geo.normdeg180(me.get_bearing()-getprop("orientation/heading-deg"));
+++	},
+++
+++	getLastAZDeviation : func() {
+++		return me.get_relative_bearing();
+++	},
+++
+++	get_altitude: func(){
+++		#Return Alt in feet
+++		return me.coord.alt()*M2FT;
+++	},
+++
+++	get_Longitude: func {
+++		return me.coord.lon()*M2FT;
+++	},
+++	get_Latitude: func {
+++		return me.coord.lat();
+++	},
+++
+++	get_range: func() {
+++		var r = me.coord.direct_distance_to(geo.aircraft_position()) * M2NM;
+++		return r;
+++	},
+++
+++	get_type: func () {
+++		return armament.POINT;
+++	},
+++
+++	get_bearing_from_Coord: func(MyAircraftCoord){
+++		var myBearing = 0;
+++		if(me.coord.is_defined()) {
+++			myBearing = MyAircraftCoord.course_to(me.coord);
+++		}
+++		return myBearing;
+++	},
+++};
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++
+++var scanInterval = 0.05;# 20hz for main radar
+++
+++
+++laserOn = props.globals.getNode("controls/armament/laser-arm-dmd",1);#don't put 'var' keyword in front of this.
+++var datalink_power = props.globals.getNode("instrumentation/datalink/power",0);
+++enable_tacobject = 1;
+++var antennae_knob_prop = props.globals.getNode("controls/radar/antennae-knob",0);
+++var wndprop = props.globals.getNode("environment/wind-speed-kt",0);
+++
+++
+++# start generic radar system
+++var baser = AIToNasal.new();
+++var partitioner = NoseRadar.new();
+++var omni = OmniRadar.new(1.0, 150, -1);
+++var terrain = TerrainChecker.new(0.05, 1, 30);# 0.05 or 0.10 is fine here
+++var callsignToContact = CallsignToContact.new();
+++var dlnkRadar = DatalinkRadar.new(0.03, 110, 225);# 3 seconds because cannot be too slow for DLINK targets
+++var ecm = ECMChecker.new(0.05, 6);
+++
+++# start specific radar system
+++var rwsMode = F16RWSMode.new(F16RWSSAMMode.new(F16MultiSTTMode.new()));
+++var twsMode = F16TWSMode.new(F16MultiSTTMode.new());
+++var lrsMode = F16LRSMode.new(F16LRSSAMMode.new(F16MultiSTTMode.new()));
+++var vsMode = F16VSMode.new(F16STTMode.new());
+++var acm20Mode = F16ACM20Mode.new(F16ACMSTTMode.new());
+++var acm60Mode = F16ACM60Mode.new(F16ACMSTTMode.new());
+++var acmBoreMode = F16ACMBoreMode.new(F16ACMSTTMode.new());
+++var seaMode = F16SeaMode.new(F16SEAFTTMode.new());
+++var gmMode = F16GMMode.new(F16GMFTTMode.new());
+++var gmtMode = F16GMTMode.new(F16GMTFTTMode.new());
+++var apg68Radar = AirborneRadar.newAirborne([[rwsMode,twsMode,lrsMode,vsMode],[acm20Mode,acm60Mode,acmBoreMode],[seaMode],[gmMode],[gmtMode]], APG68);
+++var f16_rwr = RWR.new();
+++var f16_radSensor = RadSensor.new();
+++var acmLockSound = props.globals.getNode("f16/sound/acm-lock");
+++var mapper = TerrainMapper.new(apg68Radar, 0.50);
+++
+++
+++
+++
+++var getCompleteList = func {
+++	return baser.vector_aicontacts_last;
+++}
+++
+++
+++
+++
+++
+++# BUGS:
+++#   HSD radar arc CW vs. CCW
+++#
+++# TODO:
+++#   VS switch speed at each bar instead of each frame
+++#
++diff --git a/Nasal/Radar/radar-system.nas b/Nasal/Radar/radar-system.nas
++index 69d91c8..e304976 100644
++--- a/Nasal/Radar/radar-system.nas
+++++ b/Nasal/Radar/radar-system.nas
++@@ -111,12 +111,12 @@ var RequestFullNotification = {
++ };
++ 
++ 
++-#  ███    ███  ██████  ██████  ███████ ██          ██████   █████  ██████  ███████ ███████ ██████ 
++-#  ████  ████ ██    ██ ██   ██ ██      ██          ██   ██ ██   ██ ██   ██ ██      ██      ██   ██ 
++-#  ██ ████ ██ ██    ██ ██   ██ █████   ██          ██████  ███████ ██████  ███████ █████   ██████  
++-#  ██  ██  ██ ██    ██ ██   ██ ██      ██          ██      ██   ██ ██   ██      ██ ██      ██   ██ 
++-#  ██      ██  ██████  ██████  ███████ ███████     ██      ██   ██ ██   ██ ███████ ███████ ██   ██ 
++-#                                                                                                  
+++#  ███    ███  ██████  ██████  ███████ ██          ██████   █████  ██████  ███████ ███████ ██████ 
+++#  ████  ████ ██    ██ ██   ██ ██      ██          ██   ██ ██   ██ ██   ██ ██      ██      ██   ██ 
+++#  ██ ████ ██ ██    ██ ██   ██ █████   ██          ██████  ███████ ██████  ███████ █████   ██████  
+++#  ██  ██  ██ ██    ██ ██   ██ ██      ██          ██      ██   ██ ██   ██      ██ ██      ██   ██ 
+++#  ██      ██  ██████  ██████  ███████ ███████     ██      ██   ██ ██   ██ ███████ ███████ ██   ██ 
+++#                                                                                                  
++ #
++ var AIToNasal = {
++ 	# convert AI property tree to Nasal vector
++@@ -453,12 +453,12 @@ var CallsignToContact = {
++ };
++ 
++ 
++-#   ██████  ██     ██ ███    ██ ███████ ██   ██ ██ ██████ 
++-#  ██    ██ ██     ██ ████   ██ ██      ██   ██ ██ ██   ██ 
++-#  ██    ██ ██  █  ██ ██ ██  ██ ███████ ███████ ██ ██████  
++-#  ██    ██ ██ ███ ██ ██  ██ ██      ██ ██   ██ ██ ██     
++-#   ██████   ███ ███  ██   ████ ███████ ██   ██ ██ ██ 
++-#                                                     
+++#   ██████  ██     ██ ███    ██ ███████ ██   ██ ██ ██████ 
+++#  ██    ██ ██     ██ ████   ██ ██      ██   ██ ██ ██   ██ 
+++#  ██    ██ ██  █  ██ ██ ██  ██ ███████ ███████ ██ ██████  
+++#  ██    ██ ██ ███ ██ ██  ██ ██      ██ ██   ██ ██ ██     
+++#   ██████   ███ ███  ██   ████ ███████ ██   ██ ██ ██ 
+++#                                                     
++ #
++ var SelfContact = {
++ 	#
++@@ -727,12 +727,12 @@ var Blep = {
++ };
++ 
++ 
++-#   ██████  ██████  ███    ██ ████████  █████   ██████ ████████ 
++-#  ██      ██    ██ ████   ██    ██    ██   ██ ██         ██    
++-#  ██      ██    ██ ██ ██  ██    ██    ███████ ██         ██ 
++-#  ██      ██    ██ ██  ██ ██    ██    ██   ██ ██         ██ 
++-#   ██████  ██████  ██   ████    ██    ██   ██  ██████    ██ 
++-#                                                            
+++#   ██████  ██████  ███    ██ ████████  █████   ██████ ████████ 
+++#  ██      ██    ██ ████   ██    ██    ██   ██ ██         ██    
+++#  ██      ██    ██ ██ ██  ██    ██    ███████ ██         ██ 
+++#  ██      ██    ██ ██  ██ ██    ██    ██   ██ ██         ██ 
+++#   ██████  ██████  ██   ████    ██    ██   ██  ██████    ██ 
+++#                                                            
++ #
++ var AIContact = {
++ # Attributes:
++@@ -853,7 +853,7 @@ var AIContact = {
++ 	    #
++         if (prop_name == "carrier") {
++         	return MARINE;
++-        } elsif (prop_name == "aircraft" or prop_name == "Mig-28") {
+++        } elsif (prop_name == "aircraft" or prop_name == "swift" or prop_name == "Mig-28") {
++         	return AIR;
++         } elsif (ordnance != nil) {
++         	return ORDNANCE;
++@@ -1370,12 +1370,12 @@ var AIContact = {
++ 	},
++ 
++ 
++-#  ██     ██ ███████  █████  ██████   ██████  ███    ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████ 
++-#  ██     ██ ██      ██   ██ ██   ██ ██    ██ ████   ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██      
++-#  ██  █  ██ █████   ███████ ██████  ██    ██ ██ ██  ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████ 
++-#  ██ ███ ██ ██      ██   ██ ██      ██    ██ ██  ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██ 
++-#   ███ ███  ███████ ██   ██ ██       ██████  ██   ████     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████ 
++-#                                                                                                                        
+++#  ██     ██ ███████  █████  ██████   ██████  ███    ██     ███    ███ ███████ ████████ ██   ██  ██████  ██████  ███████ 
+++#  ██     ██ ██      ██   ██ ██   ██ ██    ██ ████   ██     ████  ████ ██         ██    ██   ██ ██    ██ ██   ██ ██      
+++#  ██  █  ██ █████   ███████ ██████  ██    ██ ██ ██  ██     ██ ████ ██ █████      ██    ███████ ██    ██ ██   ██ ███████ 
+++#  ██ ███ ██ ██      ██   ██ ██      ██    ██ ██  ██ ██     ██  ██  ██ ██         ██    ██   ██ ██    ██ ██   ██      ██ 
+++#   ███ ███  ███████ ██   ██ ██       ██████  ██   ████     ██      ██ ███████    ██    ██   ██  ██████  ██████  ███████ 
+++#                                                                                                                        
++ #
++ 
++ 	get_type: func {
++@@ -1540,12 +1540,12 @@ var Radar = {
++ };
++ 
++ 
++-#  ██████   █████  ██████  ████████ ██ ████████ ██  ██████  ███    ██ 
++-#  ██   ██ ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ████   ██ 
++-#  ██████  ███████ ██████     ██    ██    ██    ██ ██    ██ ██ ██  ██ 
++-#  ██      ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ██  ██ ██ 
++-#  ██      ██   ██ ██   ██    ██    ██    ██    ██  ██████  ██   ████ 
++-#                                                                     
+++#  ██████   █████  ██████  ████████ ██ ████████ ██  ██████  ███    ██ 
+++#  ██   ██ ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ████   ██ 
+++#  ██████  ███████ ██████     ██    ██    ██    ██ ██    ██ ██ ██  ██ 
+++#  ██      ██   ██ ██   ██    ██    ██    ██    ██ ██    ██ ██  ██ ██ 
+++#  ██      ██   ██ ██   ██    ██    ██    ██    ██  ██████  ██   ████ 
+++#                                                                     
++ #
++ var NoseRadar = {
++ 	# I partition the sky into the field of regard and preserve the contacts in that field for it to be scanned by ActiveDiscRadar or similar
++@@ -2011,12 +2011,12 @@ var FullRadar = {
++ 
++ 
++ 
++-#   ██████  ███    ███ ███    ██ ██ 
++-#  ██    ██ ████  ████ ████   ██ ██ 
++-#  ██    ██ ██ ████ ██ ██ ██  ██ ██ 
++-#  ██    ██ ██  ██  ██ ██  ██ ██ ██ 
++-#   ██████  ██      ██ ██   ████ ██ 
++-#                                   
+++#   ██████  ███    ███ ███    ██ ██ 
+++#  ██    ██ ████  ████ ████   ██ ██ 
+++#  ██    ██ ██ ████ ██ ██ ██  ██ ██ 
+++#  ██    ██ ██  ██  ██ ██  ██ ██ ██ 
+++#   ██████  ██      ██ ██   ████ ██ 
+++#                                   
++ #
++ var OmniRadar = {
++ 	# I check the sky 360 deg for anything potentially detectable by a passive radar system.
++@@ -2057,6 +2057,9 @@ var OmniRadar = {
++ 				# This is not expensive as terrain manager set this in a loop.
++ 				continue;
++ 			}
+++			if (contact.getType() == ORDNANCE) {
+++				continue;
+++			}
++ 			me.rangeDirectNM = contact.getRangeDirect()*M2NM;
++ 			if (me.rangeDirectNM > me.max_dist_nm) {
++ 				continue;
++@@ -2104,12 +2107,12 @@ var OmniRadar = {
++ 
++ 
++ 
++-#  ████████ ███████ ██████  ██████   █████  ██ ███    ██ 
++-#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ████   ██ 
++-#     ██    █████   ██████  ██████  ███████ ██ ██ ██  ██ 
++-#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ██  ██ ██ 
++-#     ██    ███████ ██   ██ ██   ██ ██   ██ ██ ██   ████ 
++-#                                                        
+++#  ████████ ███████ ██████  ██████   █████  ██ ███    ██ 
+++#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ████   ██ 
+++#     ██    █████   ██████  ██████  ███████ ██ ██ ██  ██ 
+++#     ██    ██      ██   ██ ██   ██ ██   ██ ██ ██  ██ ██ 
+++#     ██    ███████ ██   ██ ██   ██ ██   ██ ██ ██   ████ 
+++#                                                        
++ #
++ var TerrainChecker = {
++ 	#
++@@ -2349,12 +2352,12 @@ var ECMChecker = {
++ 
++ 
++ 
++-#  ███████ ██ ██   ██ ███████ ██████      ██████  ███████  █████  ███    ███ 
++-#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ████  ████ 
++-#  █████   ██   ███   █████   ██   ██     ██████  █████   ███████ ██ ████ ██ 
++-#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ██  ██  ██ 
++-#  ██      ██ ██   ██ ███████ ██████      ██████  ███████ ██   ██ ██      ██ 
++-#                                                                            
+++#  ███████ ██ ██   ██ ███████ ██████      ██████  ███████  █████  ███    ███ 
+++#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ████  ████ 
+++#  █████   ██   ███   █████   ██   ██     ██████  █████   ███████ ██ ████ ██ 
+++#  ██      ██  ██ ██  ██      ██   ██     ██   ██ ██      ██   ██ ██  ██  ██ 
+++#  ██      ██ ██   ██ ███████ ██████      ██████  ███████ ██   ██ ██      ██ 
+++#                                                                            
++ #
++ var FixedBeamRadar = {
++ 
++@@ -2401,12 +2404,12 @@ var FixedBeamRadar = {
++ 
++ 
++ 
++-#   ██████  ██    ██ ███████ ██████  ██ ██████  ███████ ███████ 
++-#  ██    ██ ██    ██ ██      ██   ██ ██ ██   ██ ██      ██      
++-#  ██    ██ ██    ██ █████   ██████  ██ ██   ██ █████   ███████ 
++-#  ██    ██  ██  ██  ██      ██   ██ ██ ██   ██ ██           ██ 
++-#   ██████    ████   ███████ ██   ██ ██ ██████  ███████ ███████ 
++-#                                                               
+++#   ██████  ██    ██ ███████ ██████  ██ ██████  ███████ ███████ 
+++#  ██    ██ ██    ██ ██      ██   ██ ██ ██   ██ ██      ██      
+++#  ██    ██ ██    ██ █████   ██████  ██ ██   ██ █████   ███████ 
+++#  ██    ██  ██  ██  ██      ██   ██ ██ ██   ██ ██           ██ 
+++#   ██████    ████   ███████ ██   ██ ██ ██████  ███████ ███████ 
+++#                                                               
++ #
++ var flareProp = "rotors/main/blade[3]/flap-deg";
++ var chaffProp = "rotors/main/blade[3]/position-deg";
++@@ -2424,7 +2427,7 @@ var isOmniRadiating = func (model) {
++ 
++ var getRadarFieldRadius = func (model) {
++ 	# Override this method in your aircraft to do this in another way
++-	if (model == "A-50" or model == "EC-137R" or model == "E-3") {
+++	if (model == "A-50" or model == "EC-137R" or model == "E-3R" or model == "E-3") {
++ 		return 180;
++ 	}
++ 	if (model == "S-75" or model == "s-200") {
++@@ -2442,6 +2445,9 @@ var getRadarFieldRadius = func (model) {
++ 	if (model == "fleet" or model == "missile-frigate") {
++ 		return 180;
++ 	}
+++	if (knownSurface[model] == 0) {
+++		return 0;
+++	}
++ 	return 60;
++ }
++ 
++@@ -2481,6 +2487,7 @@ var knownCarriers = {
++ var knownAwacs = {
++ 	"A-50": nil,
++ 	"EC-137R": nil,
+++	"E-3R": nil,
++ 	"E-3": nil,
++ };
++ 
++@@ -2495,17 +2502,18 @@ var knownShips = {
++ };
++ 
++ var knownSurface = {
+++	# 0 = has no radar
++     "S-75":       nil,
++     "buk-m2":       nil,
++     "SA-6":       nil,
++     "s-300":       nil,
++     "s-200":       nil,
++-    "depot":       nil,
++-    "struct":       nil,
++-    "point":       nil,
++-    "rig":       nil,
+++    "depot":       0,
+++    "struct":       0,
+++    "point":       0,
+++    "rig":       0,
++     "gci":       nil,
++-    "truck":     nil,
+++    "truck":     0,
++     "tower":     nil,
++     "MIM104D":       nil,
++     "ZSU-23-4M":       nil,
++diff --git a/Nasal/b1b.nas b/Nasal/b1b.nas
++index d7fdfc3..c57fe7f 100644
++--- a/Nasal/b1b.nas
+++++ b/Nasal/b1b.nas
++@@ -908,3 +908,21 @@ var nuc = func {
++   screen.log.write(ltext);
++   }
++ }
+++
+++
+++var vector_aicontacts_links = [];
+++var DLRecipient = emesary.Recipient.new("DLRecipient");
+++var startDLListener = func {
+++    DLRecipient.radar = radar_system.dlnkRadar;
+++    DLRecipient.Receive = func(notification) {
+++        if (notification.NotificationType == "DatalinkNotification") {
+++            #printf("DL recv: %s", notification.NotificationType);
+++            if (me.radar.enabled == 1) {
+++                vector_aicontacts_links = notification.vector;
+++            }
+++            return emesary.Transmitter.ReceiptStatus_OK;
+++        }
+++        return emesary.Transmitter.ReceiptStatus_NotProcessed;
+++    };
+++    emesary.GlobalTransmitter.Register(DLRecipient);
+++}
++diff --git a/Nasal/data.nas b/Nasal/data.nas
++index ffbeade..de26ff6 100644
++--- a/Nasal/data.nas
+++++ b/Nasal/data.nas
++@@ -64,6 +64,7 @@ var loadSTPTs = func (path) {
++ }
++ 
++ var syncData = func {
+++    return;
++     for ( var bay = 0; bay < 3; bay = bay + 1 ) {
++         for ( var rack = 0; rack < 8; rack = rack + 1 ) {
++             weapons.wpn_info[bay][rack].lat = getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-latitude-deg");
++@@ -78,4 +79,30 @@ var syncData = func {
++     }
++ }
++ 
+++var select = func (bay, rack) {
+++    var t_lat = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-latitude-deg", bay, rack));
+++    var t_lon = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-longitude-deg", bay, rack));
+++    # t_alt = geo.elevation(t_lat, t_lon);
+++    var t_alt = getprop(sprintf("/ai/guided/bay%d/bomb[%d]/target-altitude", bay, rack));
+++    if (t_lat < 90 and t_lat > -90 and t_lon < 180 and t_lon > -180 and pylons.fcs != nil) {
+++        pylons.fcs.selectPylon(bay, rack);
+++        var wp = pylons.fcs.getSelectedWeapon();
+++        if (wp != nil and wp.parents[0] == armament.AIM and wp.target_pnt == 1 and (wp.guidance=="gps" or wp.guidance=="gps-altitude")) {
+++            var coord = geo.Coord.new();
+++            coord.set_latlon(t_lat,t_lon,t_alt);
+++            var spot = radar_system.ContactTGP.new("GPS-Spot",coord,0);
+++            armament.contactPoint = spot;
+++            if (getprop("f16/stores/tgp-mounted") and 0) {
+++                tgp.flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
+++                callsign = armament.contactPoint.getUnique();
+++                setprop("/aircraft/flir/target/auto-track", 1);
+++                flir_updater.offsetP = 0;
+++                flir_updater.offsetH = 0;
+++                setprop("f16/avionics/tgp-lock", 1);
+++            }
+++            wp.release([spot]);
+++        }
+++    }
+++}
+++
++ setprop("sim/fg-home-export", getprop("sim/fg-home")~"/Export");
++diff --git a/Nasal/datalink.nas b/Nasal/datalink.nas
++index e8ca836..7b88482 100644
++--- a/Nasal/datalink.nas
+++++ b/Nasal/datalink.nas
++@@ -21,6 +21,15 @@
++ # * Optional
++ #   /instrumentation/datalink/receive_period = 1        receiving loop update rate
++ #
+++# Optional: Re-define the function
+++#   datalink.can_transmit(callsign, mp_prop, mp_index)
+++#
+++# This function should return 'true' when the given aircraft is able to transmit over datalink to us.
+++# For instance, it can be used to check line of sight and maximum range.
+++# The default implementation always returns true (always able to transmit).
+++# Arguments are callsign, property node /ai/models/multiplayer[i], index of the former node.
+++#
+++#
++ # API:
++ # - get_data(callsign)
++ #     Returns all datalink information about 'callsign' as an object, or nil if there is none.
++@@ -35,9 +44,15 @@
++ # - get_connected_callsigns() / get_connected_indices()
++ #     Returns a vector containing all callsigns, resp. indices
++ #     in /ai/models/multiplayer[i], of aircrafts connected on datalink.
++-#     Both vectors use the same indices, i.e. get_connected_callsigns()[i]
+++#     Both vectors use the same order, i.e. get_connected_callsigns()[i]
++ #     and get_connected_indices()[i] correspond to the same aircraft.
++-# 
+++#     Furthermore this order is stable (the relative order of two aircrafts
+++#     does not change as long as neither disconnects from multiplayer).
+++#
+++# - get_all_callsigns()
+++#     Returns a vector containing all callsigns of aircraft with any associated data.
+++#     There is no guarantee on the order of callsigns.
+++#
++ # - send_data(data, timeout=nil)
++ #     Send data on the datalink. 'data' is a hash of the form
++ #       {
++@@ -75,6 +90,11 @@
++ #       tracked_by():       The callsign of the transmitting aircraft ("A"), or nil if tracked() is false.
++ #       tracked_by_index(): The index of the transmitting aircraft, or nil if tracked() is false.
++ #                           The index refers to property nodes /ai/models/multiplayer[i].
+++#       is_known():         Equivalent to (on_link() or tracked()).
+++#                           Indicates if the position of this aircraft is supposed to be known
+++#                           (i.e. whether or not it should be displayed on a HSD or whatever).
+++#       is_friendly():      Equivalent to (on_link() or iff() == IFF_FRIENDLY).
+++#       is_hostile():       Equivalent to (!on_link() and iff() == IFF_HOSTILE).
++ #
++ ## Sending data
++ # usage: send_data({ contacts: <contacts>, ...}, ...)
++@@ -93,7 +113,7 @@
++ #
++ ## Sending data
++ # Set the identifier with send_data({"identifier": <identifier>, ...});
++-# The identifier must be a string.
+++# The identifier must be a string. It must not contain '!'.
++ 
++ ### Coordinate transmission (extension name: "point")
++ #
++@@ -110,7 +130,7 @@
++ #### Protocol:
++ #
++ # Data is transmitted on MP generic string[7], with the following format:
++-#   <channel>(|<data>)+
+++#   <channel>(!<data>)+
++ #
++ # <channel> is a hash of the datalink channel. See hash_channel() and check_channel_hash().
++ # Each <data> block corresponds to data sent by an extension.
++@@ -120,8 +140,9 @@
++ # Remark: '!' as separator is specifically chosen to allow encoding with emesary.Transfer<type>.
++ #
++ # The current extension prefixes are the following:
++-#   contacts: C
+++#   contacts:   C
++ #   identifier: I
+++#   point:      P
++ 
++ #### Extensions API
++ #
++@@ -135,7 +156,7 @@
++ #
++ # encode(data)              extension encoding function.
++ #   Must return the encoding of the extension data (i.e. <data> when calling
++-#   send_data({name: <data>})) into a string, which may use any character except '|'.
+++#   send_data({name: <data>})) into a string, which may use any character except '!'.
++ #   The extension prefix must not be part of the encoded string.
++ #
++ # decode(aircrafts_data, callsign, index, string)      extension decoding function.
++@@ -158,6 +179,27 @@
++ #     unless an entry for 'callsign' already exists. Returns the modified hash.
++ 
++ 
+++
+++#### Version and changelog
+++# current: v1.1.0, minimum compatible: v1.0.0
+++#
+++## v1.1.0:
+++# Allow external transmission restrictions
+++# Make transmitting contact IFF optional
+++# Ensure personal identifier has no '!'
+++# '\n' is redundant for printf()
+++# Fix separator character in documentation
+++# Fix error when sending unknown extension
+++#
+++## v1.0.1:
+++# Add is_known(), is_friendly(), is_hostile() helpers to extension "contacts".
+++#
+++## v1.0.0: Initial version
+++# - Core protocol for datalink channel.
+++# - Extensions "contacts", "identifier", and "point".
+++
+++
+++
++ ### Parameters
++ #
++ # Remark: most parameters need to be the same on all aircrafts.
++@@ -171,6 +213,11 @@ var channel_hash_period = 600;
++ 
++ var receive_period = getprop("/instrumentation/datalink/receive_period") or 1;
++ 
+++# Should be overwitten to add transmission restrictions.
+++var can_transmit = func(contact, mp_prop, mp_index) {
+++    return 1;
+++}
+++
++ ### Properties
++ 
++ var input = {
++@@ -197,8 +244,7 @@ foreach (var name; keys(input)) {
++ # Channel is hashed with current time (rounded to 10min) and own callsign.
++ 
++ var clean_callsign = func(callsign) {
++-    if (size(callsign) > 7) return left(callsign, 7);
++-    else return callsign;
+++    return damage.processCallsign(callsign);
++ }
++ 
++ var my_callsign = func {
++@@ -283,11 +329,11 @@ var contact_parents = [Contact];
++ 
++ var register_extension = func(name, prefix, class, encode, decode) {
++     if (contains(extensions, name)) {
++-        printf("Datalink: double registration of extension '%s'. Skipping.\n", name);
+++        printf("Datalink: double registration of extension '%s'. Skipping.", name);
++         return -1;
++     }
++     if (contains(extension_prefixes, prefix)) {
++-        printf("Datalink: double registration of extension prefix '%s'. Skipping.\n", name);
+++        printf("Datalink: double registration of extension prefix '%s'. Skipping.", name);
++         return -1;
++     }
++     extensions[name] = { prefix: prefix, encode: encode, decode: decode, };
++@@ -330,7 +376,8 @@ var send_data = func(data, timeout=nil) {
++     foreach(var ext; keys(data)) {
++         # Skip missing extensions with a warning
++         if (!contains(extensions, ext)) {
++-            printf("Warning: unknown datalink extension %s in send_data().\n", ext);
+++            printf("Warning: unknown datalink extension %s in send_data().", ext);
+++            continue;
++         }
++         str = str ~ data_separator ~ extensions[ext].prefix ~ extensions[ext].encode(data[ext]);
++     }
++@@ -380,6 +427,10 @@ var get_connected_indices = func {
++     return connected_indices;
++ }
++ 
+++var get_all_callsigns = func {
+++    return keys(aircrafts_data);
+++}
+++
++ # Helper for modifying aircrafts_data.
++ var add_if_missing = func(aircrafts_data, callsign) {
++     if (!contains(aircrafts_data, callsign)) {
++@@ -413,6 +464,10 @@ var receive_loop = func {
++         # Check channel
++         if (!check_channel(tokens[0], callsign, my_channel)) continue;
++ 
+++        # We check this _after_ the channel. Checking the channel is quite cheap,
+++        # and we don't know how slow this function is, it might have a get_cart_ground_intersection()
+++        if (!can_transmit(callsign, mp, idx)) continue;
+++
++         # Add to list of connected aircrafts.
++         append(connected_callsigns, callsign);
++         append(connected_indices, idx);
++@@ -482,7 +537,14 @@ var ContactIdentifier = {
++ 
++ var encode_identifier = func(ident) {
++     # Force string conversion
++-    return ""~ident;
+++    ident = ""~ident;
+++
+++    if (find("!", ident) >= 0) {
+++        printf("Datalink: Identifier is not allowed to contain '!': %s.", ident);
+++        return "";
+++    } else {
+++        return ident;
+++    }
++ }
++ 
++ var decode_identifier = func(aircrafts_data, callsign, str) {
++@@ -528,6 +590,15 @@ var ContactTracked = {
++     iff: func {
++         return me._iff;
++     },
+++    is_known: func {
+++        return me.on_link() or me.tracked();
+++    },
+++    is_friendly: func {
+++        return me.on_link() or me.iff() == IFF_FRIENDLY;
+++    },
+++    is_hostile: func {
+++        return !me.on_link() and me.iff() == IFF_HOSTILE;
+++    },
++ };
++ 
++ # Contact encoding: callsign + bits
++@@ -539,7 +610,7 @@ var ContactTracked = {
++ 
++ var encode_contact = func(contact) {
++     # Encode bitfield
++-    var bits = contact.iff != nil ? contact.iff : IFF_UNKNOWN;
+++    var bits = contact["iff"] != nil ? contact.iff : IFF_UNKNOWN;
++ 
++     return emesary.TransferString.encode(clean_callsign(contact.callsign))
++         ~ emesary.TransferByte.encode(bits);
++@@ -607,4 +678,4 @@ var decode_point = func(aircrafts_data, callsign, str) {
++     return aircrafts_data;
++ }
++ 
++-register_extension("point", "P", ContactPoint, encode_point, decode_point);
+++register_extension("point", "P", ContactPoint, encode_point, decode_point);
++\ No newline at end of file
++diff --git a/Nasal/missile-code.nas b/Nasal/missile-code.nas
++index 2cad43f..c30bf48 100644
++--- a/Nasal/missile-code.nas
+++++ b/Nasal/missile-code.nas
++@@ -134,7 +134,7 @@ var PATTERN_ROSETTE = 1;
++ var PATTERN_DOUBLE_D = 2;
++ 
++ # set these to print stuff to console:
++-var DEBUG_STATS            = 0;#most basic stuff
+++var DEBUG_STATS            = 1;#most basic stuff
++ var DEBUG_FLIGHT           = 0;#for creating missiles sometimes good to have this on to see how it flies.
++ 
++ # set these to debug the code:
++diff --git a/Nasal/steerpoints.nas b/Nasal/steerpoints.nas
++new file mode 100644
++index 0000000..50a8626
++--- /dev/null
+++++ b/Nasal/steerpoints.nas
++@@ -0,0 +1,1071 @@
+++ #
+++# F-16 Steerpoint/route/mark/bulls-eye system.
+++#
+++var lines = [nil,nil, nil, nil];
+++
+++var desired_tos = {};
+++
+++var number_of_threat_circles  = 15;
+++var number_of_generic         = 10;
+++var number_of_markpoints_own  = 5;
+++var number_of_markpoints_dlnk = 5;
+++
+++var index_of_threat_circles   = 300;
+++var index_of_generic          = 350;
+++var index_of_markpoints_own   = 400;
+++var index_of_markpoints_dlnk  = 450;
+++var index_of_weapon_gps       = 500;
+++var index_of_bullseye         = 555;
+++var index_of_lines_1          = 100;
+++var index_of_lines_2          = 200;
+++var index_of_lines_3          = 600;
+++var index_of_lines_4          = 700;
+++
+++var stpt300 = setsize([],number_of_threat_circles);#Threat circles
+++var stpt350 = setsize([],10);#Generic
+++var stpt400 = setsize([],5);#Markpoints Own
+++var stpt450 = setsize([],5);#Markpoints DL
+++var stpt500 = setsize([],1);#Weapon
+++var stpt555 = setsize([],1);#Bullseye
+++var current = nil;#Current STPT number, nil for route/nothing.
+++
+++var colorRed = 0;
+++var colorYellow = 1;
+++var colorGreen = 2;
+++
+++var autoMode = 1;# if change this then also change f16/ded/stpt-auto
+++
+++var STPT = {
+++	# stored in the above vectors for non-route steerpoints
+++	lon: 0,
+++	lat: 0,
+++	alt: 0,
+++	type: "   ",
+++	radius: 10,
+++	color: colorYellow,
+++
+++	new: func {
+++		var n = {parents: [STPT]};
+++		return n;
+++	},
+++
+++	copy: func {
+++		var cp = STPT.new();
+++		cp.lat = me.lat;
+++		cp.lon = me.lon;
+++		cp.alt = me.alt;
+++		cp.type = me.type;
+++		cp.radius = me.radius;
+++		cp.color = me.color;
+++		return cp;
+++	},
+++};
+++
+++
+++
+++var getCurrentNumber = func {
+++	# Get current steerpoint. The first is #1. Return 0 for no current steerpoint.
+++	if (current != nil) {
+++		return current;
+++	} elsif (isRouteActive()) {
+++		var fp = flightplan();
+++		return fp.current + 1;
+++	}
+++	return 0;
+++}
+++
+++var getLastNumber = func {
+++	# Get the steerpoint # for the final steerpoint in current route or for non-route get the current.
+++	if (current != nil) {
+++		return current;
+++	} elsif (isRouteActive()) {
+++		var fp = flightplan();
+++		return fp.getPlanSize();
+++	}
+++	return 0;
+++}
+++
+++var getNumber = func (number) {
+++	# Return a specific steerpoint, nil if none
+++	if (!_isOccupiedNumber(number)) {
+++		return nil;
+++	}
+++	if (number >= 700 and lines[3] != nil) {
+++		var fp = lines[3];
+++		var leg = fp.getWP(number-700);
+++		var new = STPT.new();
+++		new.lat = leg.lat;
+++		new.lon = leg.lon;
+++		if (leg.alt_cstr != nil) {
+++			new.alt = leg.alt_cstr;
+++		}
+++		return new;
+++	}
+++	if (number >= 600 and lines[2] != nil) {
+++		var fp = lines[2];
+++		var leg = fp.getWP(number-600);
+++		var new = STPT.new();
+++		new.lat = leg.lat;
+++		new.lon = leg.lon;
+++		if (leg.alt_cstr != nil) {
+++			new.alt = leg.alt_cstr;
+++		}
+++		return new;
+++	}
+++	if (number == 555) {
+++		return stpt555[0];
+++	}
+++	if (number == 500) {
+++		return stpt500[0];
+++	}
+++	if (number >= 450) {
+++		return stpt450[number-450];
+++	}
+++	if (number >= 400) {
+++		return stpt400[number-400];
+++	}
+++	if (number >= 350) {
+++		return stpt350[number-350];
+++	}
+++	if (number >= 300) {
+++		return stpt300[number-300];
+++	}
+++	if (number >= 200 and lines[1] != nil) {
+++		var fp = lines[1];
+++		var leg = fp.getWP(number-200);
+++		var new = STPT.new();
+++		new.lat = leg.lat;
+++		new.lon = leg.lon;
+++		if (leg.alt_cstr != nil) {
+++			new.alt = leg.alt_cstr;
+++		}
+++		return new;
+++	}
+++	if (number >= 100 and lines[0] != nil) {
+++		var fp = lines[0];
+++		var leg = fp.getWP(number-100);
+++		var new = STPT.new();
+++		new.lat = leg.lat;
+++		new.lon = leg.lon;
+++		if (leg.alt_cstr != nil) {
+++			new.alt = leg.alt_cstr;
+++		}
+++		return new;
+++	}
+++	if (number < 100 and isRouteActive()) {
+++		var fp = flightplan();
+++		var leg = fp.getWP(number-1);
+++		var new = STPT.new();
+++		new.lat = leg.lat;
+++		new.lon = leg.lon;
+++		if (leg.alt_cstr != nil) {
+++			new.alt = leg.alt_cstr;
+++		}
+++		return new;
+++	}
+++	return nil;
+++}
+++
+++var setNumber = func (number, stpt) {
+++	# Store a non-route steerpoint in memory
+++	if (!_isValidNumber(number)) {
+++		return 0;
+++	}
+++	if (number == 555) {
+++		stpt555[0] = stpt;
+++		return 1;
+++	}
+++	if (number == 500) {
+++		stpt500[0] = stpt;
+++		return 1;
+++	}
+++	if (number >= 450) {
+++		stpt450[number-450] = stpt;
+++		return 1;
+++	}
+++	if (number >= 400) {
+++		stpt400[number-400] = stpt;
+++		return 1;
+++	}
+++	if (number >= 350) {
+++		stpt350[number-350] = stpt;
+++		return 1;
+++	}
+++	if (number >= 300) {
+++		stpt300[number-300] = stpt;
+++		return 1;
+++	}
+++	if (number < 300) {
+++		return 0;
+++	}
+++	return 0;
+++}
+++
+++var getCurrentDirection = func {
+++	# Get directions to current steerpoint or [nil,nil] for none.
+++	if (getCurrentNumber() != 0) {
+++		var cc = getCurrentCoord();
+++		return [geo.aircraft_position().course_to(cc), vector.Math.getPitch(geo.aircraft_position(), cc)];
+++	} else {
+++		return [nil, nil];
+++	}
+++}
+++
+++var getCurrentDirectionForHUD = func {
+++	# Get directions to current steerpoint or [nil,nil] for none.
+++	if (getCurrentNumber() != 0) {
+++		var cc = getCurrentCoordForHUD();
+++		return [geo.aircraft_position().course_to(cc), vector.Math.getPitch(geo.aircraft_position(), cc)];
+++	} else {
+++		return [nil, nil];
+++	}
+++}
+++
+++var getCurrentRange = func {
+++	# Return range in nm to current steerpoint.
+++	if (getCurrentNumber() == 0) return nil;
+++	var s = getCurrentCoord();
+++	return s.distance_to(geo.aircraft_position())*M2NM;
+++}
+++
+++var getCurrentGroundPitch = func {
+++	#if (getCurrentNumber() != 0) {
+++		var gCoord = getCurrentGroundCoord();
+++		if (gCoord != nil) {
+++			return vector.Math.getPitch(geo.aircraft_position(), gCoord);
+++		}
+++	#}
+++	return nil;
+++}
+++
+++var getCurrentSlantRange = func {
+++	# Return slant range in nm to current steerpoint.
+++	if (getCurrentNumber() == 0) return nil;
+++	var s = getCurrentCoord();
+++	return s.direct_distance_to(geo.aircraft_position())*M2NM;
+++}
+++
+++var getCurrentETA = func {
+++	# Return seconds till current steerpoint.
+++	if (getCurrentNumber() == 0) return nil;
+++	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
+++	if (gs == 0) return nil;
+++	if (current == nil) {
+++		return getprop("autopilot/route-manager/wp/eta-seconds");
+++	}
+++	var range = getCurrentRange()*NM2M;
+++	return range/gs;
+++}
+++
+++var getCurrentCoord = func {
+++	# returns current steerpoint as geo.Coord
+++	var s = getNumber(getCurrentNumber());
+++	if (s == nil) return nil;
+++	return stpt2coord(s);
+++}
+++
+++var getCurrentCoordForHUD = func {
+++	# returns current steerpoint as geo.Coord
+++	var s = getNumber(getCurrentNumber());
+++	return stpt2coordGrounded(s);
+++}
+++
+++var getCurrentGroundCoord = func {
+++	# returns current steerpoint as geo.Coord
+++	var s = getNumber(getCurrentNumber());
+++	if (s == nil) return nil;
+++	var elev = geo.elevation(s.lat, s.lon);
+++	if (elev == nil) {
+++		if (s.alt != nil) {
+++			elev = s.alt * FT2M;
+++		} else {
+++			return nil;
+++		}
+++	}
+++	var p = geo.Coord.new();
+++    p.set_latlon(s.lat, s.lon, elev);
+++
+++	return p;
+++}
+++
+++var setCurrentNumber = func (number) {
+++	# Set current steerpoint number.
+++	if (number < 100 and isRouteActive() and number > 0) {
+++		var fp = flightplan();
+++		if (fp.getPlanSize() >= number) {
+++			fp.current = number - 1;
+++			current = nil;
+++			print("Switching active steerpoint to #"~number);
+++			return 1;
+++		}
+++	} elsif (_isOccupiedNumber(number)) {
+++		current = number;
+++		print("Switching active steerpoint to #"~number);
+++		return 1;
+++	}
+++	return 0;
+++}
+++
+++var getCurrent = func {
+++	# return current steerpoint or nil
+++	return getNumber(getCurrentNumber());
+++}
+++
+++var getLastRange = func {
+++	# Get nm range to final steerpoint in current route or to current steerpoint for non-route.
+++	if (getCurrentNumber() == 0) return nil;
+++	if (current == nil) {
+++		var fp = flightplan();
+++		var dist_nm = steerpoints.getCurrentRange();
+++		var stnum = getCurrentNumber();
+++		for (var index = stnum; index < fp.getPlanSize(); index+=1) {
+++			dist_nm += fp.getWP(index).leg_distance;
+++		}
+++		return dist_nm;
+++	} else {
+++		return steerpoints.getCurrentRange();
+++	}
+++}
+++
+++var getNumberRange = func (number) {
+++	# Get range to specific steerpoint
+++	if (getCurrentNumber() == 0) return nil;
+++	if (current == nil and number >= getCurrentNumber()) {
+++		var dist_nm = steerpoints.getCurrentRange();
+++		var stnum = getCurrentNumber();
+++		for (var index = stnum; index < number-1; index+=1) {
+++			dist_nm += flightplan().getWP(index).leg_distance;
+++		}
+++		return dist_nm;
+++	} elsif (number == getCurrentNumber()) {
+++		return steerpoints.getCurrentRange();
+++	}
+++	return nil;
+++}
+++
+++var getLast = func {
+++	# Return final steerpoint
+++	if (getCurrentNumber() == 0) return nil;
+++	return getNumber(getLastNumber());
+++}
+++
+++var getRequiredSpeed = func (number) {
+++    # Get required groundspeed in kts for TOS on specific steerpoint
+++    if (getCurrentNumber() == 0) return nil;
+++    var range = getNumberRange(number)*NM2M;
+++    var des_tos = _getNumberDesiredTOS(number);
+++    #var des_tos = getprop("f16/ded/crus-des-tos");
+++    if (des_tos == nil) {
+++       des_tos = 0;
+++    }
+++    # Subtract current time from TOS to get relative time
+++    #if (des_tos > addSeconds(0, getprop("sim/time/utc/hour"),getprop("sim/time/utc/minute"),getprop("sim/time/utc/second"))) {
+++        # Desired TOS is in the past, this shouldn't really matter, since we have a min of 70kts
+++    #}
+++    var cur_sec = (((getprop("sim/time/utc/hour")*60)+getprop("sim/time/utc/minute"))*60)+getprop("sim/time/utc/second")+math.fmod(getprop("sim/time/steady-clock-sec"), 1);
+++    #var tos_sec = addSeconds(des_tos, -getprop("sim/time/utc/hour"),-getprop("sim/time/utc/minute"),-getprop("sim/time/utc/second"));
+++    #tos_sec = (((tos_sec[1]*60)+tos_sec[2])*60)+tos_sec[3];
+++
+++    # MLU M1: if STPT not reached in time, airspeed caret remains at max
+++    if (cur_sec > des_tos) {
+++        return 1700;
+++    }
+++    var tos_sec = des_tos - cur_sec;
+++    var req_spd = range / tos_sec / KT2MPS;
+++    # As per MLU M1, the speed is limited between 70kts and 1700kts
+++    return math.max(math.min(req_spd, 1700), 70);
+++}
+++
+++var getLastETA = func {
+++	# Get time in seconds till final steerpoint
+++	if (getCurrentNumber() == 0) return nil;
+++	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
+++	if (gs == 0) return nil;
+++	var range = getLastRange()*NM2M;
+++	return range/gs;
+++}
+++
+++var getNumberETA = func (number) {
+++	# Get time in seconds till specific steerpoint
+++	if (getCurrentNumber() == 0) return nil;
+++	var gs = getprop("velocities/groundspeed-kt")*KT2MPS;
+++	if (gs == 0) return nil;
+++	var range = getNumberRange(number)*NM2M;
+++	return range/gs;
+++}
+++
+++var setNumberDesiredTOS = func (number, tos) {
+++    if (tos == -1) {
+++        tos = nil;
+++    }
+++    desired_tos[number] = tos;
+++    return;
+++}
+++
+++var _getNumberDesiredTOS = func (number) {
+++    if (getCurrentNumber() == 0) return nil;
+++    return desired_tos[number];
+++}
+++
+++var serializeTOS = func (number) {
+++    var result = _getNumberDesiredTOS(number);
+++    if (result == nil) {
+++        result = -1;
+++    }
+++    return result;
+++}
+++
+++var getNumberDesiredTOS = func (number) {
+++    # Get string with desired time over steerpoint for specific steerpoint
+++    var val = _getNumberDesiredTOS(number);
+++	return _getTOS(val);
+++}
+++
+++var getNumberTOS = func (number) {
+++	# Get string with time on station for specific steerpoint
+++	if (getCurrentNumber() == 0) return nil;
+++	var eta = getNumberETA(number);
+++	return _getTOS(eta);
+++}
+++
+++var _getCurrentDesiredTOS = func {
+++    return _getNumberDesiredTOS(getCurrentNumber());
+++}
+++
+++var getCurrentDesiredTOS = func {
+++	# Get string with desired time over steerpoint for current steerpoint
+++	return getNumberDesiredTOS(getCurrentNumber());
+++}
+++
+++var setCurrentDesiredTOS = func (tos) {
+++	# Get string with desired time over steerpoint for current steerpoint
+++	return setNumberDesiredTOS(getCurrentNumber(), tos);
+++}
+++
+++var getCurrentRequiredSpeed = func {
+++    return getRequiredSpeed(getCurrentNumber());
+++}
+++
+++var getAbsoluteTOS = func (eta) {
+++    return _getTOS(eta, 1);
+++}
+++
+++var getCurrentTOS = func {
+++	# Get string with time on station for current steerpoint
+++	var eta = getCurrentETA();
+++	return _getTOS(eta);
+++}
+++
+++var getLastTOS = func {
+++	# Get string with time on station for final steerpoint
+++	var eta = getLastETA();
+++	return _getTOS(eta);
+++}
+++
+++var formatTime = func(time, absolute = 1) {
+++    var result = "--:--:--";
+++    if (time == nil or time>3600*24 or time < 0) {
+++		return result;
+++	} else {
+++	    if (!absolute) {
+++            var hour   = getprop("sim/time/utc/hour");
+++            var minute = getprop("sim/time/utc/minute");
+++            var second = getprop("sim/time/utc/second");
+++        } else {
+++            var hour   = 0;
+++            var minute = 0;
+++            var second = 0;
+++        }
+++        var final = addSeconds(time,second,minute,hour);
+++
+++		result = sprintf("%02d:%02d:%02d",final[1],final[2],final[3]);
+++	}
+++	return result;
+++}
+++
+++var _getTOS = func (eta, absolute = 0) {
+++	# Get string with time on station for a specific time in seconds
+++	# eta is allowed to be nil
+++	# if absolute the eta is assumed to be an exact time, otherwise eta is assumed to be relative to current time
+++	var TOS = "--:--:--";
+++	if (getCurrentNumber() == 0) return TOS;
+++
+++	return formatTime(eta, !absolute);
+++}
+++
+++var addSeconds = func (add_secs, secs, mins, hours) {
+++	# Add some seconds to 24 hr clock
+++
+++	# the baseline:
+++	var d = 0;
+++	var h = hours;
+++	var m = mins;
+++	var s = secs;
+++
+++	# the added:
+++	var H = int(add_secs/3600);
+++    var S = add_secs-H*3600;
+++    var M = int(S/60);
+++    S = S-M*60;
+++
+++    s += S;
+++    var addOver = 0;
+++	while (s > 59) {
+++		addOver += 1;
+++		s -= 60;
+++	}
+++
+++	m += M+addOver;
+++	addOver = 0;
+++	while (m > 59) {
+++		addOver += 1;
+++		m -= 60;
+++	}
+++
+++	h += H+addOver;
+++	while (h > 23) {
+++		addOver += 1;
+++		h -= 24;
+++	}
+++
+++	d = addOver;
+++
+++    return [d,h,m,s];
+++}
+++
+++var next = func {
+++	# Advance steerpoint
+++	if (current != nil) return;
+++	var active = isRouteActive();
+++    var wp = getprop("autopilot/route-manager/current-wp");
+++    var max = getprop("autopilot/route-manager/route/num");
+++
+++    if (active) {
+++		wp += 1;
+++		if (wp>max-1) {
+++			wp = 0;
+++		}
+++		setprop("autopilot/route-manager/current-wp", wp);
+++	}
+++}
+++
+++var prev = func {
+++	# Decrease steerpoint
+++	if (current != nil) return;
+++	var active = isRouteActive();
+++    var wp = getprop("autopilot/route-manager/current-wp");
+++    var max = getprop("autopilot/route-manager/route/num");
+++
+++    if (active) {
+++		wp -= 1;
+++		if (wp<0) {
+++			wp = max-1;
+++		}
+++		setprop("autopilot/route-manager/current-wp", wp);
+++    }
+++}
+++
+++var copy = func (from, to) {
+++	# Copy steerpoint. Cannot copy TO route or lines steerpoints.
+++	var fStpt = getNumber(from);
+++	if (fStpt != nil and _isValidNumber(to)) {
+++		var tStpt = fStpt.copy();
+++		setNumber(to, tStpt);
+++		print("Copying steerpoint #"~from~" to #"~to);
+++	} else {
+++		print("STPT copy unsuccesful.");
+++	}
+++}
+++
+++var sendCurrent = func {
+++	# Send current steerpoint over DLNK
+++	return send(getCurrentNumber());
+++}
+++
+++var stpt2coord = func (stpt) {
+++	# Convert steerpoint to geo.Coord
+++	var p = geo.Coord.new();
+++    p.set_latlon(stpt.lat, stpt.lon, stpt.alt*FT2M);
+++    return p;
+++}
+++
+++var stpt2coordGrounded = func (stpt) {
+++	# Convert steerpoint to geo.Coord but not lower than ground
+++	var p = geo.Coord.new();
+++	var elev = stpt.alt*FT2M;
+++	if (elev <= 0) {
+++		elev = geo.elevation(stpt.lat, stpt.lon);
+++		if (elev == nil) {
+++			elev = 0;
+++		}
+++	}
+++    p.set_latlon(stpt.lat, stpt.lon, elev);
+++    return p;
+++}
+++
+++var send = func (number) {
+++	# Send specific steerpoint over DLNK
+++	var s = getNumber(number);
+++	if (s != nil and sending == nil) {
+++		var p = stpt2coord(s);
+++	    sending = p;
+++	    datalink.send_data({"point": sending});
+++	    settimer(func {sending = nil;},7);
+++	    print("Sending steerpoint to #"~number~" to DLNK.");
+++	    return 1;
+++	}
+++	return 0;
+++}
+++
+++var markOFLY = func {
+++	# Create an OLFY markpoint
+++	var mark = STPT.new();
+++	mark.lat = getprop("/position/latitude-deg");
+++	mark.lon = getprop("/position/longitude-deg");
+++	mark.alt = getprop("/position/altitude-ft");
+++	mark.type = "OFLY";
+++	addOwnMark(mark);
+++}
+++
+++var markTGP = func (coord) {
+++	# Create a TGP markpoint
+++	var mark = STPT.new();
+++	mark.lat = coord.lat();
+++	mark.lon = coord.lon();
+++	mark.alt = coord.alt()*M2FT;
+++	mark.type = "TGP";
+++	return addOwnMark(mark);
+++}
+++
+++var markHUD = func (coord) {
+++	# Create a HUD markpoint
+++	var mark = STPT.new();
+++	mark.lat = coord.lat();
+++	mark.lon = coord.lon();
+++	mark.alt = coord.alt()*M2FT;
+++	mark.type = "HUD";
+++	return addOwnMark(mark);
+++}
+++
+++var ownMarkIndex = 4;
+++
+++var addOwnMark = func (mark) {
+++	# Store a mark
+++	ownMarkIndex += 1;
+++	if (ownMarkIndex > 4) ownMarkIndex = 0;
+++	stpt400[ownMarkIndex] = mark;
+++	return ownMarkIndex+400;
+++}
+++
+++var dlMarkIndex = 4;
+++
+++var addDLMark = func (mark) {
+++	# STore a DLNK mark
+++	dlMarkIndex += 1;
+++	if (dlMarkIndex > 4) dlMarkIndex = 0;
+++	stpt450[dlMarkIndex] = mark;
+++	return dlMarkIndex+450;
+++}
+++
+++var applyToWPN = func {
+++	# Apply WPN steerpoint to current weapon
+++	var lat = getprop("f16/avionics/gps-lat");
+++	var lon = getprop("f16/avionics/gps-lon");
+++	var alt = getprop("f16/avionics/gps-alt")*FT2M;
+++	if (lat < 90 and lat > -90 and lon < 180 and lon > -180 and pylons.fcs != nil) {
+++		var wp = pylons.fcs.getSelectedWeapon();
+++		if (wp != nil and wp.parents[0] == armament.AIM and wp.target_pnt == 1 and wp.guidance=="gps") {
+++			var coord = geo.Coord.new();
+++			coord.set_latlon(lat,lon,alt);
+++			var spot = radar_system.ContactTGP.new("GPS-Spot",coord,0);
+++			armament.contactPoint = spot;
+++			tgp.gps = 1;
+++			if (getprop("f16/stores/tgp-mounted") and 0) {
+++				tgp.flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
+++				callsign = armament.contactPoint.getUnique();
+++                setprop("/aircraft/flir/target/auto-track", 1);
+++                flir_updater.offsetP = 0;
+++                flir_updater.offsetH = 0;
+++				setprop("f16/avionics/tgp-lock", 1);
+++			}
+++			wp.setContacts([spot]);
+++		}
+++	}
+++}
+++
+++var _isValidNumber = func (number) {
+++	# Is the number a valid possible steerpoint number?
+++	if (number >= 300 and number < 300+number_of_threat_circles) {
+++		return 1;
+++	} elsif (number >= 350 and number <= 359) {
+++		return 1;
+++	} elsif (number >= 400 and number <= 404) {
+++		return 1;
+++	} elsif (number >= 450 and number <= 454) {
+++		return 1;
+++	} elsif (number == 500) {
+++		return 1;
+++	} elsif (number == 555) {
+++		return 1;
+++	} elsif (number >= 1 and number < 300) {
+++		return 1;
+++	} elsif (number >= 600 and number < 700) {
+++		return 1;
+++	} elsif (number >= 700 and number < 800) {
+++		return 1;
+++	}
+++	return 0;
+++}
+++
+++var _isOccupiedNumber = func (number) {
+++	# Is a steerpoint stored at this memory address?
+++	if (!_isValidNumber(number)) {
+++		return 0;
+++	}
+++	if (number < 800 and number >= 700) {
+++		if (lines[3] != nil) {
+++			var fp = lines[3];
+++			return fp.getPlanSize() > number-700;
+++		}
+++		return 0;
+++	}
+++	if (number < 700 and number >= 600) {
+++		if (lines[2] != nil) {
+++			var fp = lines[2];
+++			return fp.getPlanSize() > number-600;
+++		}
+++		return 0;
+++	}
+++	if (number == 555) {
+++		return stpt555[0] != nil;
+++	}
+++	if (number == 500) {
+++		return stpt500[0] != nil;
+++	}
+++	if (number >= 450) {
+++		return stpt450[number-450] != nil;
+++	}
+++	if (number >= 400) {
+++		return stpt400[number-400] != nil;
+++	}
+++	if (number >= 350) {
+++		return stpt350[number-350] != nil;
+++	}
+++	if (number >= 300) {
+++		return stpt300[number-300] != nil;
+++	}
+++	if (number < 300 and number >= 200 and lines[1] != nil) {
+++		var fp = lines[1];
+++		return fp.getPlanSize() > number-200;
+++	}
+++	if (number < 200 and number >= 100 and lines[0] != nil) {
+++		var fp = lines[0];
+++		return fp.getPlanSize() > number-100;
+++	}
+++	if (number < 100 and number > 0 and isRouteActive()) {
+++		var fp = flightplan();
+++		return fp.getPlanSize() > number-1;
+++	}
+++	return 0;
+++}
+++
+++
+++
+++var isRouteActive = func {
+++	return getprop("autopilot/route-manager/active") and getprop("f16/avionics/power-mmc") and getprop("autopilot/route-manager/current-wp") != nil and getprop("autopilot/route-manager/current-wp") > -1 and getprop("autopilot/route-manager/route/num") != nil and getprop("autopilot/route-manager/current-wp") < getprop("autopilot/route-manager/route/num");
+++}
+++
+++
+++var data = nil;
+++var sending = nil;
+++var dlink_loop = func {
+++  if (getprop("instrumentation/datalink/data") != 0) return;
+++  foreach(contact; b1b.vector_aicontacts_links) {
+++    if (contact.isVisible()) {
+++      data = datalink.get_data(contact.get_Callsign());
+++      if (data != nil  and data.on_link()) {
+++        var p = data.point();
+++        if (p != nil) {
+++          sending = nil;
+++          var mrk = STPT.new();
+++          mrk.lat = p.lat();
+++          mrk.lon = p.lon();
+++          mrk.alt = p.alt()*M2FT;
+++          var no = addDLMark(mrk);
+++
+++          setprop("instrumentation/datalink/data",no);
+++
+++          settimer(func {setprop("instrumentation/datalink/data",0);}, 10);
+++          return;
+++        }
+++      }
+++    }
+++  }
+++}
+++
+++var dlnk_timer = maketimer(3.5, dlink_loop);
+++dlnk_timer.start();
+++
+++
+++
+++
+++var loadLine = func  (no,path) {
+++    printf("Attempting to load route %s to act as lines %d in HSD.", path, no);
+++
+++    call(func {lines[no] = createFlightplan(path);}, nil, var err = []);
+++    if (size(err) or lines[no] == nil) {
+++        print(err[0]);
+++        setprop("f16/preplanning-status", err[0]);
+++        gui.showDialog("loadfail");
+++    } else {
+++    	setprop("f16/preplanning-status", "HSD lines loaded");
+++    }
+++};
+++
+++var EMPTY_ALT = -99999;
+++
+++var serialize = func() {
+++	var ret = "";
+++	var iter = 0;
+++	if (lines[0] != nil) {
+++		for (var s = 0; s < lines[0].getPlanSize() and s < 100; s+=1) {
+++			var key = lines[0].getWP(s);
+++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+100,key.lat,key.lon);
+++	  	}
+++	}
+++	if (lines[1] != nil) {
+++		for (var s = 0; s < lines[1].getPlanSize() and s < 100; s+=1) {
+++			var key = lines[1].getWP(s);
+++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+200,key.lat,key.lon);
+++	  	}
+++	}
+++	if (lines[2] != nil) {
+++		for (var s = 0; s < lines[2].getPlanSize() and s < 100; s+=1) {
+++			var key = lines[2].getWP(s);
+++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+600,key.lat,key.lon);
+++	  	}
+++	}
+++	if (lines[3] != nil) {
+++		for (var s = 0; s < lines[3].getPlanSize() and s < 100; s+=1) {
+++			var key = lines[3].getWP(s);
+++		  	ret = ret~sprintf("LINE,%d,%.6f,%.6f|",s+700,key.lat,key.lon);
+++	  	}
+++	}
+++	if (flightplan() != nil) {
+++		var plan = flightplan();
+++		for (var s = 0; s < plan.getPlanSize(); s+=1) {
+++			var key = plan.getWP(s);
+++		  	ret = ret~sprintf("PLAN,%d,%.6f,%.6f,%d,%d|",s+0,key.lat,key.lon,(key.alt_cstr_type!=nil and key.alt_cstr != nil)?key.alt_cstr:EMPTY_ALT,serializeTOS(s+1));
+++	  	}
+++	}
+++  foreach(key;stpt300) {
+++  	if (key == nil) {
+++		ret = ret~sprintf("STPT,%d,nil|",iter+300);
+++  	} else {
+++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+300,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+300));
+++    }
+++    iter += 1;
+++  }
+++  iter = 0;
+++  foreach(key;stpt350) {
+++  	if (key == nil) {
+++  		ret = ret~sprintf("STPT,%d,nil|",iter+350);
+++  	} else {
+++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+350,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+350));
+++    }
+++    iter += 1;
+++  }
+++  iter = 0;
+++  foreach(key;stpt400) {
+++  	if (key == nil) {
+++  		ret = ret~sprintf("STPT,%d,nil|",iter+400);
+++  	} else {
+++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+400,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+400));
+++    }
+++    iter += 1;
+++  }
+++  iter = 0;
+++  foreach(key;stpt450) {
+++  	if (key == nil) {
+++  		ret = ret~sprintf("STPT,%d,nil|",iter+450);
+++  	} else {
+++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+450,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+450));
+++    }
+++    iter += 1;
+++  }
+++  iter = 0;
+++  foreach(key;stpt500) {
+++  	if (key == nil) {
+++  		ret = ret~sprintf("STPT,%d,nil|",iter+500);
+++  	} else {
+++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+500,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+500));
+++    }
+++    iter += 1;
+++  }
+++  iter = 0;
+++  foreach(key;stpt555) {
+++  	if (key == nil) {
+++  		ret = ret~sprintf("STPT,%d,nil|",iter+555);
+++  	} else {
+++    	ret = ret~sprintf("STPT,%d,%.6f,%.6f,%d,%d,%d,%s,%d|",iter+555,key.lat,key.lon,key.alt,key.radius,key.color,key.type,serializeTOS(iter+555));
+++    }
+++    iter += 1;
+++  }
+++  ret = ret~sprintf("IFF,%d|",getprop("instrumentation/iff/channel-selection"));
+++  ret = ret~sprintf("DATALINK,%d|",getprop("instrumentation/datalink/channel"));
+++  ret = ret~sprintf("COM1,%.2f|",getprop("instrumentation/comm[0]/frequencies/selected-mhz"));
+++  ret = ret~sprintf("COM1S,%.2f|",getprop("instrumentation/comm[0]/frequencies/standby-mhz"));
+++  ret = ret~sprintf("COM2,%.2f|",getprop("instrumentation/comm[1]/frequencies/selected-mhz"));
+++  ret = ret~sprintf("COM2S,%.2f|",getprop("instrumentation/comm[1]/frequencies/standby-mhz"));
+++  ret = ret~sprintf("ALOW,%d|",getprop("f16/settings/cara-alow"));
+++  ret = ret~sprintf("BINGO,%d|",getprop("f16/settings/bingo"));
+++  ret = ret~sprintf("SQUAWK,%04d|",getprop("instrumentation/transponder/id-code"));
+++  return ret;
+++}
+++
+++var unserialize = func(m) {
+++  var stpts = split("|",m);
+++  var planned = nil;
+++
+++  # clear memory:
+++  lines = [nil,nil,nil,nil];
+++  stpt300 = setsize([],number_of_threat_circles);#Threat circles
+++  stpt350 = setsize([],10);#Generic
+++  stpt400 = setsize([],5);#Markpoints Own
+++  stpt450 = setsize([],5);#Markpoints DL
+++  stpt500 = setsize([],1);#Weapon
+++  stpt555 = setsize([],1);#Bullseye
+++  ded.dataEntryDisplay.page = ded.pCNI;
+++  current = nil;
+++
+++  foreach(item;stpts) {
+++    #if (size(item)>4) {#why is this chekc even here???!
+++      var items = split(",", item);
+++      var key = items[0];
+++
+++      if (key == "PLAN") {
+++      	var number = num(items[1]);
+++      	if (planned == nil) planned = createFlightplan();
+++      	var plan = planned;
+++      	var wp = createWP(num(items[2]), num(items[3]), sprintf("STPT-%02d",number+1));
+++		plan.insertWP(wp, number);
+++		if (num(items[4]) != EMPTY_ALT) {
+++			var leg = plan.getWP(plan.getPlanSize()-1);
+++			leg.setAltitude(num(items[4]), "at");
+++		}
+++		if (size(items) > 5) { # TOS is supported
+++            setNumberDesiredTOS(number+1, num(items[5]));
+++        }
+++      } elsif (key == "LINE") {
+++      	var number = num(items[1]);
+++      	var no = number >= 200;
+++      	if (number >= 700) {
+++      		no = 3;
+++      	} elsif (number >= 600) {
+++      		no = 2;
+++      	}
+++      	if (lines[no] == nil) {
+++      		lines[no] = createFlightplan();
+++      	}
+++      	var wp = createWP(num(items[2]), num(items[3]), ""~number);
+++      	number = no==1?number-200:(no==0?number-100:(no==2?number-600:number-700));
+++		lines[no].insertWP(wp, number);
+++      } elsif (key == "STPT") {
+++      	var newST = nil;
+++      	if (items[2]!="nil") {
+++      		newST = STPT.new();
+++      		newST.lat    = num(items[2]);
+++      		newST.lon    = num(items[3]);
+++      		newST.alt    = num(items[4]);
+++      		newST.radius = num(items[5]);
+++      		newST.color  = num(items[6]);
+++      		newST.type   =     items[7];
+++      	}
+++      	var number = num(items[1]);
+++      	if (number >= 555) {
+++      		stpt555[number-555] = newST;
+++
+++      	} elsif (number >= 500) {
+++      		stpt500[number-500] = newST;
+++
+++      	} elsif (number >= 450) {
+++      		stpt450[number-450] = newST;
+++      		dlMarkIndex = number-450;
+++      	} elsif (number >= 400) {
+++      		stpt400[number-400] = newST;
+++      		ownMarkIndex = number-400;
+++      	} elsif (number >= 350) {
+++      		stpt350[number-350] = newST;
+++
+++      	} elsif (number >= 300) {
+++      		stpt300[number-300] = newST;
+++      	}
+++      	if (size(items) > 8) { # TOS is supported
+++            setNumberDesiredTOS(number, num(items[8]));
+++        }
+++
+++      } elsif (key == "IFF") {
+++      	setprop("instrumentation/iff/channel-selection", num(items[1]));
+++      } elsif (key == "DATALINK") {
+++      	setprop("instrumentation/datalink/channel", num(items[1]));
+++      } elsif (key == "COM1") {
+++      	setprop("instrumentation/comm[0]/frequencies/selected-mhz", num(items[1]));
+++      } elsif (key == "COM1S") {
+++      	setprop("instrumentation/comm[0]/frequencies/standby-mhz", num(items[1]));
+++      } elsif (key == "COM2") {
+++      	setprop("instrumentation/comm[1]/frequencies/selected-mhz", num(items[1]));
+++      } elsif (key == "COM2S") {
+++      	setprop("instrumentation/comm[1]/frequencies/standby-mhz", num(items[1]));
+++      } elsif (key == "ALOW") {
+++      	setprop("f16/settings/cara-alow", num(items[1]));
+++      } elsif (key == "BINGO") {
+++      	setprop("f16/settings/bingo", num(items[1]));
+++      } elsif (key == "SQUAWK") {
+++      	setprop("instrumentation/transponder/id-code", num(items[1]));
+++      }
+++    #}
+++  }
+++  if (planned != nil) {
+++  	fgcommand("activate-flightplan", props.Node.new({"activate": 0}));
+++  	planned.activate();
+++  	fgcommand("activate-flightplan", props.Node.new({"activate": 1}));
+++  }
+++}
+++
+++var saveSTPTs = func (path) {
+++    var text = serialize();
+++    var opn = nil;
+++    call(func{opn = io.open(path,"w");},nil, var err = []);
+++    if (size(err) or opn == nil) {
+++      print("error open file for writing STPTs");
+++      gui.showDialog("savefail");
+++      return 0;
+++    }
+++    call(func{var text = io.write(opn,text);},nil, var err = []);
+++    if (size(err)) {
+++      print("error writing file with STPTs");
+++      setprop("f16/preplanning-status", err[0]);
+++      io.close(opn);
+++      gui.showDialog("savefail");
+++      return 0;
+++    } else {
+++      io.close(opn);
+++      setprop("f16/preplanning-status", "DTC data saved");
+++      return 1;
+++    }
+++}
+++
+++var loadSTPTs = func (path) {
+++    var text = nil;
+++    call(func{text=io.readfile(path);},nil, var err = []);
+++    if (size(err)) {
+++      print("Loading STPTs failed.");
+++      setprop("f16/preplanning-status", err[0]);
+++      gui.showDialog("loadfail");
+++    } elsif (text != nil) {
+++      unserialize(text);
+++      setprop("f16/preplanning-status", "DTC data loaded");
+++    }
+++}
+++
+++setprop("sim/fg-home-export", getprop("sim/fg-home")~"/Export");
++\ No newline at end of file
++diff --git a/Nasal/tacview.nas b/Nasal/tacview.nas
++new file mode 100644
++index 0000000..3090bf9
++--- /dev/null
+++++ b/Nasal/tacview.nas
++@@ -0,0 +1,437 @@
+++# Copyright by Justin Nicholson (aka Pinto)
+++# Released under the GNU General Public License version 2.0
+++#
+++# Authors: Pinto, Nikolai V. Chr., Colin Geniet
+++
+++# Short installation instructions:
+++# - Add and load this file in the 'tacview' namespace.
+++# - Adjust the four parameters just below.
+++# - Set property /payload/d-config/tacview_supported=1
+++# - Ensure the radar code sets 'tacobj' fields properly.
+++#   In Nikolai/Richard generic 'radar-system.nas',
+++#   this simply requires setting 'enable_tacobject=1'.
+++# - Add some way to start/stop recording.
+++
+++### Parameters to adjust (example values from the F-16)
+++
+++# Aircraft type string for tacview
+++var tacview_ac_type = "F-16A";
+++# Aircraft type as inserted in the output file name
+++var filename_ac_type = "f16";
+++
+++# Function returning an array of "contact" objects, containing all aicrafts tacview is to show.
+++# A contact object must
+++# - implement the API specified by missile-code.nas
+++# - have a getModel() method, which will be used as aircraft type designator in tacview.
+++# - contain a field 'tacobj', which must be an instance of the 'tacobj' class below,
+++#   and have the 'tacviewID' and 'valid' fields set appropriately.
+++#
+++var get_contacts_list = func {
+++    return radar_system.getCompleteList();
+++}
+++
+++# Function returning the focused/locked aircraft, as a "contact" object (or nil).
+++var get_primary_contact = func {
+++    return radar_system.apg68Radar.getPriorityTarget();
+++}
+++
+++# Radar range. May return nil if n/a
+++var get_radar_range_nm = func {
+++    return radar_system.apg68Radar.getRange();
+++}
+++
+++### End of parameters
+++
+++
+++var main_update_rate = 0.3;
+++var write_rate = 10;
+++
+++var outstr = "";
+++
+++var timestamp = "";
+++var output_file = "";
+++var f = "";
+++var myplaneID = int(rand()*10000);
+++var starttime = 0;
+++var writetime = 0;
+++
+++var seen_ids = [];
+++
+++var tacobj = {
+++    tacviewID: 0,
+++    lat: 0,
+++    lon: 0,
+++    alt: 0,
+++    roll: 0,
+++    pitch: 0,
+++    heading: 0,
+++    speed: -1,
+++    valid: 0,
+++};
+++
+++var lat = 0;
+++var lon = 0;
+++var alt = 0;
+++var roll = 0;
+++var pitch = 0;
+++var heading = 0;
+++var speed = 0;
+++var mutexWrite = thread.newlock();
+++
+++var input = {
+++    mp_host:    "sim/multiplay/txhost",
+++    radar:      "sim/multiplay/generic/int[2]",
+++    fuel:       "consumables/fuel/total-fuel-lbs",
+++    gear:       "gear/gear[0]/position-norm",
+++    lat:        "position/latitude-deg",
+++    lon:        "position/longitude-deg",
+++    alt:        "position/altitude-ft",
+++    roll:       "orientation/roll-deg",
+++    pitch:      "orientation/pitch-deg",
+++    heading:    "orientation/heading-deg",
+++    tas:        "fdm/jsbsim/velocities/vtrue-kts",
+++    cas:        "velocities/airspeed-kt",
+++    mach:       "velocities/mach",
+++    aoa:        "orientation/alpha-deg",
+++    gforce:     "accelerations/pilot-g",
+++};
+++
+++foreach (var name; keys(input)) {
+++    input[name] = props.globals.getNode(input[name], 1);
+++}
+++
+++
+++var startwrite = func() {
+++    if (starttime)
+++        return;
+++
+++    timestamp = getprop("/sim/time/utc/year") ~ "-" ~ getprop("/sim/time/utc/month") ~ "-" ~ getprop("/sim/time/utc/day") ~ "T";
+++    timestamp = timestamp ~ getprop("/sim/time/utc/hour") ~ ":" ~ getprop("/sim/time/utc/minute") ~ ":" ~ getprop("/sim/time/utc/second") ~ "Z";
+++    var filetimestamp = string.replace(timestamp,":","-");
+++    output_file = getprop("/sim/fg-home") ~ "/Export/tacview-" ~ filename_ac_type ~ "-" ~ filetimestamp ~ ".acmi";
+++    # create the file
+++    f = io.open(output_file, "w");
+++    io.close(f);
+++    var color = ",Color=Blue";
+++    if (left(getprop("sim/multiplay/callsign"),5)=="OPFOR") {
+++        color=",Color=Red";
+++    }
+++    var meta = sprintf(",DataSource=FlightGear %s,DataRecorder=%s v%s", getprop("sim/version/flightgear"), getprop("sim/description"), getprop("sim/aircraft-version"));
+++    thread.lock(mutexWrite);
+++    write("FileType=text/acmi/tacview\nFileVersion=2.1\n");
+++    write("0,ReferenceTime=" ~ timestamp ~ meta ~ "\n#0\n");
+++    write(myplaneID ~ ",T=" ~ getLon() ~ "|" ~ getLat() ~ "|" ~ getAlt() ~ "|" ~ getRoll() ~ "|" ~ getPitch() ~ "|" ~ getHeading() ~ ",Name="~tacview_ac_type~",CallSign="~getprop("/sim/multiplay/callsign")~color~"\n"); #
+++    thread.unlock(mutexWrite);
+++    starttime = systime();
+++    setprop("/sim/screen/black","Starting Tacview recording");
+++    main_timer.start();
+++}
+++
+++var stopwrite = func() {
+++    main_timer.stop();
+++    setprop("/sim/screen/black","Stopping Tacview recording");
+++    writetofile();
+++    starttime = 0;
+++    seen_ids = [];
+++    explo_arr = [];
+++    explosion_timeout_loop(1);
+++}
+++
+++var mainloop = func() {
+++    if (!starttime) {
+++        main_timer.stop();
+++        return;
+++    }
+++    if (systime() - writetime > write_rate) {
+++        writetofile();
+++    }
+++    thread.lock(mutexWrite);
+++    write("#" ~ (systime() - starttime)~"\n");
+++    thread.unlock(mutexWrite);
+++    writeMyPlanePos();
+++    writeMyPlaneAttributes();
+++    foreach (var cx; get_contacts_list()) {
+++        if(cx.get_type() == armament.ORDNANCE) {
+++            continue;
+++        }
+++        if (cx["prop"] != nil and cx.prop.getName() == "multiplayer" and input.mp_host.getValue() == "mpserver.opredflag.com") {
+++            continue;
+++        }
+++        var color = ",Color=Blue";
+++        if (left(cx.get_Callsign(),5)=="OPFOR" or left(cx.get_Callsign(),4)=="OPFR") {
+++            color=",Color=Red";
+++        }
+++        thread.lock(mutexWrite);
+++        if (find_in_array(seen_ids, cx.tacobj.tacviewID) == -1) {
+++            append(seen_ids, cx.tacobj.tacviewID);
+++            var model_is = cx.getModel();
+++            if (model_is=="Mig-28") {
+++                model_is = tacview_ac_type;
+++                color=",Color=Red";
+++            }
+++            write(cx.tacobj.tacviewID ~ ",Name="~ model_is~ ",CallSign=" ~ cx.get_Callsign() ~color~"\n")
+++        }
+++        if (cx.tacobj.valid) {
+++            var cxC = cx.getCoord();
+++            lon = cxC.lon();
+++            lat = cxC.lat();
+++            alt = cxC.alt();
+++            roll = cx.get_Roll();
+++            pitch = cx.get_Pitch();
+++            heading = cx.get_heading();
+++            speed = cx.get_Speed()*KT2MPS;
+++
+++            write(cx.tacobj.tacviewID ~ ",T=");
+++            if (lon != cx.tacobj.lon) {
+++                write(sprintf("%.6f",lon));
+++                cx.tacobj.lon = lon;
+++            }
+++            write("|");
+++            if (lat != cx.tacobj.lat) {
+++                write(sprintf("%.6f",lat));
+++                cx.tacobj.lat = lat;
+++            }
+++            write("|");
+++            if (alt != cx.tacobj.alt) {
+++                write(sprintf("%.1f",alt));
+++                cx.tacobj.alt = alt;
+++            }
+++            write("|");
+++            if (roll != cx.tacobj.roll) {
+++                write(sprintf("%.1f",roll));
+++                cx.tacobj.roll = roll;
+++            }
+++            write("|");
+++            if (pitch != cx.tacobj.pitch) {
+++                write(sprintf("%.1f",pitch));
+++                cx.tacobj.pitch = pitch;
+++            }
+++            write("|");
+++            if (heading != cx.tacobj.heading) {
+++                write(sprintf("%.1f",heading));
+++                cx.tacobj.heading = heading;
+++            }
+++            if (speed != cx.tacobj.speed) {
+++                write(sprintf(",TAS=%.1f",speed));
+++                cx.tacobj.speed = speed;
+++            }
+++            write("\n");
+++        }
+++        thread.unlock(mutexWrite);
+++    }
+++    explosion_timeout_loop();
+++}
+++
+++var main_timer = maketimer(main_update_rate, mainloop);
+++
+++
+++var writeMyPlanePos = func() {
+++    thread.lock(mutexWrite);
+++    write(myplaneID ~ ",T=" ~ getLon() ~ "|" ~ getLat() ~ "|" ~ getAlt() ~ "|" ~ getRoll() ~ "|" ~ getPitch() ~ "|" ~ getHeading() ~ "\n");
+++    thread.unlock(mutexWrite);
+++}
+++
+++var writeMyPlaneAttributes = func() {
+++    var tgt = "";
+++    var contact = get_primary_contact();
+++    if (contact != nil) {
+++        tgt= ",FocusedTarget="~contact.tacobj.tacviewID;
+++    }
+++    var rmode = ",RadarMode=1";
+++    if (input.radar.getBoolValue()) {
+++        rmode = ",RadarMode=0";
+++    }
+++    var rrange = get_radar_range_nm();
+++    if (rrange != nil) {
+++        rrange = sprintf(",RadarRange=%.0f", get_radar_range_nm()*NM2M);
+++    } else {
+++        rrange = "";
+++    }
+++    var fuel = sprintf(",FuelWeight=%.0f", input.fuel.getValue());
+++    var gear = sprintf(",LandingGear=%.2f", input.gear.getValue());
+++    var tas = getTas();
+++    if (tas != nil) {
+++        tas = ",TAS="~tas;
+++    } else {
+++        tas = "";
+++    }
+++    var str = myplaneID ~ fuel~rmode~rrange~gear~tas~",CAS="~getCas()~",Mach="~getMach()~",AOA="~getAoA()~",HDG="~getHeading()~tgt~",VerticalGForce="~getG()~"\n";#",Throttle="~getThrottle()~",Afterburner="~getAfterburner()~
+++    thread.lock(mutexWrite);
+++    write(str);
+++    thread.unlock(mutexWrite);
+++}
+++
+++var explo = {
+++    tacviewID: 0,
+++    time: 0,
+++};
+++
+++var explo_arr = [];
+++
+++# needs threadlocked before calling
+++var writeExplosion = func(lat,lon,altm,rad) {
+++    var e = {parents:[explo]};
+++    e.tacviewID = 21000 + int(math.floor(rand()*20000));
+++    e.time = systime();
+++    append(explo_arr, e);
+++    write("#" ~ (systime() - starttime)~"\n");
+++    write(e.tacviewID ~",T="~lon~"|"~lat~"|"~altm~",Radius="~rad~",Type=Explosion\n");
+++}
+++
+++var explosion_timeout_loop = func(all = 0) {
+++    foreach(var e; explo_arr) {
+++        if (e.time) {
+++            if (systime() - e.time > 15 or all) {
+++                thread.lock(mutexWrite);
+++                write("#" ~ (systime() - starttime)~"\n");
+++                write("-"~e.tacviewID);
+++                thread.unlock(mutexWrite);
+++                e.time = 0;
+++            }
+++        }
+++    }
+++}
+++
+++var write = func(str) {
+++    outstr = outstr ~ str;
+++}
+++
+++var writetofile = func() {
+++    if (outstr == "") {
+++        return;
+++    }
+++    writetime = systime();
+++    f = io.open(output_file, "a");
+++    io.write(f, outstr);
+++    io.close(f);
+++    outstr = "";
+++}
+++
+++var getLat = func() {
+++    return input.lat.getValue();
+++}
+++
+++var getLon = func() {
+++    return input.lon.getValue();
+++}
+++
+++var getAlt = func() {
+++    return sprintf("%.2f", input.alt.getValue() * FT2M);
+++}
+++
+++var getRoll = func() {
+++    return sprintf("%.2f", input.roll.getValue());
+++}
+++
+++var getPitch = func() {
+++    return sprintf("%.2f", input.pitch.getValue());
+++}
+++
+++var getHeading = func() {
+++    return sprintf("%.2f", input.heading.getValue());
+++}
+++
+++var getTas = func() {
+++    var tas = input.tas.getValue();
+++    if (tas != nil)
+++        return sprintf("%.1f", tas * KT2MPS);
+++    else
+++        return nil;
+++}
+++
+++var getCas = func() {
+++    return sprintf("%.1f", input.cas.getValue() * KT2MPS);
+++}
+++
+++var getMach = func() {
+++    return sprintf("%.3f", input.mach.getValue());
+++}
+++
+++var getAoA = func() {
+++    return sprintf("%.2f", input.aoa.getValue());
+++}
+++
+++var getG = func() {
+++    return sprintf("%.2f", input.gforce.getValue());
+++}
+++
+++#var getThrottle = func() {
+++#    return sprintf("%.2f", getprop("velocities/thrust");
+++#}
+++
+++#var getAfterburner = func() {
+++#    return getprop("velocities/thrust")>0.61*0.61;
+++#}
+++
+++var find_in_array = func(arr,val) {
+++    forindex(var i; arr) {
+++        if ( arr[i] == val ) {
+++            return i;
+++        }
+++    }
+++    return -1;
+++}
+++
+++#setlistener("/controls/armament/pickle", func() {
+++#    if (!starttime) {
+++#        return;
+++#    }
+++#    thread.lock(mutexWrite);
+++#    write("#" ~ (systime() - starttime)~"\n");
+++#    write("0,Event=Message|"~ myplaneID ~ "|Pickle, selection at " ~ (getprop("controls/armament/pylon-knob") + 1) ~ "\n");
+++#    thread.unlock(mutexWrite);
+++#},0,0);
+++
+++setlistener("/controls/armament/trigger", func(p) {
+++    if (!starttime) {
+++        return;
+++    }
+++    thread.lock(mutexWrite);
+++    if (p.getValue()) {
+++        write("#" ~ (systime() - starttime)~"\n");
+++        write("0,Event=Message|"~ myplaneID ~ "|Trigger pressed.\n");
+++    } else {
+++        write("#" ~ (systime() - starttime)~"\n");
+++        write("0,Event=Message|"~ myplaneID ~ "|Trigger released.\n");
+++    }
+++    thread.unlock(mutexWrite);
+++},0,0);
+++
+++setlistener("/sim/multiplay/chat-history", func(p) {
+++    if (!starttime) {
+++        return;
+++    }
+++    var hist_vector = split("\n",p.getValue());
+++    if (size(hist_vector) > 0) {
+++        var last = hist_vector[size(hist_vector)-1];
+++        last = string.replace(last,",",chr(92)~chr(44));#"\x5C"~"\x2C"
+++        thread.lock(mutexWrite);
+++        write("#" ~ (systime() - tacview.starttime)~"\n");
+++        write("0,Event=Message|Chat ["~last~"]\n");
+++        thread.unlock(mutexWrite);
+++    }
+++},0,0);
+++
+++
+++var msg = func (txt) {
+++    if (!starttime) {
+++        return;
+++    }
+++    thread.lock(mutexWrite);
+++    write("#" ~ (systime() - tacview.starttime)~"\n");
+++    write("0,Event=Message|"~myplaneID~"|AI ["~txt~"]\n");
+++    thread.unlock(mutexWrite);
+++}
+++
+++setlistener("damage/sounds/explode-on", func(p) {
+++    if (!starttime) {
+++        return;
+++    }
+++
+++    if (p.getValue()) {
+++        thread.lock(mutexWrite);
+++        write("#" ~ (systime() - tacview.starttime)~"\n");
+++        write("0,Event=Destroyed|"~myplaneID~"\n");
+++        thread.unlock(mutexWrite);
+++    }
+++},0,0);
++diff --git a/Nasal/tgp.nas b/Nasal/tgp.nas
++new file mode 100644
++index 0000000..36a168e
++--- /dev/null
+++++ b/Nasal/tgp.nas
++@@ -0,0 +1,977 @@
+++# Copyright (C) 2016  onox
+++#
+++# This program is free software: you can redistribute it and/or modify
+++# it under the terms of the GNU General Public License as published by
+++# the Free Software Foundation; either version 2 of the License, or
+++# (at your option) any later version.
+++#
+++# This program is distributed in the hope that it will be useful,
+++# but WITHOUT ANY WARRANTY; without even the implied warranty of
+++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+++# GNU General Public License for more details.
+++#
+++# You should have received a copy of the GNU General Public License
+++# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+++#
+++# Lines below FLIRCameraUpdater has been modified/added by Nikolai V. Chr.
+++#
+++# Position of the FLIR camera ([z (back), x (right), y (up)])
+++var coords_cam = [
+++    getprop("/sim/view[105]/config/z-offset-m"),
+++    getprop("/sim/view[105]/config/x-offset-m"),
+++    getprop("/sim/view[105]/config/y-offset-m")
+++];
+++io.include("Aircraft/Generic/updateloop.nas");
+++#io.load_nasal(getprop("/sim/fg-root") ~ "/Aircraft/c172p/Nasal/generic/math_ext2.nas","math_ext2");
+++var FLIRCameraUpdater = {
+++
+++    new: func {
+++        var m = {
+++            parents: [FLIRCameraUpdater, Updatable]
+++        };
+++        m.loop = UpdateLoop.new(components: [m], update_period: 0.0);
+++
+++        # Create a function to update the position of the FLIR camera
+++        m.update_cam = me._get_flir_auto_updater(180.0);
+++
+++        # Create a function to update the position using an input device
+++        m.manual_update_cam = me._get_flir_updater(180.0, m.update_cam);
+++
+++        m.click_coord_cam = nil;
+++
+++        m.listeners = std.Vector.new();
+++
+++        m.offsetP = 0;
+++        m.offsetH = 0;
+++
+++        return m;
+++    },
+++
+++    enable: func {
+++        #me.loop.reset();
+++        me.loop.enable();
+++    },
+++
+++    disable: func {
+++        #me.remove_listeners();
+++        me.loop.disable();
+++    },
+++
+++    enable_or_disable: func (enable) {
+++        if (enable) {
+++            me.enable();
+++        }
+++        else {
+++            me.disable();
+++        }
+++    },
+++
+++    remove_listeners: func {
+++        foreach (var listener; me.listeners.vector) {
+++            removelistener(listener);
+++        }
+++        me.listeners.clear();
+++    },
+++
+++    reset: func {
+++        #print("reset called?!?!");
+++        return;
+++        me.remove_listeners();
+++        me.listeners.append(setlistener("/sim/signals/click", func {
+++            var lat = getprop("/sim/input/click/latitude-deg");
+++            var lon = getprop("/sim/input/click/longitude-deg");
+++            var elev = getprop("/sim/input/click/elevation-m");
+++
+++            var click_position = geo.Coord.new().set_latlon(lat, lon, elev);
+++
+++            var origin_position = geo.aircraft_position();
+++            var distance_m = origin_position.direct_distance_to(click_position);
+++
+++            if (getprop("/aircraft/flir/locks/auto-track")) {
+++                me.click_coord_cam = click_position;
+++                setprop("/aircraft/flir/target/auto-track", 1);
+++                logger.screen.white(sprintf("New tracking position at %d meter distance", distance_m));
+++            }
+++            else {
+++                setprop("/aircraft/flir/target/auto-track", 0);
+++                me.click_coord_cam = nil;
+++                logger.screen.red("Press F6 to enable automatic tracking by FLIR camera");
+++            }
+++        }));
+++
+++        me.listeners.append(setlistener("/aircraft/flir/locks/auto-track", func (n) {
+++            setprop("/aircraft/flir/target/auto-track", 0);
+++            me.click_coord_cam = nil;
+++            if (n.getBoolValue()) {
+++                logger.screen.green("Automatic tracking by FLIR camera enabled. Click on the terrain to start tracking.");
+++            }
+++            else {
+++                logger.screen.red("Automatic tracking by FLIR camera disabled");
+++            }
+++        }));
+++    },
+++
+++    update: func (dt) {
+++        var roll_deg  = getprop("/orientation/roll-deg");
+++        var pitch_deg = getprop("/orientation/pitch-deg");
+++        var heading   = getprop("/orientation/heading-deg");
+++
+++        var computer = me._get_flir_computer(roll_deg, pitch_deg, heading);
+++
+++        if (getprop("/aircraft/flir/target/auto-track") and me.click_coord_cam != nil) {
+++
+++            var (yaw, pitch, distance) = computer(coords_cam, me.click_coord_cam);
+++            #printf("C %.5f,%.5f,%.5f",me.click_coord_cam.lat(),me.click_coord_cam.lon(),me.click_coord_cam.alt());
+++            if (lock_tgp) {
+++                #print("L");
+++                me.update_cam(roll_deg, pitch_deg, yaw, pitch);
+++            } else {
+++                #print("NO      LLLLLLLLLLL");
+++                me.update_cam(roll_deg, pitch_deg, yaw+me.offsetH, pitch+me.offsetP);
+++            }
+++        }
+++#        else {
+++#            me.manual_update_cam(roll_deg, pitch_deg);
+++#        }
+++    },
+++
+++    aim: func () {
+++        var roll_deg  = getprop("/orientation/roll-deg");
+++        var pitch_deg = getprop("/orientation/pitch-deg");
+++        var heading   = getprop("/orientation/heading-deg");
+++
+++        var computer = me._get_flir_computer(roll_deg, pitch_deg, heading);
+++
+++        if (getprop("/sim/current-view/name") == "TGP" and me.click_coord_cam != nil) {
+++            #printf("B %.5f,%.5f,%.5f",me.click_coord_cam.lat(),me.click_coord_cam.lon(),me.click_coord_cam.alt());
+++            me.click_coord_cam.lat();
+++            var (yaw, pitch, distance) = computer(coords_cam, me.click_coord_cam);
+++            me.update_cam(roll_deg, pitch_deg, yaw, pitch);
+++        }
+++    },
+++
+++    ######################################################################
+++    # Gyro stabilization                                                 #
+++    ######################################################################
+++
+++    _get_flir_updater: func (offset, updater) {
+++        return func (roll_deg, pitch_deg) {
+++            var yaw   = getprop("/aircraft/flir/input/yaw-deg") + (180.0 - offset);
+++            var pitch = getprop("/aircraft/flir/input/pitch-deg");
+++
+++            updater(roll_deg, pitch_deg, yaw, pitch);
+++        };
+++    },
+++
+++    ######################################################################
+++    # Automatic tracking computation                                     #
+++    ######################################################################
+++
+++    _get_flir_auto_updater: func (offset) {
+++        return func (roll_deg, pitch_deg, yaw, pitch) {
+++            (yaw, pitch) = math_ext2.get_yaw_pitch_body(roll_deg, pitch_deg, yaw, pitch, offset);
+++
+++            setprop("/aircraft/flir/target/yaw-deg", yaw);
+++            setprop("/aircraft/flir/target/pitch-deg", pitch);
+++            if (getprop("/sim/current-view/name") == "TGP") {
+++                setprop("/sim/current-view/goal-heading-offset-deg", -yaw);
+++                setprop("/sim/current-view/goal-pitch-offset-deg", pitch);
+++            }
+++            setprop("sim/view[105]/heading-offset-deg", yaw);
+++            setprop("sim/view[105]/pitch-offset-deg", pitch);
+++        };
+++    },
+++
+++    _get_flir_computer: func (roll_deg, pitch_deg, heading) {
+++        return func (coords, target) {
+++            var (position_2d, position) = math_ext2.get_point(coords[0], coords[1], coords[2], roll_deg, pitch_deg, heading);
+++            return get_yaw_pitch_distance_inert(position_2d, position, target, heading);
+++        }
+++    }
+++
+++};
+++
+++get_yaw_pitch_distance_inert = func (position_2d, position, target_position, heading, f=nil) {
+++    # Does the same as Onox's version, except takes curvature of Earth into account.
+++    #printf("A %.5f,%.5f,%.5f",target_position.lat(),target_position.lon(),target_position.alt());
+++    target_position.lat();
+++    var heading_deg = positioned.courseAndDistance(position_2d, target_position)[0] - heading;
+++    var pitch_deg   = vector.Math.getPitch(position, target_position);
+++    var distance_m  = position.direct_distance_to(target_position);
+++    return [heading_deg, pitch_deg, distance_m];
+++}
+++
+++var flir_updater = FLIRCameraUpdater.new();
+++
+++setlistener("/sim/signals/fdm-initialized", func {
+++    setlistener("/aircraft/flir/target/view-enabled", func (node) {
+++        flir_updater.enable_or_disable(node.getBoolValue());
+++    }, 1, 0);
+++});
+++
+++var steerlock = 0;
+++var enable = 1;
+++var camera_movement_speed_lock = 75;#Higher number means slower
+++var camera_movement_speed_free =  5;
+++
+++var list = func (node) {
+++    var button = getprop("controls/MFD[2]/button-pressed");
+++
+++    if (button == 20) {#BACK
+++        view.setViewByIndex(0);
+++        #setprop("/aircraft/flir/target/auto-track", 0);
+++        #lock.hide();
+++        #setprop("f16/avionics/lock-flir",0.05);
+++        return;
+++    } elsif (button == 3) {#STBY/A-G/A-A
+++        if (getprop("f16/avionics/power-mfd") and getprop("f16/avionics/power-ufc-warm")==1 and getprop("f16/avionics/power-right-hdpt") == 1 and getprop("fdm/jsbsim/elec/bus/ess-dc") > 20) {
+++            masterMode = !masterMode;
+++        }
+++    }
+++    if (!enable) return;
+++
+++    if (button == 0 and node.getName() == "button-pressed") {
+++        setprop("controls/displays/cursor-slew-x", 0);
+++        setprop("controls/displays/cursor-slew-y", 0);
+++    }
+++
+++    if (button == 1 or (getprop("controls/displays/cursor-click") and getprop("/sim/current-view/name") == "TGP")) {#LOCK
+++        gps = 0;
+++        if (lock_tgp) {
+++            lock_tgp = 0;
+++            armament.contactPoint = nil;print("Second click with TGP lock unlocks!");
+++            return;
+++        }
+++        var x = -2.5856;
+++        var y =  0.8536;
+++        var z = -1.4121;
+++        var pos = aircraftToCart({x:-x, y:y, z: -z});
+++        var coordA = geo.Coord.new();
+++        coordA.set_xyz(pos.x, pos.y, pos.z);
+++        coordA.alt();# TODO: once fixed in FG this line is no longer needed.
+++        var matrixMath = 0;
+++        if (matrixMath) {
+++            var dirCoord = geo.Coord.new(coordA);
+++            var vHead = getprop("sim/current-view/heading-offset-deg");
+++            var vPitch = getprop("sim/current-view/pitch-offset-deg");
+++
+++            var vectorF = vector.Math.eulerToCartesian3X(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
+++            var vectorL = vector.Math.eulerToCartesian3Y(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
+++            var vectorU = vector.Math.eulerToCartesian3Z(-getprop("orientation/heading-deg"),getprop("orientation/pitch-deg"),getprop("orientation/roll-deg"));
+++            var viewM   = vector.Math.viewMatrix(vectorF,vectorL,vectorU);
+++            var pitchM = vector.Math.pitchMatrix(vPitch);
+++            var yawM   = vector.Math.yawMatrix(-vHead);
+++            var rotation = vector.Math.multiplyMatrices(pitchM, yawM);#heading, pitch
+++            var viewGlobal = vector.Math.multiplyMatrices4(viewM, vector.Math.to4x4(rotation));#order?
+++            #viewGlobal = vector.Math.multiplyMatrices4(viewGlobal,vector.Math.mirrorMatrix);
+++            #var vectorA = [viewGlobal[2],viewGlobal[6],viewGlobal[10]];
+++            var vectorA = vector.Math.normalize(vector.Math.xFromView(viewGlobal));
+++            #vectorA = vector.Math.multiplyMatrixWithVector(rotation, vectorF);
+++            print(vector.Math.format(vectorA));
+++            var set = vector.Math.cartesianToEuler(vectorA);
+++
+++            #if (set[0] == nil) {print("0 heading");return;}
+++            #printf("%d heading %d pitch",set[0],set[1]);
+++            dirCoord.apply_course_distance(set[0],50);
+++            var up = math.tan(set[1]*D2R)*50;
+++            dirCoord.set_alt(coordA.alt()+up);
+++        }
+++
+++        # get quaternion for view rotation:
+++        var q = [getprop("sim/current-view/debug/orientation-w"),getprop("sim/current-view/debug/orientation-x"),getprop("sim/current-view/debug/orientation-y"),getprop("sim/current-view/debug/orientation-z")];
+++
+++        var V = [2 * (q[1] * q[3] - q[0] * q[2]), 2 * (q[2] * q[3] + q[0] * q[1]),1 - 2 * (q[1] * q[1] + q[2] * q[2])];
+++        var w= q[0];
+++        var x= q[1];
+++        var y= q[2];
+++        var z= q[3];
+++
+++        #rotate from x axis using the quaternion:
+++        V = [1 - 2 * (y*y + z*z),2 * (x*y + w*z),2 * (x*z - w*y)];
+++
+++        var xyz          = {"x":coordA.x(),                "y":coordA.y(),               "z":coordA.z()};
+++        #var directionLOS = {"x":dirCoord.x()-coordA.x(),   "y":dirCoord.y()-coordA.y(),  "z":dirCoord.z()-coordA.z()};
+++        var directionLOS = {"x":V[0],   "y":V[1],  "z":V[2]};
+++
+++        # Check for terrain between own weapon and target:
+++        var terrainGeod = get_cart_ground_intersection(xyz, directionLOS);
+++        if (terrainGeod == nil) {
+++            #print("0 terrain");
+++            return;
+++        } else {
+++            var terrain = geo.Coord.new();
+++            terrain.set_latlon(terrainGeod.lat, terrainGeod.lon, terrainGeod.elevation);
+++            var ut = nil;
+++            foreach (u ; radar_system.getCompleteList()) {
+++                if (terrain.direct_distance_to(u.get_Coord())<45) {
+++                    ut = u;
+++                    break;
+++                }
+++            }
+++            if (ut!=nil) {
+++                var contact = ut.getNearbyVirtualTGPContact();
+++                armament.contactPoint = contact;
+++                #var tc = contact.getCoord();
+++                #print("contactPoint "~tc.lat()~", "~tc.lon()~" at "~(tc.alt()*M2FT)~" ft");
+++            } else {
+++                armament.contactPoint = radar_system.ContactTGP.new("TGP-Spot",terrain,1);
+++            }
+++            #flir_updater.click_coord_cam = terrain;
+++            #setprop("/aircraft/flir/target/auto-track", 1);
+++            #interpolate("f16/avionics/lock-flir",1,1.5);
+++            #flir_updater.offsetP = 0;
+++            #flir_updater.offsetH = 0;# commented so we get back to where we were when unlocking
+++            lock_tgp = 1;
+++        }
+++    } elsif (button == 6) {#TV/IR
+++        ir = !ir;
+++    } elsif (button == 9) {#CZ
+++        if (lock_tgp) return;
+++        gps = 0;
+++        if (getprop("/aircraft/flir/target/auto-track")) {
+++            flir_updater.offsetP = 0;
+++            flir_updater.offsetH = 0;
+++        } else {
+++            interpolate("sim/current-view/pitch-offset-deg", -30, 2.5);
+++            interpolate("sim/current-view/heading-offset-deg", 0, 2.5);
+++        }
+++    } elsif (button == 10) {#MARK
+++        if (!lock_tgp or armament.contactPoint == nil) return;
+++        line10.setText("#"~steerpoints.markTGP(armament.contactPoint.get_Coord()));
+++        settimer(func {line10.setText("MARK");}, 2.5);
+++    } elsif (button == 11) {#UP
+++        if (lock_tgp) return;
+++        gps = 0;
+++        setprop("controls/displays/cursor-slew-y", -1);
+++        return;
+++        var fov = getprop("sim/current-view/field-of-view");
+++        if (getprop("/aircraft/flir/target/auto-track")) {
+++            flir_updater.offsetP += fov/camera_movement_speed_lock;
+++        } else {
+++            setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")+fov/camera_movement_speed_free);
+++        }
+++    } elsif (button == 12) {#DOWN
+++        if (lock_tgp) return;
+++        gps = 0;
+++        setprop("controls/displays/cursor-slew-y", 1);
+++        return;
+++        var fov = getprop("sim/current-view/field-of-view");
+++        if (getprop("/aircraft/flir/target/auto-track")) {
+++            flir_updater.offsetP -= fov/camera_movement_speed_lock;
+++        } else {
+++            setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")-fov/camera_movement_speed_free);
+++        }
+++    } elsif (button == 14) {#LEFT
+++        if (lock_tgp) return;
+++        gps = 0;
+++        setprop("controls/displays/cursor-slew-x", -1);
+++        return;
+++        var fov = getprop("sim/current-view/field-of-view");
+++        if (getprop("/aircraft/flir/target/auto-track")) {
+++            flir_updater.offsetH -= fov/camera_movement_speed_lock;
+++        } else {
+++            setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")+fov/camera_movement_speed_free);
+++        }
+++    } elsif (button == 15) {#RGHT
+++        if (lock_tgp) return;
+++        gps = 0;
+++        setprop("controls/displays/cursor-slew-x", 1);
+++        return;
+++        var fov = getprop("sim/current-view/field-of-view");
+++        if (getprop("/aircraft/flir/target/auto-track")) {
+++            flir_updater.offsetH += fov/camera_movement_speed_lock;
+++        } else {
+++            setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")-fov/camera_movement_speed_free);
+++        }
+++    } elsif (button == 13) {#WIDE/NARO
+++        wide = !wide;
+++    } elsif (button == 2) {#ZOOM
+++        zoomlvl += 1;
+++        if (zoomlvl > 4) {
+++            zoomlvl = 1;
+++        }
+++    }
+++};
+++setlistener("controls/MFD[2]/button-pressed", list);
+++setlistener("controls/displays/cursor-click", list);
+++
+++
+++var flyupTime = 0;
+++var flyupVis = 0;
+++
+++var fast_loop = func {
+++  var viewName = getprop("/sim/current-view/name");
+++
+++    if (viewName == "TGP" and (getprop("/fdm/jsbsim/gear/unit[0]/WOW") or !getprop("f16/stores/tgp-mounted"))) {
+++        # deselect view back to pilot default
+++        masterMode = STBY;
+++        view.setViewByIndex(0);
+++        setprop("sim/rendering/als-filters/use-IR-vision", 0);
+++        setprop("sim/view[105]/enabled", 0);
+++        pullup_cue_3.setVisible(0);
+++    } elsif (viewName == "TGP") {
+++        if (!getprop("f16/avionics/power-mfd") or getprop("f16/avionics/power-ufc-warm")!=1) {
+++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+++            midl.setText("    MFD OFF   ");
+++            bott.setText("");
+++            ralt.setText("");
+++            line9.hide();
+++            line10.hide();
+++            line3.setText("");
+++            cross.hide();
+++            enable = 0;
+++            masterMode = STBY;
+++            pullup_cue_3.setVisible(0);
+++        } elsif (getprop("f16/avionics/power-right-hdpt") == 0 or getprop("fdm/jsbsim/elec/bus/ess-dc") <=20) {
+++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+++            midl.setText("      OFF     ");
+++            bott.setText("");
+++            ralt.setText("");
+++            line9.hide();
+++            line10.hide();
+++            line3.setText("");
+++            cross.hide();
+++            enable = 0;
+++            masterMode = STBY;
+++            pullup_cue_3.setVisible(0);
+++        } elsif (getprop("f16/avionics/power-right-hdpt-warm") < 1) {
+++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+++
+++            var to_secs = (1.0-getprop("/f16/avionics/power-right-hdpt-warm"))*180;
+++            var mins = int(to_secs/60);
+++            var secs = to_secs-mins*60;
+++            var ttxt = sprintf(" %1d:%02d ", mins, secs);
+++            midl.setText("NOT TIMED OUT");
+++            bott.setText(ttxt);
+++            ralt.setText("");
+++            line9.hide();
+++            line10.hide();
+++            line3.setText(masterMode==0?"STBY":(hiddenMode==AG?"A-G":"A-A"));
+++            cross.hide();
+++            enable = 0;
+++            pullup_cue_3.setVisible(0);
+++        } elsif (masterMode == STBY) {
+++            canvasMFDext.setColorBackground(0.00, 0.00, 0.00, 1.00);
+++            midl.setText("   STANDBY   ");
+++            bott.setText("");
+++            ralt.setText("");
+++            line9.hide();
+++            line10.hide();
+++            line3.setText("STBY");
+++            cross.hide();
+++            enable = 0;
+++            flyupTime = getprop("instrumentation/radar/time-till-crash");
+++            if (flyupTime != nil and flyupTime > 0 and flyupTime < 8) {
+++                flyupVis = math.mod(getprop("sim/time/elapsed-sec"), 0.50) < 0.25;
+++            } else {
+++                flyupVis = 0;
+++            }
+++            pullup_cue_3.setVisible(flyupVis);
+++        } else {
+++            canvasMFDext.setColorBackground(1.00, 1.00, 1.00, 0.00);
+++            line3.setText(hiddenMode==AG?"A-G":"A-A");
+++            cross.show();
+++            enable = 1;
+++            flyupTime = getprop("instrumentation/radar/time-till-crash");
+++            if (flyupTime != nil and flyupTime > 0 and flyupTime < 8) {
+++                flyupVis = math.mod(getprop("sim/time/elapsed-sec"), 0.50) < 0.25;
+++            } else {
+++                flyupVis = 0;
+++            }
+++            pullup_cue_3.setVisible(flyupVis);
+++        }
+++
+++        # FLIR TGP stuff:
+++        setprop("aircraft/flir/target/view-enabled", viewName == "TGP");
+++        setprop("sim/rendering/als-filters/use-filtering", viewName == "TGP");
+++        setprop("sim/rendering/als-filters/use-IR-vision", viewName == "TGP" and ir);
+++        setprop("sim/rendering/als-filters/use-night-vision", 0);
+++
+++        var x = getprop("sim/gui/canvas/size[0]");
+++        var y = getprop("sim/gui/canvas/size[1]");
+++
+++        var degs = 3.6/zoomlvl;
+++        if (wide) {
+++            line13.setText("WIDE");
+++        } else {
+++            degs = 1.0/zoomlvl;
+++            line13.setText("NARO");
+++        }
+++        var fov = degs*(x/y);
+++        var format = (x/y)/2.25;#16/9 = 1.777
+++        var scale = format*20/fov;# we take into account that different pilots have different screen formats so the height of the MFD in screen stays same relative.
+++        setprop("sim/current-view/field-of-view-scale",scale);
+++        setprop("sim/current-view/field-of-view",fov);
+++
+++        zoom.setText(sprintf("%.1fX",zoomlvl));
+++
+++        line6.setText(ir==1?"WHOT":"TV");
+++
+++        if (enable) {
+++            lasercode = getprop("f16/avionics/laser-code");
+++            if (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil) {
+++                var dist = flir_updater.click_coord_cam.direct_distance_to(geo.aircraft_position())*M2NM;
+++                bott.setText(sprintf("%2.1f  CMBT  %04d",dist,lasercode));
+++                lat.setText(ded.convertDegreeToStringLat(flir_updater.click_coord_cam.lat()));
+++                lon.setText(ded.convertDegreeToStringLon(flir_updater.click_coord_cam.lon()));
+++            } else {
+++                bott.setText(sprintf("      CMBT  %04d",lasercode));
+++                lat.setText("");
+++                lon.setText("");
+++            }
+++            if (getprop("f16/avionics/cara-on")) {
+++                #1F-F16CJ-34-1 page 1-224
+++                ralt.setText(sprintf("%4d",getprop("position/altitude-agl-ft")));
+++            } else {
+++                ralt.setText("");
+++            }
+++        } else {
+++            lat.setText("");
+++            lon.setText("");
+++        }
+++        if (!getprop("/aircraft/flir/target/auto-track") or flir_updater.click_coord_cam == nil) {
+++            setprop("sim/view[105]/heading-offset-deg", -getprop("sim/current-view/heading-offset-deg"));
+++            setprop("sim/view[105]/pitch-offset-deg", getprop("sim/current-view/pitch-offset-deg"));
+++        }
+++        setprop("sim/current-view/x-offset-m",0.8536);
+++        setprop("sim/current-view/y-offset-m",-1.4121);
+++        setprop("sim/current-view/z-offset-m",-2.5856);
+++    } else {
+++        # remove FLIR effects and disable TGP view
+++        setprop("sim/rendering/als-filters/use-IR-vision", 0);
+++        setprop("sim/view[105]/enabled", 0);#!getprop("gear/gear/wow"));
+++        #lock.hide();
+++        #setprop("f16/avionics/lock-flir",0.05);
+++    }
+++
+++    steerlock = 0;
+++    var follow = 0;
+++    if (armament.contactPoint !=nil and armament.contactPoint.get_range()>35 and armament.contactPoint.get_Callsign() != "GPS-Spot") {
+++        print("TGP attempted lock at 35+ nm: ",armament.contactPoint.get_range());
+++        armament.contactPoint = nil;
+++    }
+++    var gpps = 0;
+++    if (armament.contactPoint == nil or !enable) {
+++        # no TGP lock
+++        if (armament.contact == nil and enable and masterMode) {# we do not check for get_display here since as long as something is selected we dont show steerpoint.
+++            if (steerpoints.getCurrentNumber() != 0) {
+++                # TGP follow steerpoint
+++                hiddenMode = AG;
+++                var stpt = steerpoints.getCurrent();
+++                var ele = stpt.alt;
+++                var lat = stpt.lat;
+++                var lon = stpt.lon;
+++                if (ele == nil) {
+++                    ele = 0;
+++                }
+++                ele *= FT2M;
+++                var ele2 = geo.elevation(lat,lon);
+++                if (ele2 != nil) {
+++                    ele = ele2;
+++                }
+++                var sp = geo.Coord.new();
+++                sp.set_latlon(lat,lon,ele);
+++                flir_updater.click_coord_cam = sp;
+++                setprop("/aircraft/flir/target/auto-track", 1);
+++                if (callsign != "#"~steerpoints.getCurrentNumber()) {
+++                    # we switched steerpoint or from radar to steerpoint
+++                    flir_updater.offsetP = 0;
+++                    flir_updater.offsetH = 0;
+++                }
+++                callsign = "#"~steerpoints.getCurrentNumber();
+++                steerlock = 1;
+++                steer = 1;
+++            } else {
+++                # TGP not follow, locked from aircraft
+++                hiddenMode = AG;
+++                setprop("/aircraft/flir/target/auto-track", 0);
+++                flir_updater.click_coord_cam = nil;
+++                flir_updater.offsetP = 0;
+++                flir_updater.offsetH = 0;
+++                steer = 0;
+++                callsign = nil;
+++            }
+++        } elsif (armament.contact != nil and armament.contact.isVisible() and enable and masterMode) {
+++            # TGP follow radar lock
+++            flir_updater.click_coord_cam = armament.contact.get_Coord();
+++            setprop("/aircraft/flir/target/auto-track", 1);
+++            if (callsign != armament.contact.getUnique()) {
+++                flir_updater.offsetP = 0;
+++                flir_updater.offsetH = 0;
+++            }
+++            callsign = armament.contact.getUnique();
+++            hiddenMode = armament.contact.get_type() == armament.AIR?AA:AG;
+++            steer = 0;
+++        } else {
+++            hiddenMode = AG;
+++            setprop("/aircraft/flir/target/auto-track", 0);
+++            flir_updater.click_coord_cam = nil;
+++            callsign = nil;
+++            flir_updater.offsetP = 0;
+++            flir_updater.offsetH = 0;
+++            steer = 0;
+++        }
+++        lock_tgp = 0;
+++        gps = 0;
+++    } else {
+++        # TGP lock
+++        var vis = 1;
+++        line10.show();
+++        gpss = armament.contactPoint.get_Callsign() == "GPS-Spot";# GPS-Spot only used by "program GPS dialog"
+++        if (armament.contactPoint.get_Callsign() != "TGP-Spot" and !gps and !gpss and !steer) {
+++            # we do not check for visibility if:
+++            # - following steerpoint
+++            # - a GPS coord has been entered manually by "program GPS dialog"
+++            follow = 1;
+++            vis = radar_system.terrain.fastTerrainCheck(armament.contactPoint);
+++            if (vis > 0) vis = 1;
+++        }
+++        if (!vis or !masterMode) {
+++            setprop("/aircraft/flir/target/auto-track", 0);
+++            flir_updater.click_coord_cam = nil;
+++            callsign = nil;
+++            flir_updater.offsetP = 0;
+++            flir_updater.offsetH = 0;
+++            lock_tgp = 0;
+++            armament.contactPoint = nil;print("No vis on TGP lock");
+++            hiddenMode = AG;
+++        } else {
+++            lock_tgp = 1;
+++            flir_updater.click_coord_cam = armament.contactPoint.get_Coord();
+++            #callsign = armament.contactPoint.getUnique();
+++            setprop("/aircraft/flir/target/auto-track", 1);
+++            #flir_updater.offsetP = 0;
+++            #flir_updater.offsetH = 0;# commented so we get back to where we were when unlocking
+++        }
+++    }
+++    setprop("f16/avionics/tgp-lock", lock_tgp);#used in HUD
+++
+++    if (getprop("f16/stores/tgp-mounted") and enable) {
+++        if (lock_tgp and !lock_tgp_last) {
+++            interpolate("f16/avionics/lock-flir",1,1.5);
+++        } elsif (!lock_tgp) {
+++            setprop("f16/avionics/lock-flir",0.05);
+++        }
+++        lock_tgp_last = lock_tgp;
+++        if (lock_tgp) {
+++            line1box.show();
+++            line9.hide();
+++            line11.hide();
+++            line12.hide();
+++            line14.hide();
+++            line15.hide();
+++        } else {
+++            line1box.hide();
+++            line9.show();
+++            line11.show();
+++            line12.show();
+++            line14.show();
+++            line15.show();
+++        }
+++        if (lock_tgp and gps) {
+++            midl.setText(sprintf("%s      %s", "GPS", getprop("controls/armament/laser-arm-dmd")?"L":""));
+++        } elsif (lock_tgp and follow) {
+++            midl.setText(sprintf("%s POINT %s", gps?"GPS":(ir==1?"IR":"TV"), getprop("controls/armament/laser-arm-dmd")?"L":""));
+++        } elsif (lock_tgp) {
+++            midl.setText(sprintf("%s AREA  %s", gps?"GPS":(ir==1?"IR":"TV"), getprop("controls/armament/laser-arm-dmd")?"L":""));
+++        } elsif (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil and steerlock) {
+++            midl.setText(sprintf("STPT %s  %s", "#"~steerpoints.getCurrentNumber(), getprop("controls/armament/laser-arm-dmd")?"L":""));
+++        } elsif (getprop("/aircraft/flir/target/auto-track") and flir_updater.click_coord_cam != nil) {
+++            midl.setText(sprintf("  RADAR  %s", getprop("controls/armament/laser-arm-dmd")?"L":""));
+++        } else {
+++            midl.setText(sprintf("         %s", getprop("controls/armament/laser-arm-dmd")?"L":""));
+++        }
+++
+++        var scaleLock = getprop("f16/avionics/lock-flir");
+++        lock.setScale(scaleLock,scaleLock);
+++        lock.setStrokeLineWidth(1/scaleLock);
+++        if (scaleLock != 0.05) {
+++            lock.show();
+++        } else {
+++            lock.hide();
+++        }
+++        lock.update();
+++
+++        # animate the LANTIRN camera:
+++        var b = geo.normdeg180(getprop("sim/view[105]/heading-offset-deg"));
+++        var p = getprop("sim/view[105]/pitch-offset-deg");
+++        var polarL = math.sqrt(p*p+b*b);
+++        var polarD = polarL!=0 and b!=0?math.atan2(p,b)*R2D:-90;
+++        setprop("aircraft/flir/swivel/pitch-deg",polarL);
+++        setprop("aircraft/flir/swivel/roll-deg",polarD);
+++    } elsif (!masterMode) {
+++        lock.hide();
+++    }
+++    var dt = systime();
+++    if (viewName == "TGP" and getprop("f16/stores/tgp-mounted") and enable) {
+++        var cx = -getprop("/controls/displays/cursor-slew-x-delta");
+++        var cy = -getprop("/controls/displays/cursor-slew-y-delta");
+++        setprop("/controls/displays/cursor-slew-x-delta",0);
+++        setprop("/controls/displays/cursor-slew-y-delta",0);
+++        var modifier = getprop("/controls/displays/tgp-movement-modifier");
+++        if (!lock_tgp and (cy != 0 or cx != 0)) {
+++            gps = 0;
+++            var fov = getprop("sim/current-view/field-of-view");
+++            #var tme = dt - dt_old;
+++            if (getprop("/aircraft/flir/target/auto-track")) {
+++                var dist_modi = 1.0;
+++                if (flir_updater.click_coord_cam != nil) {
+++                    # 5nm is 5.0, 50 nm is 1.0
+++                    dist_modi = 5 + ((flir_updater.click_coord_cam.direct_distance_to(radar_system.self.getCoord())*M2NM - 5) / (50 - 5)) * (1 - 5);
+++                }
+++                flir_updater.offsetP += dist_modi*modifier*cy*fov/camera_movement_speed_lock;
+++                flir_updater.offsetH -= dist_modi*modifier*cx*fov/camera_movement_speed_lock;
+++            } else {
+++                setprop("sim/current-view/pitch-offset-deg",getprop("sim/current-view/pitch-offset-deg")+modifier*cy*fov/camera_movement_speed_free);
+++                setprop("sim/current-view/heading-offset-deg",getprop("sim/current-view/heading-offset-deg")+modifier*cx*fov/camera_movement_speed_free);
+++            }
+++        }
+++    }
+++    dt_old = dt;
+++}
+++
+++var flooptimer = nil;# started from f16.nas
+++
+++var dt_old = 0;
+++
+++var line1 = nil;
+++var line1box = nil;
+++var line2 = nil;
+++var line3 = nil;
+++var line4 = nil;
+++var line6 = nil;
+++var line7 = nil;
+++var line10 = nil;
+++var line11 = nil;
+++var line12 = nil;
+++var line13 = nil;
+++var line14 = nil;
+++var line15 = nil;
+++var line20 = nil;
+++var cross = nil;
+++var lock = nil;
+++var zoom = nil;
+++var bott = nil;
+++var ralt = nil;
+++var lat = nil;
+++var lon = nil;
+++var line9 = nil;
+++var midl = nil;
+++var ir = 1;
+++var lasercode = int(rand()*1778+1111);setprop("f16/avionics/laser-code",lasercode);
+++var callsign = nil;
+++var lock_tgp = 0;
+++var lock_tgp_last = 0;
+++var wide = 1;
+++var zoomlvl = 1.0;
+++var gps = 0;# set from Program GPS dialog
+++var steer = 0;
+++var STBY = 0;
+++var AG = 1;
+++var AA = 2;
+++var masterMode = STBY;
+++var hiddenMode = AG;
+++var pullup_cue_3 = nil;
+++
+++var canvasMFDext = nil;
+++var callInit = func {
+++  canvasMFDext = canvas.new({
+++        "name": "MFD-EXT",
+++        "size": [256, 256],
+++        "view": [256, 256],
+++        "mipmapping": 1
+++  });
+++
+++  canvasMFDext.addPlacement({"node": "MFDimage3", "texture": "tranbg.png"});
+++  canvasMFDext.setColorBackground(1.00, 1.00, 1.00, 0.00);
+++
+++  dedGroup = canvasMFDext.createGroup();
+++  dedGroup.show();
+++  var color = [getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"),1];
+++  line1 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("left-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("LOCK")
+++        .setTranslation(5, 256*0.20);# 1
+++  line1box = dedGroup.createChild("path")
+++        .moveTo(0,-7)
+++        .vert(14)
+++        .horiz(35)
+++        .vert(-14)
+++        .horiz(-35)
+++        .setStrokeLineWidth(1)
+++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+++        .hide()
+++        .setTranslation(5, 256*0.20);
+++  line2 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("left-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("ZOOM")
+++        .setTranslation(5, 256*0.35);# 2
+++  line3 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("left-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("STBY")
+++        .setTranslation(5, 256*0.50);# 3
+++  line4 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("left-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("")
+++        .setTranslation(5, 256*0.65);# 4
+++  line6 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("right-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("WHOT")
+++        .setTranslation(256-5, 256*0.2);# 6
+++  line7 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("right-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("XFER")
+++        .hide()
+++        .setTranslation(256-5, 256*0.35);# 7
+++  line9 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("right-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("CZ")
+++        .hide()
+++        .setTranslation(256-5, 256*0.65);# 9
+++  line10 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("right-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("MARK")
+++        .hide()
+++        .setTranslation(256-5, 256*0.8);# 10
+++  line11 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("center-top")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("UP")
+++        .setTranslation(256*0.2, 5);# 11
+++  line12 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("center-top")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("DOWN")
+++        .setTranslation(256*0.35, 5);# 12
+++  line13 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("center-top")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("WIDE")
+++        .setTranslation(256*0.50, 5);# 13
+++  line14 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("center-top")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("LEFT")
+++        .setTranslation(256*0.65, 5);# 14
+++  line15 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("center-top")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("RGHT")
+++        .setTranslation(256*0.8, 5);# 15
+++  line20 = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("center-bottom")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("BACK")
+++        .setTranslation(256*0.8, 256-5);# 20
+++
+++    zoom = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+++        .setAlignment("center-top")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("1.0X")
+++        .setTranslation(256*0.5, 20);
+++    midl = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+++        .setAlignment("center-bottom")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("IR POINT    L")
+++        .setTranslation(256*0.5, 256*0.8);
+++    bott = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"))
+++        .setAlignment("center-bottom")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("13.0  CMBT  1538")
+++        .setTranslation(256*0.5, 256*0.9);
+++    ralt = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("right-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("RALT")
+++        .setTranslation(256-25, 256*0.1);
+++    lat = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("left-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("LAT")
+++        .setTranslation(50, 256*0.2);
+++    lon = dedGroup.createChild("text")
+++        .setFontSize(13, 1)
+++        .setColor(color)
+++        .setAlignment("left-center")
+++        .setFont("LiberationFonts/LiberationMono-Bold.ttf")
+++        .setText("LON")
+++        .setTranslation(50, 256*0.25);
+++
+++  cross = dedGroup.createChild("path")
+++            .moveTo(128,0)
+++            .vert(120)
+++            .moveTo(128,256)
+++            .vert(-120)
+++            .moveTo(0,128)
+++            .horiz(120)
+++            .moveTo(256,128)
+++            .horiz(-120)
+++            .setStrokeLineWidth(1)
+++            .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"));
+++    lock = dedGroup.createChild("path")
+++            #.setCenter(128,128)
+++            .moveTo(48,48)
+++            .vert(-96)
+++            .horiz(-96)
+++            .vert(96)
+++            .horiz(96)
+++            .hide()
+++            .setTranslation(128,128)
+++            .setStrokeLineWidth(1)
+++            .setColor(getprop("/sim/model/MFD-color/text1/red"),getprop("/sim/model/MFD-color/text1/green"),getprop("/sim/model/MFD-color/text1/blue"));
+++
+++    pullup_cue_3 = canvasMFDext.createGroup().set("z-index", 9000).hide();
+++    pullup_cue_3.createChild("path")
+++               .moveTo(0, 0)
+++               .lineTo(256, 256)
+++               .moveTo(0, 256)
+++               .lineTo(256, 0)
+++               .setStrokeLineWidth(3)
+++               .setColor([getprop("/sim/model/MFD-color/circle1/red"), getprop("/sim/model/MFD-color/circle1/green"), getprop("/sim/model/MFD-color/circle1/blue")]);
+++};
++diff --git a/Systems/b1-payload.xml b/Systems/b1-payload.xml
++index 089126a..f733d16 100644
++--- a/Systems/b1-payload.xml
+++++ b/Systems/b1-payload.xml
++@@ -329,7 +329,7 @@
++             <terminal-dive-time type="double">12.0</terminal-dive-time>
++             <seeker-angular-speed-dps type="double">150</seeker-angular-speed-dps>
++             <ready-time type="double">300</ready-time>
++-            <requires-power-on type="bool">true</requires-power-on>
+++            <requires-power-on type="bool">false</requires-power-on>
++             <power-on-battery-time type="double">2700</power-on-battery-time>
++             <ejector-speed-fps type="double">5</ejector-speed-fps>
++             <telemetry type="bool">false</telemetry>
++diff --git a/gui/dialogs/missile-view-select.xml b/gui/dialogs/missile-view-select.xml
++new file mode 100644
++index 0000000..10eed96
++--- /dev/null
+++++ b/gui/dialogs/missile-view-select.xml
++@@ -0,0 +1,72 @@
+++<?xml version="1.0" encoding="iso-8859-1"?>
+++
+++<PropertyList>
+++  <name>missile-view-select</name>
+++  <dialog-name>missile-view-select</dialog-name>
+++  <x>46</x>
+++  <y>33</y>
+++  <layout>hbox</layout>
+++  <default-padding>0</default-padding>
+++
+++  <nasal>
+++    <open>
+++      var self = cmdarg();
+++      var dlg = props.globals.getNode("sim/gui/dialogs/missile-view-select", 1);
+++      dlg.getNode("open", 1).setBoolValue(1);
+++      var maxh = getprop("sim/startup/ysize") - 50;
+++      var gui = getprop("sim/gui/current-style");
+++      var baseline = getprop("/sim/gui/style[" ~ gui ~ "]/fonts/gui/baseline-height") or 21;
+++      var list = cmdarg().getNode("list");
+++
+++      var data = view.missile_view_handler.list;
+++      var height = size(data) * baseline;
+++      if (height > maxh)
+++        height = maxh;
+++      list.getNode("pref-height").setValue(height);
+++      list.removeChildren("value");
+++
+++      var entries = {};
+++      forindex (var i; data) {
+++        if (i == 0) {
+++          var ident = var myself = '[' ~ data[i].callsign ~ ']';
+++          list.getChild("value", size(data), 1).setValue(ident);
+++        } else {
+++          var ident = '"' ~ data[i].callsign ~ '"';
+++          list.getChild("value", i - 1, 1).setValue(ident);
+++        }
+++        entries[ident] = data[i].callsign;
+++      }
+++
+++      var select = func {
+++        var e = dlg.initNode("choice", "").getValue();
+++        if (e == myself or contains(view.myModel.callsign, entries[e]))
+++          view.missile_view_handler.select(which: entries[e], by_callsign: 1);
+++        else
+++          settimer(func fgcommand("dialog-show", self), 0);
+++      }
+++    </open>
+++
+++    <close>
+++      dlg.getNode("open").setValue(0);
+++    </close>
+++  </nasal>
+++
+++  <list>
+++    <legend />
+++    <pref-height>100</pref-height>
+++    <pref-width>250</pref-width>
+++    <border>0</border>
+++    <property>/sim/gui/dialogs/missile-view-select/choice</property>
+++    <binding>
+++      <command>dialog-apply</command>
+++    </binding>
+++    <binding>
+++      <command>nasal</command>
+++      <script>select()</script>
+++    </binding>
+++    <binding>
+++      <command>dialog-close</command>
+++    </binding>
+++  </list>
+++
+++</PropertyList>
++diff --git a/gui/dialogs/missile-view.xml b/gui/dialogs/missile-view.xml
++new file mode 100644
++index 0000000..4bd01d2
++--- /dev/null
+++++ b/gui/dialogs/missile-view.xml
++@@ -0,0 +1,90 @@
+++<?xml version="1.0" encoding="iso-8859-1"?>
+++
+++<PropertyList>
+++  <name>missile-view</name>
+++  <x>5</x>
+++  <y>3</y>
+++  <layout>hbox</layout>
+++  <default-padding>0</default-padding>
+++
+++  <color>
+++    <enabled>false</enabled>
+++    <red>0</red>
+++    <green>0</green>
+++    <blue>0</blue>
+++    <alpha>0</alpha>
+++  </color>
+++
+++  <button>
+++    <legend>&lt;</legend>
+++    <pref-width>20</pref-width>
+++    <pref-height>20</pref-height>
+++    <color>
+++      <red>0.5</red>
+++      <green>0.5</green>
+++      <blue>0.5</blue>
+++      <alpha>0.3</alpha>
+++    </color>
+++    <binding>
+++      <command>nasal</command>
+++      <script>view.missile_view_handler.next(-1)</script>
+++    </binding>
+++  </button>
+++
+++  <button>
+++    <legend>&gt;</legend>
+++    <pref-width>20</pref-width>
+++    <pref-height>20</pref-height>
+++    <color>
+++      <red>0.5</red>
+++      <green>0.5</green>
+++      <blue>0.5</blue>
+++      <alpha>0.3</alpha>
+++    </color>
+++    <binding>
+++      <command>nasal</command>
+++      <script>view.missile_view_handler.next(1)</script>
+++    </binding>
+++  </button>
+++
+++  <whatever>
+++    <pref-width>6</pref-width>
+++  </whatever>
+++
+++  <text>
+++    <pref-width>70</pref-width>
+++    <live>1</live>
+++    <property>/sim/current-view/missile-view</property>
+++    <color>
+++      <red>1</red>
+++      <green>1</green>
+++      <blue>1</blue>
+++      <alpha>1</alpha>
+++    </color>
+++    <font>
+++      <name>HELVETICA_14</name>
+++    </font>
+++  </text>
+++
+++  <button>
+++    <legend>list</legend>
+++    <pref-width>40</pref-width>
+++    <border>0</border>
+++    <color>
+++      <red>1</red>
+++      <green>1</green>
+++      <blue>1</blue>
+++      <alpha>0</alpha>
+++    </color>
+++    <binding>
+++      <command>nasal</command>
+++      <script>
+++if (size(view.missile_view_handler.list) &lt;= 1)
+++    return;
+++var isopen = !!getprop("sim/gui/dialogs/missile-view-select/open");
+++var toggle = isopen ? "dialog-close" : "dialog-show";
+++fgcommand(toggle, props.Node.new({ "dialog-name": "missile-view-select" }));
+++      </script>
+++    </binding>
+++  </button>
+++</PropertyList>
++diff --git a/Dialogs/targeting_comp.xml b/gui/dialogs/targeting_comp.xml
++similarity index 97%
++rename from Dialogs/targeting_comp.xml
++rename to gui/dialogs/targeting_comp.xml
++index c6da14e..2162860 100644
++--- a/Dialogs/targeting_comp.xml
+++++ b/gui/dialogs/targeting_comp.xml
++@@ -1,3 +1,4 @@
+++<?xml version="1.0"?>
++ <PropertyList>
++ 
++     <name>targeting_comp</name>
++@@ -70,6 +71,20 @@
++                         <command>dialog-apply</command>
++                     </binding>
++                 </input>
+++                <input>
+++                    <property>/ai/guided/bay0/bomb[0]/target-altitude</property>
+++                    <binding>
+++                        <command>dialog-apply</command>
+++                    </binding>
+++                </input>
+++                <button>
+++                    <legend>Select</legend>
+++                    <halign>center</halign>
+++                    <binding>
+++                        <command>nasal</command>
+++                        <script>data.select(0,0);</script>
+++                    </binding>
+++                </button>
++             </group>
++             <group>
++                 <layout>hbox</layout>
+diff --git a/gui/dialogs/missile-view-select.xml b/gui/dialogs/missile-view-select.xml
+new file mode 100644
+index 0000000..10eed96
+--- /dev/null
++++ b/gui/dialogs/missile-view-select.xml
+@@ -0,0 +1,72 @@
++<?xml version="1.0" encoding="iso-8859-1"?>
++
++<PropertyList>
++  <name>missile-view-select</name>
++  <dialog-name>missile-view-select</dialog-name>
++  <x>46</x>
++  <y>33</y>
++  <layout>hbox</layout>
++  <default-padding>0</default-padding>
++
++  <nasal>
++    <open>
++      var self = cmdarg();
++      var dlg = props.globals.getNode("sim/gui/dialogs/missile-view-select", 1);
++      dlg.getNode("open", 1).setBoolValue(1);
++      var maxh = getprop("sim/startup/ysize") - 50;
++      var gui = getprop("sim/gui/current-style");
++      var baseline = getprop("/sim/gui/style[" ~ gui ~ "]/fonts/gui/baseline-height") or 21;
++      var list = cmdarg().getNode("list");
++
++      var data = view.missile_view_handler.list;
++      var height = size(data) * baseline;
++      if (height > maxh)
++        height = maxh;
++      list.getNode("pref-height").setValue(height);
++      list.removeChildren("value");
++
++      var entries = {};
++      forindex (var i; data) {
++        if (i == 0) {
++          var ident = var myself = '[' ~ data[i].callsign ~ ']';
++          list.getChild("value", size(data), 1).setValue(ident);
++        } else {
++          var ident = '"' ~ data[i].callsign ~ '"';
++          list.getChild("value", i - 1, 1).setValue(ident);
++        }
++        entries[ident] = data[i].callsign;
++      }
++
++      var select = func {
++        var e = dlg.initNode("choice", "").getValue();
++        if (e == myself or contains(view.myModel.callsign, entries[e]))
++          view.missile_view_handler.select(which: entries[e], by_callsign: 1);
++        else
++          settimer(func fgcommand("dialog-show", self), 0);
++      }
++    </open>
++
++    <close>
++      dlg.getNode("open").setValue(0);
++    </close>
++  </nasal>
++
++  <list>
++    <legend />
++    <pref-height>100</pref-height>
++    <pref-width>250</pref-width>
++    <border>0</border>
++    <property>/sim/gui/dialogs/missile-view-select/choice</property>
++    <binding>
++      <command>dialog-apply</command>
++    </binding>
++    <binding>
++      <command>nasal</command>
++      <script>select()</script>
++    </binding>
++    <binding>
++      <command>dialog-close</command>
++    </binding>
++  </list>
++
++</PropertyList>
+diff --git a/gui/dialogs/missile-view.xml b/gui/dialogs/missile-view.xml
+new file mode 100644
+index 0000000..4bd01d2
+--- /dev/null
++++ b/gui/dialogs/missile-view.xml
+@@ -0,0 +1,90 @@
++<?xml version="1.0" encoding="iso-8859-1"?>
++
++<PropertyList>
++  <name>missile-view</name>
++  <x>5</x>
++  <y>3</y>
++  <layout>hbox</layout>
++  <default-padding>0</default-padding>
++
++  <color>
++    <enabled>false</enabled>
++    <red>0</red>
++    <green>0</green>
++    <blue>0</blue>
++    <alpha>0</alpha>
++  </color>
++
++  <button>
++    <legend>&lt;</legend>
++    <pref-width>20</pref-width>
++    <pref-height>20</pref-height>
++    <color>
++      <red>0.5</red>
++      <green>0.5</green>
++      <blue>0.5</blue>
++      <alpha>0.3</alpha>
++    </color>
++    <binding>
++      <command>nasal</command>
++      <script>view.missile_view_handler.next(-1)</script>
++    </binding>
++  </button>
++
++  <button>
++    <legend>&gt;</legend>
++    <pref-width>20</pref-width>
++    <pref-height>20</pref-height>
++    <color>
++      <red>0.5</red>
++      <green>0.5</green>
++      <blue>0.5</blue>
++      <alpha>0.3</alpha>
++    </color>
++    <binding>
++      <command>nasal</command>
++      <script>view.missile_view_handler.next(1)</script>
++    </binding>
++  </button>
++
++  <whatever>
++    <pref-width>6</pref-width>
++  </whatever>
++
++  <text>
++    <pref-width>70</pref-width>
++    <live>1</live>
++    <property>/sim/current-view/missile-view</property>
++    <color>
++      <red>1</red>
++      <green>1</green>
++      <blue>1</blue>
++      <alpha>1</alpha>
++    </color>
++    <font>
++      <name>HELVETICA_14</name>
++    </font>
++  </text>
++
++  <button>
++    <legend>list</legend>
++    <pref-width>40</pref-width>
++    <border>0</border>
++    <color>
++      <red>1</red>
++      <green>1</green>
++      <blue>1</blue>
++      <alpha>0</alpha>
++    </color>
++    <binding>
++      <command>nasal</command>
++      <script>
++if (size(view.missile_view_handler.list) &lt;= 1)
++    return;
++var isopen = !!getprop("sim/gui/dialogs/missile-view-select/open");
++var toggle = isopen ? "dialog-close" : "dialog-show";
++fgcommand(toggle, props.Node.new({ "dialog-name": "missile-view-select" }));
++      </script>
++    </binding>
++  </button>
++</PropertyList>
+diff --git a/Dialogs/targeting_comp.xml b/gui/dialogs/targeting_comp.xml
+similarity index 97%
+rename from Dialogs/targeting_comp.xml
+rename to gui/dialogs/targeting_comp.xml
+index c6da14e..2162860 100644
+--- a/Dialogs/targeting_comp.xml
++++ b/gui/dialogs/targeting_comp.xml
+@@ -1,3 +1,4 @@
++<?xml version="1.0"?>
+ <PropertyList>
+ 
+     <name>targeting_comp</name>
+@@ -70,6 +71,20 @@
+                         <command>dialog-apply</command>
+                     </binding>
+                 </input>
++                <input>
++                    <property>/ai/guided/bay0/bomb[0]/target-altitude</property>
++                    <binding>
++                        <command>dialog-apply</command>
++                    </binding>
++                </input>
++                <button>
++                    <legend>Select</legend>
++                    <halign>center</halign>
++                    <binding>
++                        <command>nasal</command>
++                        <script>data.select(0,0);</script>
++                    </binding>
++                </button>
+             </group>
+             <group>
+                 <layout>hbox</layout>
diff --git a/gui/dialogs/targeting_comp.xml b/gui/dialogs/targeting_comp.xml
new file mode 100644
index 0000000..39b9a61
--- /dev/null
+++ b/gui/dialogs/targeting_comp.xml
@@ -0,0 +1,1184 @@
+<?xml version="1.0"?>
+<PropertyList>
+    <name>targeting_comp</name>
+    <modal>false</modal>
+    <layout>vbox</layout>
+    <!-- <width>850</width> -->
+    <!--    <height>450</height>-->
+    <nasal>
+        <open><![CDATA[
+        setprop("b1/preplanning-status", "");
+        for ( var bay = 0; bay < 3; bay = bay + 1 ) {
+            for ( var rack = 0; rack < 8; rack = rack + 1 ) {
+                if (getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-altitude") == nil
+                    or getprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-altitude") == "") {
+                    setprop("/ai/guided/bay"~bay~"/bomb["~rack~"]/target-altitude", "0");
+                }
+            }
+        }
+        var load_stpts = func(path) {
+            data.loadSTPTs(path.getValue());
+        }
+        var save_stpts = func(path) {
+            data.saveSTPTs(path.getValue());
+        }
+
+        var defaultDirInFileSelector = getprop("/sim/fg-home") ~ "/Export";
+
+        var file_selector_dtc = gui.FileSelector.new(
+            callback: load_stpts, title: "Load data", button: "Load",
+            dir: defaultDirInFileSelector, dotfiles: 1, pattern: ["*.b1dtc"]);
+        var save_selector_dtc = gui.FileSelector.new(
+            callback: save_stpts, title: "Save data", button: "Save",
+            dir: defaultDirInFileSelector, dotfiles: 1, file: "b1-dtc-data.b1dtc", pattern: ["*.b1dtc"]);
+
+        data.status_update.start();
+    ]]></open>
+
+        <close><![CDATA[
+        file_selector_dtc.del();
+        save_selector_dtc.del();
+        data.status_update.stop();
+    ]]></close>
+    </nasal>
+    <group>
+        <layout>hbox</layout>
+        <text>
+            <halign>center</halign>
+            <label>Targeting Computer</label>
+        </text>
+    </group>
+    <hrule/>
+    <group>
+        <layout>hbox</layout>
+        <group>
+            <!-- ********************************* FWD BAY ************************************ -->
+            <layout>vbox</layout>
+
+            <group>
+                <layout>hbox</layout>
+                <text>
+                    <halign>center</halign>
+                    <label>FWD Bay</label>
+                </text>
+            </group>
+
+            <group>
+                <layout>hbox</layout>
+                <text>
+                    <halign>right</halign>
+                    <label>Latitude</label>
+                </text>
+                <text>
+                    <halign>center</halign>
+                    <label>Longitude</label>
+                </text>
+                <text>
+                    <halign>left</halign>
+                    <label>Altitude</label>
+                </text>
+            </group>
+
+            <group>
+                <layout>hbox</layout>
+
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>1 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay0/bomb[0]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[0]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[0]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[0]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,0);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>2 (%s):</format>
+<pref-width>80</pref-width>
+            
+            <property>/ai/guided/bay0/bomb[1]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[1]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[1]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[1]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,1);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>3 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay0/bomb[2]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[2]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[2]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[2]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,2);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>4 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay0/bomb[3]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[3]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[3]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[3]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,3);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>5 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay0/bomb[4]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[4]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[4]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[4]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,4);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>6 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay0/bomb[5]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[5]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[5]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[5]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,5);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>7 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay0/bomb[6]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[6]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[6]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[6]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,6);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>8 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay0/bomb[7]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[7]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[7]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay0/bomb[7]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(0,7);</script>
+                    </binding>
+                </button>
+            </group>
+        </group>
+        <vrule/>
+        <group>
+            <layout>vbox</layout>
+            <!-- ********************************* IMD BAY ************************************ -->
+            <group>
+                <layout>hbox</layout>
+                <text>
+                    <label>IMD Bay</label>
+                    <halign>center</halign>
+                </text>
+            </group>
+            <group>
+                <layout>hbox</layout>
+                <text>
+                    <halign>right</halign>
+                    <label>Latitude</label>
+                </text>
+                <text>
+                    <halign>center</halign>
+                    <label>Longitude</label>
+                </text>
+                <text>
+                    <halign>left</halign>
+                    <label>Altitude</label>
+                </text>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>1 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[0]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[0]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[0]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[0]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,0);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>2 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[1]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[1]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[1]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[1]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,1);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>3 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[2]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[2]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[2]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[2]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,2);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>4 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[3]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[3]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[3]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[3]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,3);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>5 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[4]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[4]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[4]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[4]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,4);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>6 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[5]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[5]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[5]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[5]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,5);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>7 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[6]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[6]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[6]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[6]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,6);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>8 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay1/bomb[7]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[7]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[7]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay1/bomb[7]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(1,7);</script>
+                    </binding>
+                </button>
+            </group>
+        </group>
+        <vrule/>
+        <group>
+            <layout>vbox</layout>
+            <!-- ********************************* AFT BAY ************************************ -->
+            <group>
+                <layout>hbox</layout>
+                <text>
+                    <label>AFT Bay</label>
+                    <halign>center</halign>
+                </text>
+            </group>
+            <group>
+                <layout>hbox</layout>
+                <text>
+                    <halign>right</halign>
+                    <label>Latitude</label>
+                </text>
+                <text>
+                    <halign>center</halign>
+                    <label>Longitude</label>
+                </text>
+                <text>
+                    <halign>left</halign>
+                    <label>Altitude</label>
+                </text>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>1 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[0]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[0]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[0]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[0]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,0);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>2 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[1]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[1]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[1]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[1]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,1);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>3 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[2]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[2]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[2]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[2]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,2);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>4 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[3]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[3]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[3]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[3]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,3);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>5 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[4]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[4]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[4]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[4]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,4);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>6 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[5]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[5]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[5]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[5]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,5);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>7 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[6]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[6]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[6]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[6]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,6);</script>
+                    </binding>
+                </button>
+            </group>
+            <group>
+                <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>8 (%s):</format>
+<pref-width>80</pref-width>
+            <property>/ai/guided/bay2/bomb[7]/status-text</property>
+        </text>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[7]/target-latitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[7]/target-longitude-deg</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <input>
+                    <live>true</live>
+                    <property>/ai/guided/bay2/bomb[7]/target-altitude</property>
+                    <binding>
+                        <command>dialog-apply</command>
+                    </binding>
+                </input>
+                <button>
+                    <legend>Select</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>data.select(2,7);</script>
+                    </binding>
+                </button>
+            </group>
+        </group>
+    </group>
+    <hrule/>
+    <group>
+        <layout>hbox</layout>
+        <text>
+            <halign>left</halign>
+            <live>true</live>
+            <format>I/O Status: %s</format>
+            <property>b1/preplanning-status</property>
+        </text>
+        <button>
+            <legend>Load DTC</legend>
+            <equal>true</equal>
+            <binding>
+                <command>nasal</command>
+                <script>file_selector_dtc.open()</script>
+            </binding>
+            <binding>
+                <command>dialog-update</command>
+            </binding>
+        </button>
+        <button>
+            <legend>Save DTC</legend>
+            <equal>true</equal>
+            <enable>
+                <value>1</value>
+            </enable>
+            <binding>
+                <command>dialog-apply</command>
+            </binding>
+            <binding>
+                <command>nasal</command>
+                <script>save_selector_dtc.open();</script>
+            </binding>
+        </button>
+    </group>
+    <hrule/>
+    <!-- ********************************* CLOSE BUTTON ************************************* -->
+    <group>
+        <layout>hbox</layout>
+                        <button>
+                    <legend>Toggle Power</legend>
+                    <halign>center</halign>
+                    <binding>
+                        <command>nasal</command>
+                        <script>pylons.fcs.togglePowerOn();</script>
+                    </binding>
+                </button>
+        <button>
+            <legend>Close</legend>
+            <halign>center</halign>
+            <binding>
+                <command>nasal</command>
+                <script>
+                    <![CDATA[
+		    data.syncData();
+	    ]]>
+                </script>
+            </binding>
+            <binding>
+                <command>dialog-close</command>
+            </binding>
+        </button>
+    </group>
+
+
+    <!--<text>
+      <label>Weapon Management</label>
+    </text>
+
+        var tlat = getprop("ai/guided/bay"~ b ~"/bomb["~ n ~"]/target-latitude-deg");
+  var tlong = getprop("ai/guided/bay"~ b ~"/bomb["~ n ~"]/target-longitude-deg");
+
+   <hrule/>
+
+    <nasal>
+      <open>
+      #nasal
+      </open>
+    </nasal>
+
+
+      <text>
+      <label>Load Weapons</label>
+     </text>
+      <text>
+      <label></label>
+     </text>
+    <group>
+     <layout>vbox</layout>
+
+      <text>
+      <label>Load bays with 8 guidable GBU-31 2000lb bombs</label>
+      <halign>left</halign>
+     </text>
+
+    <button>
+      <legend>Load Guided Ordonance - FWD</legend>
+      <default>true</default>
+      <pref-width>230</pref-width>
+        <binding>
+          <command>nasal</command>
+          <script>weapons.wpn_load(0)</script>
+        </binding>
+            <binding>
+              <command>dialog-apply</command>
+            </binding>
+    </button>-->
+
+</PropertyList>
\ No newline at end of file
